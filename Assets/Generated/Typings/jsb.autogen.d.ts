declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { ValueType, Array } from "System";
    /** Specifies Layers to use in a Physics.Raycast.
     */
    class LayerMask extends ValueType {
        constructor()
        static op_Implicit(mask: LayerMask): number
        static op_Implicit(intVal: number): LayerMask
        /** Given a layer number, returns the name of the layer as defined in either a Builtin or a User Layer in the.
         */
        static LayerToName(layer: number): string
        /** Given a layer name, returns the layer index as defined by either a Builtin or a User Layer in the.
         */
        static NameToLayer(layerName: string): number
        /** Given a set of layer names as defined by either a Builtin or a User Layer in the, returns the equivalent layer mask for all of them.
         * @param layerNames List of layer names to convert to a layer mask.
         * @returns The layer mask created from the layerNames. 
         */
        static GetMask(...layerNames: string[]): number
        /** Converts a layer mask value to an integer value.
         */
        value: number
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { ValueType, Array, Object as Object1 } from "System";
    /** Representation of RGBA colors.
     */
    class Color extends ValueType {
        constructor(r: number, g: number, b: number, a: number)
        constructor(r: number, g: number, b: number)
        $GetValue(index: number): number
        $SetValue(index: number, value: number): void
        /** Returns a nicely formatted string of this color.
         */
        toString(format: string): string
        toString(): string
        GetHashCode(): number
        Equals(other: Object1): boolean
        Equals(other: Color): boolean
        static op_Inequality(lhs: Color, rhs: Color): boolean
        /** Linearly interpolates between colors a and b by t.
         * @param a Color a.
         * @param b Color b.
         * @param t Float for combining a and b.
         */
        static Lerp(a: Color, b: Color, t: number): Color
        /** Linearly interpolates between colors a and b by t.
         */
        static LerpUnclamped(a: Color, b: Color, t: number): Color
        static op_Implicit(c: Color): Vector4
        static op_Implicit(v: Vector4): Color
        /** Calculates the hue, saturation and value of an RGB input color.
         * @param rgbColor An input color.
         * @param H Output variable for hue.
         * @param S Output variable for saturation.
         * @param V Output variable for value.
         */
        static RGBToHSV(rgbColor: Color, H: jsb.Out<number>, S: jsb.Out<number>, V: jsb.Out<number>): void
        /** Creates an RGB colour from HSV input.
         * @param H Hue [0..1].
         * @param S Saturation [0..1].
         * @param V Brightness value [0..1].
         * @param hdr Output HDR colours. If true, the returned colour will not be clamped to [0..1].
         * @returns An opaque colour with HSV matching the input. 
         */
        static HSVToRGB(H: number, S: number, V: number, hdr: boolean): Color
        /** Creates an RGB colour from HSV input.
         * @param H Hue [0..1].
         * @param S Saturation [0..1].
         * @param V Brightness value [0..1].
         * @param hdr Output HDR colours. If true, the returned colour will not be clamped to [0..1].
         * @returns An opaque colour with HSV matching the input. 
         */
        static HSVToRGB(H: number, S: number, V: number): Color
        // js_op_overloading: static +(a: Color, b: Color): Color
        // js_op_overloading: static -(a: Color, b: Color): Color
        // js_op_overloading: static *(a: Color, b: Color): Color
        // js_op_overloading: static *(a: Color, b: number): Color
        // js_op_overloading: static *(b: number, a: Color): Color
        // js_op_overloading: static /(a: Color, b: number): Color
        // js_op_overloading: static ==(lhs: Color, rhs: Color): boolean
        /** Solid red. RGBA is (1, 0, 0, 1).
         */
        static readonly red: Color
        /** Solid green. RGBA is (0, 1, 0, 1).
         */
        static readonly green: Color
        /** Solid blue. RGBA is (0, 0, 1, 1).
         */
        static readonly blue: Color
        /** Solid white. RGBA is (1, 1, 1, 1).
         */
        static readonly white: Color
        /** Solid black. RGBA is (0, 0, 0, 1).
         */
        static readonly black: Color
        /** Yellow. RGBA is (1, 0.92, 0.016, 1), but the color is nice to look at!
         */
        static readonly yellow: Color
        /** Cyan. RGBA is (0, 1, 1, 1).
         */
        static readonly cyan: Color
        /** Magenta. RGBA is (1, 0, 1, 1).
         */
        static readonly magenta: Color
        /** Gray. RGBA is (0.5, 0.5, 0.5, 1).
         */
        static readonly gray: Color
        /** English spelling for gray. RGBA is the same (0.5, 0.5, 0.5, 1).
         */
        static readonly grey: Color
        /** Completely transparent. RGBA is (0, 0, 0, 0).
         */
        static readonly clear: Color
        /** The grayscale value of the color. (Read Only)
         */
        readonly grayscale: number
        /** A linear value of an sRGB color.
         */
        readonly linear: Color
        /** A version of the color that has had the gamma curve applied.
         */
        readonly gamma: Color
        /** Returns the maximum color component value: Max(r,g,b).
         */
        readonly maxColorComponent: number
        /** Red component of the color.
         */
        r: number
        /** Green component of the color.
         */
        g: number
        /** Blue component of the color.
         */
        b: number
        /** Alpha component of the color (0 is transparent, 1 is opaque).
         */
        a: number
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    /** Representation of RGBA colors in 32 bit format.
     */
    class Color32 extends ValueType {
        constructor(r: jsb.byte, g: jsb.byte, b: jsb.byte, a: jsb.byte)
        $GetValue(index: number): jsb.byte
        $SetValue(index: number, value: jsb.byte): void
        /** Returns a nicely formatted string of this color.
         */
        toString(format: string): string
        toString(): string
        static op_Implicit(c: Color): Color32
        static op_Implicit(c: Color32): Color
        /** Linearly interpolates between colors a and b by t.
         */
        static Lerp(a: Color32, b: Color32, t: number): Color32
        /** Linearly interpolates between colors a and b by t.
         */
        static LerpUnclamped(a: Color32, b: Color32, t: number): Color32
        /** Red component of the color.
         */
        r: jsb.byte
        /** Green component of the color.
         */
        g: jsb.byte
        /** Blue component of the color.
         */
        b: jsb.byte
        /** Alpha component of the color.
         */
        a: jsb.byte
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { ValueType, Array, Object as Object1 } from "System";
    /** Representation of 2D vectors and points.
     */
    class Vector2 extends ValueType {
        constructor(x: number, y: number)
        $GetValue(index: number): number
        $SetValue(index: number, value: number): void
        /** Set x and y components of an existing Vector2.
         */
        Set(newX: number, newY: number): void
        /** Multiplies every component of this vector by the same component of scale.
         */
        Scale(scale: Vector2): void
        Normalize(): void
        /** Returns a nicely formatted string for this vector.
         */
        toString(format: string): string
        toString(): string
        GetHashCode(): number
        /** Returns true if the given vector is exactly equal to this vector.
         */
        Equals(other: Object1): boolean
        Equals(other: Vector2): boolean
        SqrMagnitude(): number
        /** Linearly interpolates between vectors a and b by t.
         */
        static Lerp(a: Vector2, b: Vector2, t: number): Vector2
        /** Linearly interpolates between vectors a and b by t.
         */
        static LerpUnclamped(a: Vector2, b: Vector2, t: number): Vector2
        /** Moves a point current towards target.
         */
        static MoveTowards(current: Vector2, target: Vector2, maxDistanceDelta: number): Vector2
        /** Multiplies two vectors component-wise.
         */
        static Scale(a: Vector2, b: Vector2): Vector2
        /** Reflects a vector off the vector defined by a normal.
         */
        static Reflect(inDirection: Vector2, inNormal: Vector2): Vector2
        /** Returns the 2D vector perpendicular to this 2D vector. The result is always rotated 90-degrees in a counter-clockwise direction for a 2D coordinate system where the positive Y axis goes up.
         * @param inDirection The input direction.
         * @returns The perpendicular direction. 
         */
        static Perpendicular(inDirection: Vector2): Vector2
        /** Dot Product of two vectors.
         */
        static Dot(lhs: Vector2, rhs: Vector2): number
        /** Returns the unsigned angle in degrees between from and to.
         * @param from The vector from which the angular difference is measured.
         * @param to The vector to which the angular difference is measured.
         */
        static Angle(from: Vector2, to: Vector2): number
        /** Returns the signed angle in degrees between from and to.
         * @param from The vector from which the angular difference is measured.
         * @param to The vector to which the angular difference is measured.
         */
        static SignedAngle(from: Vector2, to: Vector2): number
        /** Returns the distance between a and b.
         */
        static Distance(a: Vector2, b: Vector2): number
        /** Returns a copy of vector with its magnitude clamped to maxLength.
         */
        static ClampMagnitude(vector: Vector2, maxLength: number): Vector2
        static SqrMagnitude(a: Vector2): number
        /** Returns a vector that is made from the smallest components of two vectors.
         */
        static Min(lhs: Vector2, rhs: Vector2): Vector2
        /** Returns a vector that is made from the largest components of two vectors.
         */
        static Max(lhs: Vector2, rhs: Vector2): Vector2
        /** Gradually changes a vector towards a desired goal over time.
         * @param current The current position.
         * @param target The position we are trying to reach.
         * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
         * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
         * @param maxSpeed Optionally allows you to clamp the maximum speed.
         * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
         */
        static SmoothDamp(current: Vector2, target: Vector2, currentVelocity: jsb.Ref<Vector2>, smoothTime: number, maxSpeed: number, deltaTime: number): Vector2
        /** Gradually changes a vector towards a desired goal over time.
         * @param current The current position.
         * @param target The position we are trying to reach.
         * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
         * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
         * @param maxSpeed Optionally allows you to clamp the maximum speed.
         * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
         */
        static SmoothDamp(current: Vector2, target: Vector2, currentVelocity: jsb.Ref<Vector2>, smoothTime: number, maxSpeed: number): Vector2
        /** Gradually changes a vector towards a desired goal over time.
         * @param current The current position.
         * @param target The position we are trying to reach.
         * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
         * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
         * @param maxSpeed Optionally allows you to clamp the maximum speed.
         * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
         */
        static SmoothDamp(current: Vector2, target: Vector2, currentVelocity: jsb.Ref<Vector2>, smoothTime: number): Vector2
        static op_Inequality(lhs: Vector2, rhs: Vector2): boolean
        static op_Implicit(v: Vector3): Vector2
        static op_Implicit(v: Vector2): Vector3
        // js_op_overloading: static +(a: Vector2, b: Vector2): Vector2
        // js_op_overloading: static -(a: Vector2, b: Vector2): Vector2
        // js_op_overloading: static *(a: Vector2, b: Vector2): Vector2
        // js_op_overloading: static /(a: Vector2, b: Vector2): Vector2
        // js_op_overloading: static neg(a: Vector2): Vector2
        // js_op_overloading: static *(a: Vector2, d: number): Vector2
        // js_op_overloading: static *(d: number, a: Vector2): Vector2
        // js_op_overloading: static /(a: Vector2, d: number): Vector2
        // js_op_overloading: static ==(lhs: Vector2, rhs: Vector2): boolean
        /** Returns this vector with a magnitude of 1 (Read Only).
         */
        readonly normalized: Vector2
        /** Returns the length of this vector (Read Only).
         */
        readonly magnitude: number
        /** Returns the squared length of this vector (Read Only).
         */
        readonly sqrMagnitude: number
        /** Shorthand for writing Vector2(0, 0).
         */
        static readonly zero: Vector2
        /** Shorthand for writing Vector2(1, 1).
         */
        static readonly one: Vector2
        /** Shorthand for writing Vector2(0, 1).
         */
        static readonly up: Vector2
        /** Shorthand for writing Vector2(0, -1).
         */
        static readonly down: Vector2
        /** Shorthand for writing Vector2(-1, 0).
         */
        static readonly left: Vector2
        /** Shorthand for writing Vector2(1, 0).
         */
        static readonly right: Vector2
        /** Shorthand for writing Vector2(float.PositiveInfinity, float.PositiveInfinity).
         */
        static readonly positiveInfinity: Vector2
        /** Shorthand for writing Vector2(float.NegativeInfinity, float.NegativeInfinity).
         */
        static readonly negativeInfinity: Vector2
        /** X component of the vector.
         */
        x: number
        /** Y component of the vector.
         */
        y: number
        static readonly kEpsilon: number
        static readonly kEpsilonNormalSqrt: number
    }
}
declare module "UnityEngine" {
    import { ValueType, Object as Object1 } from "System";
    /** Representation of 2D vectors and points using integers.
     */
    class Vector2Int extends ValueType {
        constructor(x: number, y: number)
        $GetValue(index: number): number
        $SetValue(index: number, value: number): void
        /** Set x and y components of an existing Vector2Int.
         */
        Set(x: number, y: number): void
        /** Multiplies every component of this vector by the same component of scale.
         */
        Scale(scale: Vector2Int): void
        /** Clamps the Vector2Int to the bounds given by min and max.
         */
        Clamp(min: Vector2Int, max: Vector2Int): void
        /** Returns true if the objects are equal.
         */
        Equals(other: Object1): boolean
        Equals(other: Vector2Int): boolean
        GetHashCode(): number
        toString(): string
        /** Returns the distance between a and b.
         */
        static Distance(a: Vector2Int, b: Vector2Int): number
        /** Returns a vector that is made from the smallest components of two vectors.
         */
        static Min(lhs: Vector2Int, rhs: Vector2Int): Vector2Int
        /** Returns a vector that is made from the largest components of two vectors.
         */
        static Max(lhs: Vector2Int, rhs: Vector2Int): Vector2Int
        /** Multiplies two vectors component-wise.
         */
        static Scale(a: Vector2Int, b: Vector2Int): Vector2Int
        static op_Implicit(v: Vector2Int): Vector2
        static op_Explicit(v: Vector2Int): Vector3Int
        /** Converts a Vector2 to a Vector2Int by doing a Floor to each value.
         */
        static FloorToInt(v: Vector2): Vector2Int
        /** Converts a  Vector2 to a Vector2Int by doing a Ceiling to each value.
         */
        static CeilToInt(v: Vector2): Vector2Int
        /** Converts a  Vector2 to a Vector2Int by doing a Round to each value.
         */
        static RoundToInt(v: Vector2): Vector2Int
        static op_Inequality(lhs: Vector2Int, rhs: Vector2Int): boolean
        // js_op_overloading: static neg(v: Vector2Int): Vector2Int
        // js_op_overloading: static +(a: Vector2Int, b: Vector2Int): Vector2Int
        // js_op_overloading: static -(a: Vector2Int, b: Vector2Int): Vector2Int
        // js_op_overloading: static *(a: Vector2Int, b: Vector2Int): Vector2Int
        // js_op_overloading: static *(a: number, b: Vector2Int): Vector2Int
        // js_op_overloading: static *(a: Vector2Int, b: number): Vector2Int
        // js_op_overloading: static /(a: Vector2Int, b: number): Vector2Int
        // js_op_overloading: static ==(lhs: Vector2Int, rhs: Vector2Int): boolean
        /** X component of the vector.
         */
        x: number
        /** Y component of the vector.
         */
        y: number
        /** Returns the length of this vector (Read Only).
         */
        readonly magnitude: number
        /** Returns the squared length of this vector (Read Only).
         */
        readonly sqrMagnitude: number
        /** Shorthand for writing Vector2Int (0, 0).
         */
        static readonly zero: Vector2Int
        /** Shorthand for writing Vector2Int (1, 1).
         */
        static readonly one: Vector2Int
        /** Shorthand for writing Vector2Int (0, 1).
         */
        static readonly up: Vector2Int
        /** Shorthand for writing Vector2Int (0, -1).
         */
        static readonly down: Vector2Int
        /** Shorthand for writing Vector2Int (-1, 0).
         */
        static readonly left: Vector2Int
        /** Shorthand for writing Vector2Int (1, 0).
         */
        static readonly right: Vector2Int
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { ValueType, Array, Object as Object1 } from "System";
    /** Representation of 3D vectors and points.
     */
    class Vector3 extends ValueType {
        constructor(x: number, y: number, z: number)
        constructor(x: number, y: number)
        $GetValue(index: number): number
        $SetValue(index: number, value: number): void
        /** Set x, y and z components of an existing Vector3.
         */
        Set(newX: number, newY: number, newZ: number): void
        /** Multiplies every component of this vector by the same component of scale.
         */
        Scale(scale: Vector3): void
        GetHashCode(): number
        /** Returns true if the given vector is exactly equal to this vector.
         */
        Equals(other: Object1): boolean
        Equals(other: Vector3): boolean
        Normalize(): void
        /** Returns a nicely formatted string for this vector.
         */
        toString(format: string): string
        toString(): string
        /** Spherically interpolates between two vectors.
         */
        static Slerp(a: Vector3, b: Vector3, t: number): Vector3
        /** Spherically interpolates between two vectors.
         */
        static SlerpUnclamped(a: Vector3, b: Vector3, t: number): Vector3
        /** Makes vectors normalized and orthogonal to each other.
         */
        static OrthoNormalize(normal: jsb.Ref<Vector3>, tangent: jsb.Ref<Vector3>, binormal: jsb.Ref<Vector3>): void
        /** Makes vectors normalized and orthogonal to each other.
         */
        static OrthoNormalize(normal: jsb.Ref<Vector3>, tangent: jsb.Ref<Vector3>): void
        /** Rotates a vector current towards target.
         * @param current The vector being managed.
         * @param target The vector.
         * @param maxRadiansDelta The maximum angle in radians allowed for this rotation.
         * @param maxMagnitudeDelta The maximum allowed change in vector magnitude for this rotation.
         * @returns The location that RotateTowards generates. 
         */
        static RotateTowards(current: Vector3, target: Vector3, maxRadiansDelta: number, maxMagnitudeDelta: number): Vector3
        /** Linearly interpolates between two points.
         * @param a Start value, returned when t = 0.
         * @param b End value, returned when t = 1.
         * @param t Value used to interpolate between a and b.
         * @returns Interpolated value, equals to a + (b - a) * t. 
         */
        static Lerp(a: Vector3, b: Vector3, t: number): Vector3
        /** Linearly interpolates between two vectors.
         */
        static LerpUnclamped(a: Vector3, b: Vector3, t: number): Vector3
        /** Calculate a position between the points specified by current and target, moving no farther than the distance specified by maxDistanceDelta.
         * @param current The position to move from.
         * @param target The position to move towards.
         * @param maxDistanceDelta Distance to move current per call.
         * @returns The new position. 
         */
        static MoveTowards(current: Vector3, target: Vector3, maxDistanceDelta: number): Vector3
        /** Gradually changes a vector towards a desired goal over time.
         * @param current The current position.
         * @param target The position we are trying to reach.
         * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
         * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
         * @param maxSpeed Optionally allows you to clamp the maximum speed.
         * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
         */
        static SmoothDamp(current: Vector3, target: Vector3, currentVelocity: jsb.Ref<Vector3>, smoothTime: number, maxSpeed: number, deltaTime: number): Vector3
        /** Gradually changes a vector towards a desired goal over time.
         * @param current The current position.
         * @param target The position we are trying to reach.
         * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
         * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
         * @param maxSpeed Optionally allows you to clamp the maximum speed.
         * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
         */
        static SmoothDamp(current: Vector3, target: Vector3, currentVelocity: jsb.Ref<Vector3>, smoothTime: number, maxSpeed: number): Vector3
        /** Gradually changes a vector towards a desired goal over time.
         * @param current The current position.
         * @param target The position we are trying to reach.
         * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
         * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
         * @param maxSpeed Optionally allows you to clamp the maximum speed.
         * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
         */
        static SmoothDamp(current: Vector3, target: Vector3, currentVelocity: jsb.Ref<Vector3>, smoothTime: number): Vector3
        /** Multiplies two vectors component-wise.
         */
        static Scale(a: Vector3, b: Vector3): Vector3
        /** Cross Product of two vectors.
         */
        static Cross(lhs: Vector3, rhs: Vector3): Vector3
        /** Reflects a vector off the plane defined by a normal.
         */
        static Reflect(inDirection: Vector3, inNormal: Vector3): Vector3
        /** Makes this vector have a magnitude of 1.
         */
        static Normalize(value: Vector3): Vector3
        /** Dot Product of two vectors.
         */
        static Dot(lhs: Vector3, rhs: Vector3): number
        /** Projects a vector onto another vector.
         */
        static Project(vector: Vector3, onNormal: Vector3): Vector3
        /** Projects a vector onto a plane defined by a normal orthogonal to the plane.
         * @param planeNormal The direction from the vector towards the plane.
         * @param vector The location of the vector above the plane.
         * @returns The location of the vector on the plane. 
         */
        static ProjectOnPlane(vector: Vector3, planeNormal: Vector3): Vector3
        /** Returns the angle in degrees between from and to.
         * @param from The vector from which the angular difference is measured.
         * @param to The vector to which the angular difference is measured.
         * @returns The angle in degrees between the two vectors. 
         */
        static Angle(from: Vector3, to: Vector3): number
        /** Returns the signed angle in degrees between from and to.
         * @param from The vector from which the angular difference is measured.
         * @param to The vector to which the angular difference is measured.
         * @param axis A vector around which the other vectors are rotated.
         */
        static SignedAngle(from: Vector3, to: Vector3, axis: Vector3): number
        /** Returns the distance between a and b.
         */
        static Distance(a: Vector3, b: Vector3): number
        /** Returns a copy of vector with its magnitude clamped to maxLength.
         */
        static ClampMagnitude(vector: Vector3, maxLength: number): Vector3
        static Magnitude(vector: Vector3): number
        static SqrMagnitude(vector: Vector3): number
        /** Returns a vector that is made from the smallest components of two vectors.
         */
        static Min(lhs: Vector3, rhs: Vector3): Vector3
        /** Returns a vector that is made from the largest components of two vectors.
         */
        static Max(lhs: Vector3, rhs: Vector3): Vector3
        static op_Inequality(lhs: Vector3, rhs: Vector3): boolean
        // js_op_overloading: static +(a: Vector3, b: Vector3): Vector3
        // js_op_overloading: static -(a: Vector3, b: Vector3): Vector3
        // js_op_overloading: static neg(a: Vector3): Vector3
        // js_op_overloading: static *(a: Vector3, d: number): Vector3
        // js_op_overloading: static *(d: number, a: Vector3): Vector3
        // js_op_overloading: static /(a: Vector3, d: number): Vector3
        // js_op_overloading: static ==(lhs: Vector3, rhs: Vector3): boolean
        /** Returns this vector with a magnitude of 1 (Read Only).
         */
        readonly normalized: Vector3
        /** Returns the length of this vector (Read Only).
         */
        readonly magnitude: number
        /** Returns the squared length of this vector (Read Only).
         */
        readonly sqrMagnitude: number
        /** Shorthand for writing Vector3(0, 0, 0).
         */
        static readonly zero: Vector3
        /** Shorthand for writing Vector3(1, 1, 1).
         */
        static readonly one: Vector3
        /** Shorthand for writing Vector3(0, 0, 1).
         */
        static readonly forward: Vector3
        /** Shorthand for writing Vector3(0, 0, -1).
         */
        static readonly back: Vector3
        /** Shorthand for writing Vector3(0, 1, 0).
         */
        static readonly up: Vector3
        /** Shorthand for writing Vector3(0, -1, 0).
         */
        static readonly down: Vector3
        /** Shorthand for writing Vector3(-1, 0, 0).
         */
        static readonly left: Vector3
        /** Shorthand for writing Vector3(1, 0, 0).
         */
        static readonly right: Vector3
        /** Shorthand for writing Vector3(float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity).
         */
        static readonly positiveInfinity: Vector3
        /** Shorthand for writing Vector3(float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity).
         */
        static readonly negativeInfinity: Vector3
        static readonly kEpsilon: number
        static readonly kEpsilonNormalSqrt: number
        /** X component of the vector.
         */
        x: number
        /** Y component of the vector.
         */
        y: number
        /** Z component of the vector.
         */
        z: number
    }
}
declare module "UnityEngine" {
    import { ValueType, Object as Object1 } from "System";
    /** Representation of 3D vectors and points using integers.
     */
    class Vector3Int extends ValueType {
        constructor(x: number, y: number, z: number)
        $GetValue(index: number): number
        $SetValue(index: number, value: number): void
        /** Set x, y and z components of an existing Vector3Int.
         */
        Set(x: number, y: number, z: number): void
        /** Multiplies every component of this vector by the same component of scale.
         */
        Scale(scale: Vector3Int): void
        /** Clamps the Vector3Int to the bounds given by min and max.
         */
        Clamp(min: Vector3Int, max: Vector3Int): void
        /** Returns true if the objects are equal.
         */
        Equals(other: Object1): boolean
        Equals(other: Vector3Int): boolean
        GetHashCode(): number
        /** Returns a nicely formatted string for this vector.
         */
        toString(format: string): string
        toString(): string
        /** Returns the distance between a and b.
         */
        static Distance(a: Vector3Int, b: Vector3Int): number
        /** Returns a vector that is made from the smallest components of two vectors.
         */
        static Min(lhs: Vector3Int, rhs: Vector3Int): Vector3Int
        /** Returns a vector that is made from the largest components of two vectors.
         */
        static Max(lhs: Vector3Int, rhs: Vector3Int): Vector3Int
        /** Multiplies two vectors component-wise.
         */
        static Scale(a: Vector3Int, b: Vector3Int): Vector3Int
        static op_Implicit(v: Vector3Int): Vector3
        static op_Explicit(v: Vector3Int): Vector2Int
        /** Converts a  Vector3 to a Vector3Int by doing a Floor to each value.
         */
        static FloorToInt(v: Vector3): Vector3Int
        /** Converts a  Vector3 to a Vector3Int by doing a Ceiling to each value.
         */
        static CeilToInt(v: Vector3): Vector3Int
        /** Converts a  Vector3 to a Vector3Int by doing a Round to each value.
         */
        static RoundToInt(v: Vector3): Vector3Int
        static op_Inequality(lhs: Vector3Int, rhs: Vector3Int): boolean
        // js_op_overloading: static +(a: Vector3Int, b: Vector3Int): Vector3Int
        // js_op_overloading: static -(a: Vector3Int, b: Vector3Int): Vector3Int
        // js_op_overloading: static *(a: Vector3Int, b: Vector3Int): Vector3Int
        // js_op_overloading: static neg(a: Vector3Int): Vector3Int
        // js_op_overloading: static *(a: Vector3Int, b: number): Vector3Int
        // js_op_overloading: static *(a: number, b: Vector3Int): Vector3Int
        // js_op_overloading: static /(a: Vector3Int, b: number): Vector3Int
        // js_op_overloading: static ==(lhs: Vector3Int, rhs: Vector3Int): boolean
        /** X component of the vector.
         */
        x: number
        /** Y component of the vector.
         */
        y: number
        /** Z component of the vector.
         */
        z: number
        /** Returns the length of this vector (Read Only).
         */
        readonly magnitude: number
        /** Returns the squared length of this vector (Read Only).
         */
        readonly sqrMagnitude: number
        /** Shorthand for writing Vector3Int (0, 0, 0).
         */
        static readonly zero: Vector3Int
        /** Shorthand for writing Vector3Int (1, 1, 1).
         */
        static readonly one: Vector3Int
        /** Shorthand for writing Vector3Int (0, 1, 0).
         */
        static readonly up: Vector3Int
        /** Shorthand for writing Vector3Int (0, -1, 0).
         */
        static readonly down: Vector3Int
        /** Shorthand for writing Vector3Int (-1, 0, 0).
         */
        static readonly left: Vector3Int
        /** Shorthand for writing Vector3Int (1, 0, 0).
         */
        static readonly right: Vector3Int
    }
}
declare module "UnityEngine" {
    import { ValueType, Object as Object1 } from "System";
    /** Representation of four-dimensional vectors.
     */
    class Vector4 extends ValueType {
        constructor(x: number, y: number, z: number, w: number)
        constructor(x: number, y: number, z: number)
        constructor(x: number, y: number)
        $GetValue(index: number): number
        $SetValue(index: number, value: number): void
        /** Set x, y, z and w components of an existing Vector4.
         */
        Set(newX: number, newY: number, newZ: number, newW: number): void
        /** Multiplies every component of this vector by the same component of scale.
         */
        Scale(scale: Vector4): void
        GetHashCode(): number
        /** Returns true if the given vector is exactly equal to this vector.
         */
        Equals(other: Object1): boolean
        Equals(other: Vector4): boolean
        Normalize(): void
        /** Returns a nicely formatted string for this vector.
         */
        toString(format: string): string
        toString(): string
        SqrMagnitude(): number
        /** Linearly interpolates between two vectors.
         */
        static Lerp(a: Vector4, b: Vector4, t: number): Vector4
        /** Linearly interpolates between two vectors.
         */
        static LerpUnclamped(a: Vector4, b: Vector4, t: number): Vector4
        /** Moves a point current towards target.
         */
        static MoveTowards(current: Vector4, target: Vector4, maxDistanceDelta: number): Vector4
        /** Multiplies two vectors component-wise.
         */
        static Scale(a: Vector4, b: Vector4): Vector4
        static Normalize(a: Vector4): Vector4
        /** Dot Product of two vectors.
         */
        static Dot(a: Vector4, b: Vector4): number
        /** Projects a vector onto another vector.
         */
        static Project(a: Vector4, b: Vector4): Vector4
        /** Returns the distance between a and b.
         */
        static Distance(a: Vector4, b: Vector4): number
        static Magnitude(a: Vector4): number
        /** Returns a vector that is made from the smallest components of two vectors.
         */
        static Min(lhs: Vector4, rhs: Vector4): Vector4
        /** Returns a vector that is made from the largest components of two vectors.
         */
        static Max(lhs: Vector4, rhs: Vector4): Vector4
        static op_Inequality(lhs: Vector4, rhs: Vector4): boolean
        static op_Implicit(v: Vector3): Vector4
        static op_Implicit(v: Vector4): Vector3
        static op_Implicit(v: Vector2): Vector4
        static SqrMagnitude(a: Vector4): number
        // js_op_overloading: static +(a: Vector4, b: Vector4): Vector4
        // js_op_overloading: static -(a: Vector4, b: Vector4): Vector4
        // js_op_overloading: static neg(a: Vector4): Vector4
        // js_op_overloading: static *(a: Vector4, d: number): Vector4
        // js_op_overloading: static *(d: number, a: Vector4): Vector4
        // js_op_overloading: static /(a: Vector4, d: number): Vector4
        // js_op_overloading: static ==(lhs: Vector4, rhs: Vector4): boolean
        /** Returns this vector with a magnitude of 1 (Read Only).
         */
        readonly normalized: Vector4
        /** Returns the length of this vector (Read Only).
         */
        readonly magnitude: number
        /** Returns the squared length of this vector (Read Only).
         */
        readonly sqrMagnitude: number
        /** Shorthand for writing Vector4(0,0,0,0).
         */
        static readonly zero: Vector4
        /** Shorthand for writing Vector4(1,1,1,1).
         */
        static readonly one: Vector4
        /** Shorthand for writing Vector4(float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity).
         */
        static readonly positiveInfinity: Vector4
        /** Shorthand for writing Vector4(float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity).
         */
        static readonly negativeInfinity: Vector4
        static readonly kEpsilon: number
        /** X component of the vector.
         */
        x: number
        /** Y component of the vector.
         */
        y: number
        /** Z component of the vector.
         */
        z: number
        /** W component of the vector.
         */
        w: number
    }
}
declare module "UnityEngine" {
    import { ValueType, Object as Object1 } from "System";
    /** A 2D Rectangle defined by X and Y position, width and height.
     */
    class Rect extends ValueType {
        constructor(x: number, y: number, width: number, height: number)
        constructor(position: Vector2, size: Vector2)
        constructor(source: Rect)
        /** Set components of an existing Rect.
         */
        Set(x: number, y: number, width: number, height: number): void
        /** Returns true if the x and y components of point is a point inside this rectangle. If allowInverse is present and true, the width and height of the Rect are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.
         * @param point Point to test.
         * @param allowInverse Does the test allow the Rect's width and height to be negative?
         * @returns True if the point lies within the specified rectangle. 
         */
        Contains(point: Vector3, allowInverse: boolean): boolean
        /** Returns true if the x and y components of point is a point inside this rectangle. If allowInverse is present and true, the width and height of the Rect are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.
         * @param point Point to test.
         * @param allowInverse Does the test allow the Rect's width and height to be negative?
         * @returns True if the point lies within the specified rectangle. 
         */
        Contains(point: Vector2): boolean
        /** Returns true if the x and y components of point is a point inside this rectangle. If allowInverse is present and true, the width and height of the Rect are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.
         * @param point Point to test.
         * @param allowInverse Does the test allow the Rect's width and height to be negative?
         * @returns True if the point lies within the specified rectangle. 
         */
        Contains(point: Vector3): boolean
        /** Returns true if the other rectangle overlaps this one. If allowInverse is present and true, the widths and heights of the Rects are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.
         * @param other Other rectangle to test overlapping with.
         * @param allowInverse Does the test allow the widths and heights of the Rects to be negative?
         */
        Overlaps(other: Rect, allowInverse: boolean): boolean
        /** Returns true if the other rectangle overlaps this one. If allowInverse is present and true, the widths and heights of the Rects are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.
         * @param other Other rectangle to test overlapping with.
         * @param allowInverse Does the test allow the widths and heights of the Rects to be negative?
         */
        Overlaps(other: Rect): boolean
        GetHashCode(): number
        Equals(other: Object1): boolean
        Equals(other: Rect): boolean
        /** Returns a nicely formatted string for this Rect.
         */
        toString(format: string): string
        toString(): string
        /** Creates a rectangle from min/max coordinate values.
         * @param xmin The minimum X coordinate.
         * @param ymin The minimum Y coordinate.
         * @param xmax The maximum X coordinate.
         * @param ymax The maximum Y coordinate.
         * @returns A rectangle matching the specified coordinates. 
         */
        static MinMaxRect(xmin: number, ymin: number, xmax: number, ymax: number): Rect
        /** Returns a point inside a rectangle, given normalized coordinates.
         * @param rectangle Rectangle to get a point inside.
         * @param normalizedRectCoordinates Normalized coordinates to get a point for.
         */
        static NormalizedToPoint(rectangle: Rect, normalizedRectCoordinates: Vector2): Vector2
        /** Returns the normalized coordinates cooresponding the the point.
         * @param rectangle Rectangle to get normalized coordinates inside.
         * @param point A point inside the rectangle to get normalized coordinates for.
         */
        static PointToNormalized(rectangle: Rect, point: Vector2): Vector2
        static op_Inequality(lhs: Rect, rhs: Rect): boolean
        // js_op_overloading: static ==(lhs: Rect, rhs: Rect): boolean
        /** Shorthand for writing new Rect(0,0,0,0).
         */
        static readonly zero: Rect
        /** The X coordinate of the rectangle.
         */
        x: number
        /** The Y coordinate of the rectangle.
         */
        y: number
        /** The X and Y position of the rectangle.
         */
        position: Vector2
        /** The position of the center of the rectangle.
         */
        center: Vector2
        /** The position of the minimum corner of the rectangle.
         */
        min: Vector2
        /** The position of the maximum corner of the rectangle.
         */
        max: Vector2
        /** The width of the rectangle, measured from the X position.
         */
        width: number
        /** The height of the rectangle, measured from the Y position.
         */
        height: number
        /** The width and height of the rectangle.
         */
        size: Vector2
        /** The minimum X coordinate of the rectangle.
         */
        xMin: number
        /** The minimum Y coordinate of the rectangle.
         */
        yMin: number
        /** The maximum X coordinate of the rectangle.
         */
        xMax: number
        /** The maximum Y coordinate of the rectangle.
         */
        yMax: number
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { ValueType, Array, Object as Object1 } from "System";
    /** Quaternions are used to represent rotations.
     */
    class Quaternion extends ValueType {
        constructor(x: number, y: number, z: number, w: number)
        $GetValue(index: number): number
        $SetValue(index: number, value: number): void
        /** Set x, y, z and w components of an existing Quaternion.
         */
        Set(newX: number, newY: number, newZ: number, newW: number): void
        /** Creates a rotation with the specified forward and upwards directions.
         * @param view The direction to look in.
         * @param up The vector that defines in which direction up is.
         */
        SetLookRotation(view: Vector3, up: Vector3): void
        /** Creates a rotation with the specified forward and upwards directions.
         * @param view The direction to look in.
         * @param up The vector that defines in which direction up is.
         */
        SetLookRotation(view: Vector3): void
        /** Converts a rotation to angle-axis representation (angles in degrees).
         */
        ToAngleAxis(angle: jsb.Out<number>, axis: jsb.Out<Vector3>): void
        /** Creates a rotation which rotates from fromDirection to toDirection.
         */
        SetFromToRotation(fromDirection: Vector3, toDirection: Vector3): void
        Normalize(): void
        GetHashCode(): number
        Equals(other: Object1): boolean
        Equals(other: Quaternion): boolean
        /** Returns a nicely formatted string of the Quaternion.
         */
        toString(format: string): string
        toString(): string
        /** Creates a rotation which rotates from fromDirection to toDirection.
         */
        static FromToRotation(fromDirection: Vector3, toDirection: Vector3): Quaternion
        /** Returns the Inverse of rotation.
         */
        static Inverse(rotation: Quaternion): Quaternion
        /** Spherically interpolates between quaternions a and b by ratio t. The parameter t is clamped to the range [0, 1].
         * @param a Start value, returned when t = 0.
         * @param b End value, returned when t = 1.
         * @param t Interpolation ratio.
         * @returns A quaternion spherically interpolated between quaternions a and b. 
         */
        static Slerp(a: Quaternion, b: Quaternion, t: number): Quaternion
        /** Spherically interpolates between a and b by t. The parameter t is not clamped.
         */
        static SlerpUnclamped(a: Quaternion, b: Quaternion, t: number): Quaternion
        /** Interpolates between a and b by t and normalizes the result afterwards. The parameter t is clamped to the range [0, 1].
         */
        static Lerp(a: Quaternion, b: Quaternion, t: number): Quaternion
        /** Interpolates between a and b by t and normalizes the result afterwards. The parameter t is not clamped.
         */
        static LerpUnclamped(a: Quaternion, b: Quaternion, t: number): Quaternion
        /** Creates a rotation which rotates angle degrees around axis.
         */
        static AngleAxis(angle: number, axis: Vector3): Quaternion
        /** Creates a rotation with the specified forward and upwards directions.
         * @param forward The direction to look in.
         * @param upwards The vector that defines in which direction up is.
         */
        static LookRotation(forward: Vector3, upwards: Vector3): Quaternion
        /** Creates a rotation with the specified forward and upwards directions.
         * @param forward The direction to look in.
         * @param upwards The vector that defines in which direction up is.
         */
        static LookRotation(forward: Vector3): Quaternion
        static op_Inequality(lhs: Quaternion, rhs: Quaternion): boolean
        /** The dot product between two rotations.
         */
        static Dot(a: Quaternion, b: Quaternion): number
        /** Returns the angle in degrees between two rotations a and b.
         */
        static Angle(a: Quaternion, b: Quaternion): number
        /** Returns a rotation that rotates z degrees around the z axis, x degrees around the x axis, and y degrees around the y axis; applied in that order.
         */
        static Euler(x: number, y: number, z: number): Quaternion
        /** Returns a rotation that rotates z degrees around the z axis, x degrees around the x axis, and y degrees around the y axis.
         */
        static Euler(euler: Vector3): Quaternion
        /** Rotates a rotation from towards to.
         */
        static RotateTowards(from: Quaternion, to: Quaternion, maxDegreesDelta: number): Quaternion
        /** Converts this quaternion to one with the same orientation but with a magnitude of 1.
         */
        static Normalize(q: Quaternion): Quaternion
        // js_op_overloading: static *(lhs: Quaternion, rhs: Quaternion): Quaternion
        // js_op_overloading: static *(rotation: Quaternion, point: Vector3): Vector3
        // js_op_overloading: static ==(lhs: Quaternion, rhs: Quaternion): boolean
        /** The identity rotation (Read Only).
         */
        static readonly identity: Quaternion
        /** Returns or sets the euler angle representation of the rotation.
         */
        eulerAngles: Vector3
        /** Returns this quaternion with a magnitude of 1 (Read Only).
         */
        readonly normalized: Quaternion
        /** X component of the Quaternion. Don't modify this directly unless you know quaternions inside out.
         */
        x: number
        /** Y component of the Quaternion. Don't modify this directly unless you know quaternions inside out.
         */
        y: number
        /** Z component of the Quaternion. Don't modify this directly unless you know quaternions inside out.
         */
        z: number
        /** W component of the Quaternion. Do not directly modify quaternions.
         */
        w: number
        static readonly kEpsilon: number
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { ValueType, Array, Object as Object1 } from "System";
    /** A standard 4x4 transformation matrix.
     */
    class Matrix4x4 extends ValueType {
        constructor(column0: Vector4, column1: Vector4, column2: Vector4, column3: Vector4)
        $GetValue(row: number, column: number): number
        $GetValue(index: number): number
        $SetValue(row: number, column: number, value: number): void
        $SetValue(index: number, value: number): void
        ValidTRS(): boolean
        /** Sets this matrix to a translation, rotation and scaling matrix.
         */
        SetTRS(pos: Vector3, q: Quaternion, s: Vector3): void
        GetHashCode(): number
        Equals(other: Object1): boolean
        Equals(other: Matrix4x4): boolean
        /** Get a column of the matrix.
         */
        GetColumn(index: number): Vector4
        /** Returns a row of the matrix.
         */
        GetRow(index: number): Vector4
        /** Sets a column of the matrix.
         */
        SetColumn(index: number, column: Vector4): void
        /** Sets a row of the matrix.
         */
        SetRow(index: number, row: Vector4): void
        /** Transforms a position by this matrix (generic).
         */
        MultiplyPoint(point: Vector3): Vector3
        /** Transforms a position by this matrix (fast).
         */
        MultiplyPoint3x4(point: Vector3): Vector3
        /** Transforms a direction by this matrix.
         */
        MultiplyVector(vector: Vector3): Vector3
        /** Returns a plane that is transformed in space.
         */
        TransformPlane(plane: any): any
        /** Returns a nicely formatted string for this matrix.
         */
        toString(format: string): string
        toString(): string
        static Determinant(m: Matrix4x4): number
        /** Creates a translation, rotation and scaling matrix.
         */
        static TRS(pos: Vector3, q: Quaternion, s: Vector3): Matrix4x4
        /** Computes the inverse of a 3D affine matrix.
         * @param input Input matrix to invert.
         * @param result The result of the inversion. Equal to the input matrix if the function fails.
         * @returns Returns true and a valid result if the function succeeds, false and a copy of the input matrix if the function fails. 
         */
        static Inverse3DAffine(input: Matrix4x4, result: jsb.Ref<Matrix4x4>): boolean
        static Inverse(m: Matrix4x4): Matrix4x4
        static Transpose(m: Matrix4x4): Matrix4x4
        /** Create an orthogonal projection matrix.
         * @param left Left-side x-coordinate.
         * @param right Right-side x-coordinate.
         * @param bottom Bottom y-coordinate.
         * @param top Top y-coordinate.
         * @param zNear Near depth clipping plane value.
         * @param zFar Far depth clipping plane value.
         * @returns The projection matrix. 
         */
        static Ortho(left: number, right: number, bottom: number, top: number, zNear: number, zFar: number): Matrix4x4
        /** Create a perspective projection matrix.
         * @param fov Vertical field-of-view in degrees.
         * @param aspect Aspect ratio (width divided by height).
         * @param zNear Near depth clipping plane value.
         * @param zFar Far depth clipping plane value.
         * @returns The projection matrix. 
         */
        static Perspective(fov: number, aspect: number, zNear: number, zFar: number): Matrix4x4
        /** Create a "look at" matrix.
         * @param from The source point.
         * @param to The target point.
         * @param up The vector describing the up direction (typically Vector3.up).
         * @returns The resulting transformation matrix. 
         */
        static LookAt(from: Vector3, to: Vector3, up: Vector3): Matrix4x4
        /** This function returns a projection matrix with viewing frustum that has a near plane defined by the coordinates that were passed in.
         * @param left The X coordinate of the left side of the near projection plane in view space.
         * @param right The X coordinate of the right side of the near projection plane in view space.
         * @param bottom The Y coordinate of the bottom side of the near projection plane in view space.
         * @param top The Y coordinate of the top side of the near projection plane in view space.
         * @param zNear Z distance to the near plane from the origin in view space.
         * @param zFar Z distance to the far plane from the origin in view space.
         * @param frustumPlanes Frustum planes struct that contains the view space coordinates of that define a viewing frustum.
         * @returns A projection matrix with a viewing frustum defined by the plane coordinates passed in. 
         */
        static Frustum(left: number, right: number, bottom: number, top: number, zNear: number, zFar: number): Matrix4x4
        /** This function returns a projection matrix with viewing frustum that has a near plane defined by the coordinates that were passed in.
         * @param left The X coordinate of the left side of the near projection plane in view space.
         * @param right The X coordinate of the right side of the near projection plane in view space.
         * @param bottom The Y coordinate of the bottom side of the near projection plane in view space.
         * @param top The Y coordinate of the top side of the near projection plane in view space.
         * @param zNear Z distance to the near plane from the origin in view space.
         * @param zFar Z distance to the far plane from the origin in view space.
         * @param frustumPlanes Frustum planes struct that contains the view space coordinates of that define a viewing frustum.
         * @returns A projection matrix with a viewing frustum defined by the plane coordinates passed in. 
         */
        static Frustum(fp: any): Matrix4x4
        static op_Inequality(lhs: Matrix4x4, rhs: Matrix4x4): boolean
        /** Creates a scaling matrix.
         */
        static Scale(vector: Vector3): Matrix4x4
        /** Creates a translation matrix.
         */
        static Translate(vector: Vector3): Matrix4x4
        /** Creates a rotation matrix.
         */
        static Rotate(q: Quaternion): Matrix4x4
        // js_op_overloading: static *(lhs: Matrix4x4, rhs: Matrix4x4): Matrix4x4
        // js_op_overloading: static *(lhs: Matrix4x4, vector: Vector4): Vector4
        // js_op_overloading: static ==(lhs: Matrix4x4, rhs: Matrix4x4): boolean
        /** Attempts to get a rotation quaternion from this matrix.
         */
        readonly rotation: Quaternion
        /** Attempts to get a scale value from the matrix. (Read Only)
         */
        readonly lossyScale: Vector3
        /** Checks whether this is an identity matrix. (Read Only)
         */
        readonly isIdentity: boolean
        /** The determinant of the matrix. (Read Only)
         */
        readonly determinant: number
        /** This property takes a projection matrix and returns the six plane coordinates that define a projection frustum.
         */
        readonly decomposeProjection: any
        /** The inverse of this matrix. (Read Only)
         */
        readonly inverse: Matrix4x4
        /** Returns the transpose of this matrix (Read Only).
         */
        readonly transpose: Matrix4x4
        /** Returns a matrix with all elements set to zero (Read Only).
         */
        static readonly zero: Matrix4x4
        /** Returns the identity matrix (Read Only).
         */
        static readonly identity: Matrix4x4
        m00: number
        m10: number
        m20: number
        m30: number
        m01: number
        m11: number
        m21: number
        m31: number
        m02: number
        m12: number
        m22: number
        m32: number
        m03: number
        m13: number
        m23: number
        m33: number
    }
}
declare module "UnityEngine" {
    import { Enum } from "System";
    /** The various primitives that can be created using the GameObject.CreatePrimitive function.
     */
    enum PrimitiveType {
        /** A sphere primitive.
         */
        Sphere = 0,
        /** A capsule primitive.
         */
        Capsule = 1,
        /** A cylinder primitive.
         */
        Cylinder = 2,
        /** A cube primitive.
         */
        Cube = 3,
        /** A plane primitive.
         */
        Plane = 4,
        /** A quad primitive.
         */
        Quad = 5,
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1, Enum, Array } from "System";
    /** Base class for all objects Unity can reference.
     */
    class Object extends Object1 {
        constructor()
        GetInstanceID(): number
        GetHashCode(): number
        Equals(other: Object1): boolean
        toString(): string
        static op_Implicit(exists: Object): boolean
        /** Clones the object original and returns the clone.
         * @param original An existing object that you want to make a copy of.
         * @param position Position for the new object.
         * @param rotation Orientation of the new object.
         * @param parent Parent that will be assigned to the new object.
         * @param instantiateInWorldSpace When you assign a parent Object, pass true to position the new object directly in world space. Pass false to set the Objects position relative to its new parent..
         * @returns The instantiated clone. 
         */
        static Instantiate(original: Object, position: Vector3, rotation: Quaternion, parent: Transform): Object
        /** Clones the object original and returns the clone.
         * @param original An existing object that you want to make a copy of.
         * @param position Position for the new object.
         * @param rotation Orientation of the new object.
         * @param parent Parent that will be assigned to the new object.
         * @param instantiateInWorldSpace When you assign a parent Object, pass true to position the new object directly in world space. Pass false to set the Objects position relative to its new parent..
         * @returns The instantiated clone. 
         */
        static Instantiate(original: Object, position: Vector3, rotation: Quaternion): Object
        /** Clones the object original and returns the clone.
         * @param original An existing object that you want to make a copy of.
         * @param position Position for the new object.
         * @param rotation Orientation of the new object.
         * @param parent Parent that will be assigned to the new object.
         * @param instantiateInWorldSpace When you assign a parent Object, pass true to position the new object directly in world space. Pass false to set the Objects position relative to its new parent..
         * @returns The instantiated clone. 
         */
        static Instantiate(original: Object, parent: Transform, instantiateInWorldSpace: boolean): Object
        /** Clones the object original and returns the clone.
         * @param original An existing object that you want to make a copy of.
         * @param position Position for the new object.
         * @param rotation Orientation of the new object.
         * @param parent Parent that will be assigned to the new object.
         * @param instantiateInWorldSpace When you assign a parent Object, pass true to position the new object directly in world space. Pass false to set the Objects position relative to its new parent..
         * @returns The instantiated clone. 
         */
        static Instantiate(original: Object, parent: Transform): Object
        /** Clones the object original and returns the clone.
         * @param original An existing object that you want to make a copy of.
         * @param position Position for the new object.
         * @param rotation Orientation of the new object.
         * @param parent Parent that will be assigned to the new object.
         * @param instantiateInWorldSpace When you assign a parent Object, pass true to position the new object directly in world space. Pass false to set the Objects position relative to its new parent..
         * @returns The instantiated clone. 
         */
        static Instantiate(original: Object): Object
        /** Removes a GameObject, component or asset.
         * @param obj The object to destroy.
         * @param t The optional amount of time to delay before destroying the object.
         */
        static Destroy(obj: Object, t: number): void
        /** Removes a GameObject, component or asset.
         * @param obj The object to destroy.
         * @param t The optional amount of time to delay before destroying the object.
         */
        static Destroy(obj: Object): void
        /** Destroys the object obj immediately. You are strongly recommended to use Destroy instead.
         * @param obj Object to be destroyed.
         * @param allowDestroyingAssets Set to true to allow assets to be destroyed.
         */
        static DestroyImmediate(obj: Object, allowDestroyingAssets: boolean): void
        /** Destroys the object obj immediately. You are strongly recommended to use Destroy instead.
         * @param obj Object to be destroyed.
         * @param allowDestroyingAssets Set to true to allow assets to be destroyed.
         */
        static DestroyImmediate(obj: Object): void
        /** The older, non-generic version of this method. In most cases you should use the generic version of this method.
         * @param type The type of object to find.
         * @returns Returns an array of all active loaded objects of Type type. 
         */
        static FindObjectsOfType(type: any): Array<Object>
        /** Do not destroy the target Object when loading a new Scene.
         * @param target An Object not destroyed on Scene change.
         */
        static DontDestroyOnLoad(target: Object): void
        /** The older, non-generic version of this method. In most cases you should use the generic version of this method.
         * @param type The type of object to find.
         * @returns Returns an array of all active loaded objects of Type type. 
         */
        static FindObjectOfType(type: any): Object
        static op_Equality(x: Object, y: Object): boolean
        static op_Inequality(x: Object, y: Object): boolean
        /** The name of the object.
         */
        name: string
        /** Should the object be hidden, saved with the Scene or modifiable by the user?
         */
        hideFlags: any
    }
}
declare module "UnityEngine" {
    import { Object as Object1 } from "System";
    /** The interface to get time information from Unity.
     */
    class Time extends Object1 {
        constructor()
        /** The time at the beginning of this frame (Read Only). This is the time in seconds since the start of the game.
         */
        static readonly time: number
        /** The time this frame has started (Read Only). This is the time in seconds since the last level has been loaded.
         */
        static readonly timeSinceLevelLoad: number
        /** The completion time in seconds since the last frame (Read Only).
         */
        static readonly deltaTime: number
        /** The time the latest MonoBehaviour.FixedUpdate has started (Read Only). This is the time in seconds since the start of the game.
         */
        static readonly fixedTime: number
        /** The timeScale-independant time for this frame (Read Only). This is the time in seconds since the start of the game.
         */
        static readonly unscaledTime: number
        /** The TimeScale-independant time the latest MonoBehaviour.FixedUpdate has started (Read Only). This is the time in seconds since the start of the game.
         */
        static readonly fixedUnscaledTime: number
        /** The timeScale-independent interval in seconds from the last frame to the current one (Read Only).
         */
        static readonly unscaledDeltaTime: number
        /** The timeScale-independent interval in seconds from the last fixed frame to the current one (Read Only).
         */
        static readonly fixedUnscaledDeltaTime: number
        /** The interval in seconds at which physics and other fixed frame rate updates (like MonoBehaviour's MonoBehaviour.FixedUpdate) are performed.
         */
        static fixedDeltaTime: number
        /** The maximum time a frame can take. Physics and other fixed frame rate updates (like MonoBehaviour's MonoBehaviour.FixedUpdate) will be performed only for this duration of time per frame.
         */
        static maximumDeltaTime: number
        /** A smoothed out Time.deltaTime (Read Only).
         */
        static readonly smoothDeltaTime: number
        /** The maximum time a frame can spend on particle updates. If the frame takes longer than this, then updates are split into multiple smaller updates.
         */
        static maximumParticleDeltaTime: number
        /** The scale at which time passes. This can be used for slow motion effects.
         */
        static timeScale: number
        /** The total number of frames that have passed (Read Only).
         */
        static readonly frameCount: number
        static readonly renderedFrameCount: number
        /** The real time in seconds since the game started (Read Only).
         */
        static readonly realtimeSinceStartup: number
        /** Slows game playback time to allow screenshots to be saved between frames.
         */
        static captureDeltaTime: number
        /** The reciprocal of Time.captureDeltaTime.
         */
        static captureFramerate: number
        /** Returns true if called inside a fixed time step callback (like MonoBehaviour's MonoBehaviour.FixedUpdate), otherwise returns false.
         */
        static readonly inFixedTimeStep: boolean
    }
}
declare module "UnityEngine" {
    import { Object as Object1, ValueType } from "System";
    /** Class for generating random data.
     */
    class Random extends Object1 {
        constructor()
        /** Initializes the random number generator state with a seed.
         * @param seed Seed used to initialize the random number generator.
         */
        static InitState(seed: number): void
        /** Return a random float number between min [inclusive] and max [inclusive] (Read Only).
         */
        static Range(min: number, max: number): number
        /** Return a random integer number between min [inclusive] and max [exclusive] (Read Only).
         */
        static Range(min: number, max: number): number
        /** Generates a random color from HSV and alpha ranges.
         * @param hueMin Minimum hue [0..1].
         * @param hueMax Maximum hue [0..1].
         * @param saturationMin Minimum saturation [0..1].
         * @param saturationMax Maximum saturation[0..1].
         * @param valueMin Minimum value [0..1].
         * @param valueMax Maximum value [0..1].
         * @param alphaMin Minimum alpha [0..1].
         * @param alphaMax Maximum alpha [0..1].
         * @returns A random color with HSV and alpha values in the input ranges. 
         */
        static ColorHSV(hueMin: number, hueMax: number, saturationMin: number, saturationMax: number, valueMin: number, valueMax: number, alphaMin: number, alphaMax: number): Color
        /** Generates a random color from HSV and alpha ranges.
         * @param hueMin Minimum hue [0..1].
         * @param hueMax Maximum hue [0..1].
         * @param saturationMin Minimum saturation [0..1].
         * @param saturationMax Maximum saturation[0..1].
         * @param valueMin Minimum value [0..1].
         * @param valueMax Maximum value [0..1].
         * @param alphaMin Minimum alpha [0..1].
         * @param alphaMax Maximum alpha [0..1].
         * @returns A random color with HSV and alpha values in the input ranges. 
         */
        static ColorHSV(hueMin: number, hueMax: number, saturationMin: number, saturationMax: number, valueMin: number, valueMax: number): Color
        /** Generates a random color from HSV and alpha ranges.
         * @param hueMin Minimum hue [0..1].
         * @param hueMax Maximum hue [0..1].
         * @param saturationMin Minimum saturation [0..1].
         * @param saturationMax Maximum saturation[0..1].
         * @param valueMin Minimum value [0..1].
         * @param valueMax Maximum value [0..1].
         * @param alphaMin Minimum alpha [0..1].
         * @param alphaMax Maximum alpha [0..1].
         * @returns A random color with HSV and alpha values in the input ranges. 
         */
        static ColorHSV(hueMin: number, hueMax: number, saturationMin: number, saturationMax: number): Color
        /** Generates a random color from HSV and alpha ranges.
         * @param hueMin Minimum hue [0..1].
         * @param hueMax Maximum hue [0..1].
         * @param saturationMin Minimum saturation [0..1].
         * @param saturationMax Maximum saturation[0..1].
         * @param valueMin Minimum value [0..1].
         * @param valueMax Maximum value [0..1].
         * @param alphaMin Minimum alpha [0..1].
         * @param alphaMax Maximum alpha [0..1].
         * @returns A random color with HSV and alpha values in the input ranges. 
         */
        static ColorHSV(hueMin: number, hueMax: number): Color
        static ColorHSV(): Color
        /** Gets/Sets the full internal state of the random number generator.
         */
        static state: any
        /** Returns a random number between 0.0 [inclusive] and 1.0 [inclusive] (Read Only).
         */
        static readonly value: number
        /** Returns a random point inside a sphere with radius 1 (Read Only).
         */
        static readonly insideUnitSphere: Vector3
        /** Returns a random point inside a circle with radius 1 (Read Only).
         */
        static readonly insideUnitCircle: Vector2
        /** Returns a random point on the surface of a sphere with radius 1 (Read Only).
         */
        static readonly onUnitSphere: Vector3
        /** Returns a random rotation (Read Only).
         */
        static readonly rotation: Quaternion
        /** Returns a random rotation with uniform distribution (Read Only).
         */
        static readonly rotationUniform: Quaternion
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { ValueType, Array, Object as Object1, Enum } from "System";
    import { List } from "System.Collections.Generic";
    /** Base class for all entities in Unity Scenes.
     */
    class GameObject extends Object {
        constructor(name: string)
        constructor(name: string, ...components: any[])
        constructor()
        /** Returns the component of Type type if the game object has one attached, null if it doesn't.
         * @param type The type of Component to retrieve.
         */
        GetComponent<T extends Component>(type: { new(): T }): T
        /** Returns the component with name type if the game object has one attached, null if it doesn't.
         * @param type The type of Component to retrieve.
         */
        GetComponent(type: string): Component
        /** Returns the component of Type type in the GameObject or any of its children using depth first search.
         * @param type The type of Component to retrieve.
         * @returns A component of the matching type, if found. 
         */
        GetComponentInChildren<T extends Component>(type: { new(): T }, includeInactive: boolean): T
        /** Returns the component of Type type in the GameObject or any of its children using depth first search.
         * @param type The type of Component to retrieve.
         * @returns A component of the matching type, if found. 
         */
        GetComponentInChildren<T extends Component>(type: { new(): T }): T
        /** Retrieves the component of Type type in the GameObject or any of its parents.
         * @param type Type of component to find.
         * @returns Returns a component if a component matching the type is found. Returns null otherwise. 
         */
        GetComponentInParent<T extends Component>(type: { new(): T }): T
        GetComponents(type: any, results: any): void
        /** Returns all components of Type type in the GameObject.
         * @param type The type of component to retrieve.
         */
        GetComponents<T extends Component>(type: { new(): T }): T[]
        /** Returns all components of Type type in the GameObject or any of its children.
         * @param type The type of Component to retrieve.
         * @param includeInactive Should Components on inactive GameObjects be included in the found set?
         */
        GetComponentsInChildren<T extends Component>(type: { new(): T }, includeInactive: boolean): T[]
        /** Returns all components of Type type in the GameObject or any of its children.
         * @param type The type of Component to retrieve.
         * @param includeInactive Should Components on inactive GameObjects be included in the found set?
         */
        GetComponentsInChildren<T extends Component>(type: { new(): T }): T[]
        /** Returns all components of Type type in the GameObject or any of its parents.
         * @param type The type of Component to retrieve.
         * @param includeInactive Should inactive Components be included in the found set?
         */
        GetComponentsInParent<T extends Component>(type: { new(): T }, includeInactive: boolean): T[]
        GetComponentsInParent<T extends Component>(type: { new(): T }): T[]
        /** Gets the component of the specified type, if it exists.
         * @param type The type of component to retrieve.
         * @param component The output argument that will contain the component or null.
         * @returns Returns true if the component is found, false otherwise. 
         */
        TryGetComponent(type: any, component: jsb.Out<Component>): boolean
        /** Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour.
         * @param methodName The name of the method to call.
         * @param value An optional parameter value to pass to the called method.
         * @param options Should an error be raised if the method doesn't exist on the target object?
         */
        SendMessageUpwards(methodName: string, value: Object1, options: any): void
        SendMessageUpwards(methodName: string, options: any): void
        /** Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour.
         * @param methodName The name of the method to call.
         * @param value An optional parameter value to pass to the called method.
         * @param options Should an error be raised if the method doesn't exist on the target object?
         */
        SendMessageUpwards(methodName: string, value: Object1): void
        /** Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour.
         * @param methodName The name of the method to call.
         * @param value An optional parameter value to pass to the called method.
         * @param options Should an error be raised if the method doesn't exist on the target object?
         */
        SendMessageUpwards(methodName: string): void
        /** Calls the method named methodName on every MonoBehaviour in this game object.
         * @param methodName The name of the method to call.
         * @param value An optional parameter value to pass to the called method.
         * @param options Should an error be raised if the method doesn't exist on the target object?
         */
        SendMessage(methodName: string, value: Object1, options: any): void
        SendMessage(methodName: string, options: any): void
        /** Calls the method named methodName on every MonoBehaviour in this game object.
         * @param methodName The name of the method to call.
         * @param value An optional parameter value to pass to the called method.
         * @param options Should an error be raised if the method doesn't exist on the target object?
         */
        SendMessage(methodName: string, value: Object1): void
        /** Calls the method named methodName on every MonoBehaviour in this game object.
         * @param methodName The name of the method to call.
         * @param value An optional parameter value to pass to the called method.
         * @param options Should an error be raised if the method doesn't exist on the target object?
         */
        SendMessage(methodName: string): void
        /** Calls the method named methodName on every MonoBehaviour in this game object or any of its children.
         */
        BroadcastMessage(methodName: string, parameter: Object1, options: any): void
        BroadcastMessage(methodName: string, options: any): void
        /** Calls the method named methodName on every MonoBehaviour in this game object or any of its children.
         */
        BroadcastMessage(methodName: string, parameter: Object1): void
        /** Calls the method named methodName on every MonoBehaviour in this game object or any of its children.
         */
        BroadcastMessage(methodName: string): void
        /** Adds a component class of type componentType to the game object. C# Users can use a generic version.
         */
        AddComponent<T extends Component>(type: { new(): T }): T
        /** ActivatesDeactivates the GameObject, depending on the given true or false/ value.
         * @param value Activate or deactivate the object, where true activates the GameObject and false deactivates the GameObject.
         */
        SetActive(value: boolean): void
        /** Is this game object tagged with tag ?
         * @param tag The tag to compare.
         */
        CompareTag(tag: string): boolean
        /** Creates a game object with a primitive mesh renderer and appropriate collider.
         * @param type The type of primitive object to create.
         */
        static CreatePrimitive(type: PrimitiveType): GameObject
        /** Returns one active GameObject tagged tag. Returns null if no GameObject was found.
         * @param tag The tag to search for.
         */
        static FindWithTag(tag: string): GameObject
        static FindGameObjectWithTag(tag: string): GameObject
        /** Returns an array of active GameObjects tagged tag. Returns empty array if no GameObject was found.
         * @param tag The name of the tag to search GameObjects for.
         */
        static FindGameObjectsWithTag(tag: string): Array<GameObject>
        /** Finds a GameObject by name and returns it.
         */
        static Find(name: string): GameObject
        /** The Transform attached to this GameObject.
         */
        readonly transform: Transform
        /** The layer the game object is in.
         */
        layer: number
        /** The local active state of this GameObject. (Read Only)
         */
        readonly activeSelf: boolean
        /** Defines whether the GameObject is active in the Scene.
         */
        readonly activeInHierarchy: boolean
        /** Gets and sets the GameObject's StaticEditorFlags.
         */
        isStatic: boolean
        /** The tag of this game object.
         */
        tag: string
        /** Scene that the GameObject is part of.
         */
        readonly scene: any
        /** Scene culling mask Unity uses to determine which scene to render the GameObject in.
         */
        readonly sceneCullingMask: number
        readonly gameObject: GameObject
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Enum, Array, ValueType, Object as Object1 } from "System";
    /** A Camera is a device through which the player views the world.
     */
    class Camera extends Behaviour {
        constructor()
        Reset(): void
        ResetTransparencySortSettings(): void
        ResetAspect(): void
        ResetCullingMatrix(): void
        /** Make the camera render with shader replacement.
         */
        SetReplacementShader(shader: any, replacementTag: string): void
        ResetReplacementShader(): void
        GetGateFittedFieldOfView(): number
        GetGateFittedLensShift(): Vector2
        /** Sets the Camera to render to the chosen buffers of one or more RenderTextures.
         * @param colorBuffer The RenderBuffer(s) to which color information will be rendered.
         * @param depthBuffer The RenderBuffer to which depth information will be rendered.
         */
        SetTargetBuffers(colorBuffer: any, depthBuffer: any): void
        /** Sets the Camera to render to the chosen buffers of one or more RenderTextures.
         * @param colorBuffer The RenderBuffer(s) to which color information will be rendered.
         * @param depthBuffer The RenderBuffer to which depth information will be rendered.
         */
        SetTargetBuffers(colorBuffer: Array<any>, depthBuffer: any): void
        ResetWorldToCameraMatrix(): void
        ResetProjectionMatrix(): void
        /** Calculates and returns oblique near-plane projection matrix.
         * @param clipPlane Vector4 that describes a clip plane.
         * @returns Oblique near-plane projection matrix. 
         */
        CalculateObliqueMatrix(clipPlane: Vector4): Matrix4x4
        WorldToScreenPoint(position: Vector3, eye: any): Vector3
        /** Transforms position from world space into screen space.
         * @param eye Optional argument that can be used to specify which eye transform to use. Default is Mono.
         */
        WorldToScreenPoint(position: Vector3): Vector3
        WorldToViewportPoint(position: Vector3, eye: any): Vector3
        /** Transforms position from world space into viewport space.
         * @param eye Optional argument that can be used to specify which eye transform to use. Default is Mono.
         */
        WorldToViewportPoint(position: Vector3): Vector3
        ViewportToWorldPoint(position: Vector3, eye: any): Vector3
        /** Transforms position from viewport space into world space.
         * @param position The 3d vector in Viewport space.
         * @returns The 3d vector in World space. 
         */
        ViewportToWorldPoint(position: Vector3): Vector3
        ScreenToWorldPoint(position: Vector3, eye: any): Vector3
        /** Transforms a point from screen space into world space, where world space is defined as the coordinate system at the very top of your game's hierarchy.
         * @param position A screen space position (often mouse x, y), plus a z position for depth (for example, a camera clipping plane).
         * @param eye By default, Camera.MonoOrStereoscopicEye.Mono. Can be set to Camera.MonoOrStereoscopicEye.Left or Camera.MonoOrStereoscopicEye.Right for use in stereoscopic rendering (e.g., for VR).
         * @returns The worldspace point created by converting the screen space point at the provided distance z from the camera plane. 
         */
        ScreenToWorldPoint(position: Vector3): Vector3
        /** Transforms position from screen space into viewport space.
         */
        ScreenToViewportPoint(position: Vector3): Vector3
        /** Transforms position from viewport space into screen space.
         */
        ViewportToScreenPoint(position: Vector3): Vector3
        ViewportPointToRay(pos: Vector3, eye: any): Ray
        /** Returns a ray going from camera through a viewport point.
         * @param eye Optional argument that can be used to specify which eye transform to use. Default is Mono.
         */
        ViewportPointToRay(pos: Vector3): Ray
        ScreenPointToRay(pos: Vector3, eye: any): Ray
        /** Returns a ray going from camera through a screen point.
         * @param eye Optional argument that can be used to specify which eye transform to use. Default is Mono.
         */
        ScreenPointToRay(pos: Vector3): Ray
        CalculateFrustumCorners(viewport: Rect, z: number, eye: any, outCorners: Array<Vector3>): void
        GetStereoNonJitteredProjectionMatrix(eye: any): Matrix4x4
        GetStereoViewMatrix(eye: any): Matrix4x4
        CopyStereoDeviceProjectionMatrixToNonJittered(eye: any): void
        GetStereoProjectionMatrix(eye: any): Matrix4x4
        SetStereoProjectionMatrix(eye: any, matrix: Matrix4x4): void
        ResetStereoProjectionMatrices(): void
        SetStereoViewMatrix(eye: any, matrix: Matrix4x4): void
        ResetStereoViewMatrices(): void
        RenderToCubemap(cubemap: any, faceMask: number, stereoEye: any): boolean
        /** Render into a static cubemap from this camera.
         * @param cubemap The cube map to render to.
         * @param faceMask A bitmask which determines which of the six faces are rendered to.
         * @returns False if rendering fails, else true. 
         */
        RenderToCubemap(cubemap: any, faceMask: number): boolean
        /** Render into a cubemap from this camera.
         * @param faceMask A bitfield indicating which cubemap faces should be rendered into.
         * @param cubemap The texture to render to.
         * @returns False if rendering fails, else true. 
         */
        RenderToCubemap(cubemap: any, faceMask: number): boolean
        RenderToCubemap(cubemap: any): boolean
        RenderToCubemap(cubemap: any): boolean
        Render(): void
        /** Render the camera with shader replacement.
         */
        RenderWithShader(shader: any, replacementTag: string): void
        RenderDontRestore(): void
        /** Makes this camera's settings match other camera.
         * @param other Copy camera settings to the other camera.
         */
        CopyFrom(other: Camera): void
        /** Remove command buffers from execution at a specified place.
         * @param evt When to execute the command buffer during rendering.
         */
        RemoveCommandBuffers(evt: any): void
        RemoveAllCommandBuffers(): void
        /** Add a command buffer to be executed at a specified place.
         * @param evt When to execute the command buffer during rendering.
         * @param buffer The buffer to execute.
         */
        AddCommandBuffer(evt: any, buffer: any): void
        /** Adds a command buffer to the GPU's async compute queues and executes that command buffer when graphics processing reaches a given point.
         * @param evt The point during the graphics processing at which this command buffer should commence on the GPU.
         * @param buffer The buffer to execute.
         * @param queueType The desired async compute queue type to execute the buffer on.
         */
        AddCommandBufferAsync(evt: any, buffer: any, queueType: any): void
        /** Remove command buffer from execution at a specified place.
         * @param evt When to execute the command buffer during rendering.
         * @param buffer The buffer to execute.
         */
        RemoveCommandBuffer(evt: any, buffer: any): void
        /** Get command buffers to be executed at a specified place.
         * @param evt When to execute the command buffer during rendering.
         * @returns Array of command buffers. 
         */
        GetCommandBuffers(evt: any): Array<any>
        /** Get culling parameters for a camera.
         * @param cullingParameters Resultant culling parameters.
         * @param stereoAware Generate single-pass stereo aware culling parameters.
         * @returns Flag indicating whether culling parameters are valid. 
         */
        TryGetCullingParameters(stereoAware: boolean, cullingParameters: jsb.Out<any>): boolean
        /** Get culling parameters for a camera.
         * @param cullingParameters Resultant culling parameters.
         * @param stereoAware Generate single-pass stereo aware culling parameters.
         * @returns Flag indicating whether culling parameters are valid. 
         */
        TryGetCullingParameters(cullingParameters: jsb.Out<any>): boolean
        static CalculateProjectionMatrixFromPhysicalProperties(output: jsb.Out<Matrix4x4>, focalLength: number, sensorSize: Vector2, lensShift: Vector2, nearClip: number, farClip: number, gateFitParameters: any): void
        /** Converts focal length to field of view.
         * @param focalLength Focal length in millimeters.
         * @param sensorSize Sensor size in millimeters. Use the sensor height to get the vertical field of view. Use the sensor width to get the horizontal field of view.
         * @returns field of view in degrees. 
         */
        static FocalLengthToFieldOfView(focalLength: number, sensorSize: number): number
        /** Converts field of view to focal length. Use either sensor height and vertical field of view or sensor width and horizontal field of view.
         * @param fieldOfView field of view in degrees.
         * @param sensorSize Sensor size in millimeters.
         * @returns Focal length in millimeters. 
         */
        static FieldOfViewToFocalLength(fieldOfView: number, sensorSize: number): number
        /** Converts the horizontal field of view (FOV) to the vertical FOV, based on the value of the aspect ratio parameter.
         * @param horizontalFOV The horizontal FOV value in degrees.
         * @param aspectRatio The aspect ratio value used for the conversion
         */
        static HorizontalToVerticalFieldOfView(horizontalFieldOfView: number, aspectRatio: number): number
        /** Converts the vertical field of view (FOV) to the horizontal FOV, based on the value of the aspect ratio parameter.
         * @param verticalFieldOfView The vertical FOV value in degrees.
         * @param aspectRatio The aspect ratio value used for the conversion
         */
        static VerticalToHorizontalFieldOfView(verticalFieldOfView: number, aspectRatio: number): number
        /** Fills an array of Camera with the current cameras in the Scene, without allocating a new array.
         * @param cameras An array to be filled up with cameras currently in the Scene.
         */
        static GetAllCameras(cameras: Array<Camera>): number
        static SetupCurrent(cur: Camera): void
        /** The distance of the near clipping plane from the the Camera, in world units.
         */
        nearClipPlane: number
        /** The distance of the far clipping plane from the Camera, in world units.
         */
        farClipPlane: number
        /** The field of view of the camera in degrees.
         */
        fieldOfView: number
        /** The rendering path that should be used, if possible.
         */
        renderingPath: any
        /** The rendering path that is currently being used (Read Only).
         */
        readonly actualRenderingPath: any
        /** High dynamic range rendering.
         */
        allowHDR: boolean
        /** MSAA rendering.
         */
        allowMSAA: boolean
        /** Dynamic Resolution Scaling.
         */
        allowDynamicResolution: boolean
        /** Should camera rendering be forced into a RenderTexture.
         */
        forceIntoRenderTexture: boolean
        /** Camera's half-size when in orthographic mode.
         */
        orthographicSize: number
        /** Is the camera orthographic (true) or perspective (false)?
         */
        orthographic: boolean
        /** Opaque object sorting mode.
         */
        opaqueSortMode: any
        /** Transparent object sorting mode.
         */
        transparencySortMode: any
        /** An axis that describes the direction along which the distances of objects are measured for the purpose of sorting.
         */
        transparencySortAxis: Vector3
        /** Camera's depth in the camera rendering order.
         */
        depth: number
        /** The aspect ratio (width divided by height).
         */
        aspect: number
        /** Get the world-space speed of the camera (Read Only).
         */
        readonly velocity: Vector3
        /** This is used to render parts of the Scene selectively.
         */
        cullingMask: number
        /** Mask to select which layers can trigger events on the camera.
         */
        eventMask: number
        /** How to perform per-layer culling for a Camera.
         */
        layerCullSpherical: boolean
        /** Identifies what kind of camera this is, using the CameraType enum.
         */
        cameraType: any
        /** Sets the culling maks used to determine which objects from which Scenes to draw.
See EditorSceneManager.SetSceneCullingMask.
         */
        overrideSceneCullingMask: number
        /** Per-layer culling distances.
         */
        layerCullDistances: Array<number>
        /** Whether or not the Camera will use occlusion culling during rendering.
         */
        useOcclusionCulling: boolean
        /** Sets a custom matrix for the camera to use for all culling queries.
         */
        cullingMatrix: Matrix4x4
        /** The color with which the screen will be cleared.
         */
        backgroundColor: Color
        /** How the camera clears the background.
         */
        clearFlags: any
        /** How and if camera generates a depth texture.
         */
        depthTextureMode: any
        /** Should the camera clear the stencil buffer after the deferred light pass?
         */
        clearStencilAfterLightingPass: boolean
        /** Enable [UsePhysicalProperties] to use physical camera properties to compute the field of view and the frustum.
         */
        usePhysicalProperties: boolean
        /** The size of the camera sensor, expressed in millimeters.
         */
        sensorSize: Vector2
        /** The lens offset of the camera. The lens shift is relative to the sensor size. For example, a lens shift of 0.5 offsets the sensor by half its horizontal size.
         */
        lensShift: Vector2
        /** The camera focal length, expressed in millimeters. To use this property, enable UsePhysicalProperties.
         */
        focalLength: number
        /** There are two gates for a camera, the sensor gate and the resolution gate. The physical camera sensor gate is defined by the sensorSize property, the resolution gate is defined by the render target area.
         */
        gateFit: any
        /** Where on the screen is the camera rendered in normalized coordinates.
         */
        rect: Rect
        /** Where on the screen is the camera rendered in pixel coordinates.
         */
        pixelRect: Rect
        /** How wide is the camera in pixels (not accounting for dynamic resolution scaling) (Read Only).
         */
        readonly pixelWidth: number
        /** How tall is the camera in pixels (not accounting for dynamic resolution scaling) (Read Only).
         */
        readonly pixelHeight: number
        /** How wide is the camera in pixels (accounting for dynamic resolution scaling) (Read Only).
         */
        readonly scaledPixelWidth: number
        /** How tall is the camera in pixels (accounting for dynamic resolution scaling) (Read Only).
         */
        readonly scaledPixelHeight: number
        /** Destination render texture.
         */
        targetTexture: any
        /** Gets the temporary RenderTexture target for this Camera.
         */
        readonly activeTexture: any
        /** Set the target display for this Camera.
         */
        targetDisplay: number
        /** Matrix that transforms from camera space to world space (Read Only).
         */
        readonly cameraToWorldMatrix: Matrix4x4
        /** Matrix that transforms from world to camera space.
         */
        worldToCameraMatrix: Matrix4x4
        /** Set a custom projection matrix.
         */
        projectionMatrix: Matrix4x4
        /** Get or set the raw projection matrix with no camera offset (no jittering).
         */
        nonJitteredProjectionMatrix: Matrix4x4
        /** Should the jittered matrix be used for transparency rendering?
         */
        useJitteredProjectionMatrixForTransparentRendering: boolean
        /** Get the view projection matrix used on the last frame.
         */
        readonly previousViewProjectionMatrix: Matrix4x4
        /** The first enabled Camera component that is tagged "MainCamera" (Read Only).
         */
        static readonly main: Camera
        /** The camera we are currently rendering with, for low-level render control only (Read Only).
         */
        static readonly current: Camera
        /** If not null, the camera will only render the contents of the specified Scene.
         */
        scene: any
        /** Stereoscopic rendering.
         */
        readonly stereoEnabled: boolean
        /** The distance between the virtual eyes. Use this to query or set the current eye separation. Note that most VR devices provide this value, in which case setting the value will have no effect.
         */
        stereoSeparation: number
        /** Distance to a point where virtual eyes converge.
         */
        stereoConvergence: number
        /** Determines whether the stereo view matrices are suitable to allow for a single pass cull.
         */
        readonly areVRStereoViewMatricesWithinSingleCullTolerance: boolean
        /** Defines which eye of a VR display the Camera renders into.
         */
        stereoTargetEye: any
        /** Returns the eye that is currently rendering.
If called when stereo is not enabled it will return Camera.MonoOrStereoscopicEye.Mono.

If called during a camera rendering callback such as OnRenderImage it will return the currently rendering eye.

If called outside of a rendering callback and stereo is enabled, it will return the default eye which is Camera.MonoOrStereoscopicEye.Left.
         */
        readonly stereoActiveEye: any
        /** The number of cameras in the current Scene.
         */
        static readonly allCamerasCount: number
        /** Returns all enabled cameras in the Scene.
         */
        static readonly allCameras: Array<Camera>
        /** Number of command buffers set up on this camera (Read Only).
         */
        readonly commandBufferCount: number
        static onPreCull(op: "get"): (cam: Camera) => void
        static onPreCull(op: "add" | "remove" | "set", fn?: (cam: Camera) => void): void
        static onPreCull(op: "add" | "remove" | "set" | "get", fn?: (cam: Camera) => void): (cam: Camera) => void | void
        static onPreRender(op: "get"): (cam: Camera) => void
        static onPreRender(op: "add" | "remove" | "set", fn?: (cam: Camera) => void): void
        static onPreRender(op: "add" | "remove" | "set" | "get", fn?: (cam: Camera) => void): (cam: Camera) => void | void
        static onPostRender(op: "get"): (cam: Camera) => void
        static onPostRender(op: "add" | "remove" | "set", fn?: (cam: Camera) => void): void
        static onPostRender(op: "add" | "remove" | "set" | "get", fn?: (cam: Camera) => void): (cam: Camera) => void | void
    }
}
declare module "UnityEngine" {
    /** Behaviours are Components that can be enabled or disabled.
     */
    class Behaviour extends Component {
        constructor()
        /** Enabled Behaviours are Updated, disabled Behaviours are not.
         */
        enabled: boolean
        /** Has the Behaviour had active and enabled called?
         */
        readonly isActiveAndEnabled: boolean
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1, Array, Enum } from "System";
    import { List } from "System.Collections.Generic";
    /** Base class for everything attached to GameObjects.
     */
    class Component extends Object {
        constructor()
        /** Returns the component of Type type if the game object has one attached, null if it doesn't.
         * @param type The type of Component to retrieve.
         */
        GetComponent<T extends Component>(type: { new(): T }): T
        /** Returns the component with name type if the game object has one attached, null if it doesn't.
         */
        GetComponent(type: string): Component
        /** Gets the component of the specified type, if it exists.
         * @param type The type of the component to retrieve.
         * @param component The output argument that will contain the component or null.
         * @returns Returns true if the component is found, false otherwise. 
         */
        TryGetComponent(type: any, component: jsb.Out<Component>): boolean
        GetComponentInChildren<T extends Component>(type: { new(): T }, includeInactive: boolean): T
        /** Returns the component of Type type in the GameObject or any of its children using depth first search.
         * @param t The type of Component to retrieve.
         * @returns A component of the matching type, if found. 
         */
        GetComponentInChildren<T extends Component>(type: { new(): T }): T
        /** Returns all components of Type type in the GameObject or any of its children.
         * @param t The type of Component to retrieve.
         * @param includeInactive Should Components on inactive GameObjects be included in the found set? includeInactive decides which children of the GameObject will be searched.  The GameObject that you call GetComponentsInChildren on is always searched regardless.
         */
        GetComponentsInChildren<T extends Component>(type: { new(): T }, includeInactive: boolean): T[]
        GetComponentsInChildren<T extends Component>(type: { new(): T }): T[]
        /** Returns the component of Type type in the GameObject or any of its parents.
         * @param t The type of Component to retrieve.
         * @returns A component of the matching type, if found. 
         */
        GetComponentInParent<T extends Component>(type: { new(): T }): T
        /** Returns all components of Type type in the GameObject or any of its parents.
         * @param t The type of Component to retrieve.
         * @param includeInactive Should inactive Components be included in the found set?
         */
        GetComponentsInParent<T extends Component>(type: { new(): T }, includeInactive: boolean): T[]
        GetComponentsInParent<T extends Component>(type: { new(): T }): T[]
        GetComponents(type: any, results: any): void
        /** Returns all components of Type type in the GameObject.
         * @param type The type of Component to retrieve.
         */
        GetComponents<T extends Component>(type: { new(): T }): T[]
        /** Is this game object tagged with tag ?
         * @param tag The tag to compare.
         */
        CompareTag(tag: string): boolean
        /** Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour.
         * @param methodName Name of method to call.
         * @param value Optional parameter value for the method.
         * @param options Should an error be raised if the method does not exist on the target object?
         */
        SendMessageUpwards(methodName: string, value: Object1, options: any): void
        /** Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour.
         * @param methodName Name of method to call.
         * @param value Optional parameter value for the method.
         * @param options Should an error be raised if the method does not exist on the target object?
         */
        SendMessageUpwards(methodName: string, value: Object1): void
        /** Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour.
         * @param methodName Name of method to call.
         * @param value Optional parameter value for the method.
         * @param options Should an error be raised if the method does not exist on the target object?
         */
        SendMessageUpwards(methodName: string, options: any): void
        /** Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour.
         * @param methodName Name of method to call.
         * @param value Optional parameter value for the method.
         * @param options Should an error be raised if the method does not exist on the target object?
         */
        SendMessageUpwards(methodName: string): void
        /** Calls the method named methodName on every MonoBehaviour in this game object.
         * @param methodName Name of the method to call.
         * @param value Optional parameter for the method.
         * @param options Should an error be raised if the target object doesn't implement the method for the message?
         */
        SendMessage(methodName: string, value: Object1, options: any): void
        /** Calls the method named methodName on every MonoBehaviour in this game object.
         * @param methodName Name of the method to call.
         * @param value Optional parameter for the method.
         * @param options Should an error be raised if the target object doesn't implement the method for the message?
         */
        SendMessage(methodName: string, value: Object1): void
        /** Calls the method named methodName on every MonoBehaviour in this game object.
         * @param methodName Name of the method to call.
         * @param value Optional parameter for the method.
         * @param options Should an error be raised if the target object doesn't implement the method for the message?
         */
        SendMessage(methodName: string, options: any): void
        /** Calls the method named methodName on every MonoBehaviour in this game object.
         * @param methodName Name of the method to call.
         * @param value Optional parameter for the method.
         * @param options Should an error be raised if the target object doesn't implement the method for the message?
         */
        SendMessage(methodName: string): void
        /** Calls the method named methodName on every MonoBehaviour in this game object or any of its children.
         * @param methodName Name of the method to call.
         * @param parameter Optional parameter to pass to the method (can be any value).
         * @param options Should an error be raised if the method does not exist for a given target object?
         */
        BroadcastMessage(methodName: string, parameter: Object1, options: any): void
        /** Calls the method named methodName on every MonoBehaviour in this game object or any of its children.
         * @param methodName Name of the method to call.
         * @param parameter Optional parameter to pass to the method (can be any value).
         * @param options Should an error be raised if the method does not exist for a given target object?
         */
        BroadcastMessage(methodName: string, parameter: Object1): void
        /** Calls the method named methodName on every MonoBehaviour in this game object or any of its children.
         * @param methodName Name of the method to call.
         * @param parameter Optional parameter to pass to the method (can be any value).
         * @param options Should an error be raised if the method does not exist for a given target object?
         */
        BroadcastMessage(methodName: string, options: any): void
        /** Calls the method named methodName on every MonoBehaviour in this game object or any of its children.
         * @param methodName Name of the method to call.
         * @param parameter Optional parameter to pass to the method (can be any value).
         * @param options Should an error be raised if the method does not exist for a given target object?
         */
        BroadcastMessage(methodName: string): void
        /** The Transform attached to this GameObject.
         */
        readonly transform: Transform
        /** The game object this component is attached to. A component is always attached to a game object.
         */
        readonly gameObject: GameObject
        /** The tag of this game object.
         */
        tag: string
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Enum, Array } from "System";
    import { IEnumerator } from "System.Collections";
    /** Position, rotation and scale of an object.
     */
    class Transform extends Component {
        /** Set the parent of the transform.
         * @param parent The parent Transform to use.
         * @param worldPositionStays If true, the parent-relative position, scale and rotation are modified such that the object keeps the same world space position, rotation and scale as before.
         */
        SetParent(parent: Transform, worldPositionStays: boolean): void
        /** Set the parent of the transform.
         * @param parent The parent Transform to use.
         * @param worldPositionStays If true, the parent-relative position, scale and rotation are modified such that the object keeps the same world space position, rotation and scale as before.
         */
        SetParent(p: Transform): void
        /** Sets the world space position and rotation of the Transform component.
         */
        SetPositionAndRotation(position: Vector3, rotation: Quaternion): void
        /** Moves the transform by x along the x axis, y along the y axis, and z along the z axis.
         */
        Translate(x: number, y: number, z: number, relativeTo: any): void
        /** Moves the transform by x along the x axis, y along the y axis, and z along the z axis.
         */
        Translate(x: number, y: number, z: number, relativeTo: Transform): void
        /** Moves the transform by x along the x axis, y along the y axis, and z along the z axis.
         */
        Translate(x: number, y: number, z: number): void
        /** Moves the transform in the direction and distance of translation.
         */
        Translate(translation: Vector3, relativeTo: any): void
        /** Moves the transform in the direction and distance of translation.
         */
        Translate(translation: Vector3, relativeTo: Transform): void
        /** Moves the transform in the direction and distance of translation.
         */
        Translate(translation: Vector3): void
        /** The implementation of this method applies a rotation of zAngle degrees around the z axis, xAngle degrees around the x axis, and yAngle degrees around the y axis (in that order).
         * @param relativeTo Determines whether to rotate the GameObject either locally to the GameObject or relative to the Scene in world space.
         * @param xAngle Degrees to rotate the GameObject around the X axis.
         * @param yAngle Degrees to rotate the GameObject around the Y axis.
         * @param zAngle Degrees to rotate the GameObject around the Z axis.
         */
        Rotate(xAngle: number, yAngle: number, zAngle: number, relativeTo: any): void
        /** The implementation of this method applies a rotation of zAngle degrees around the z axis, xAngle degrees around the x axis, and yAngle degrees around the y axis (in that order).
         * @param xAngle Degrees to rotate the GameObject around the X axis.
         * @param yAngle Degrees to rotate the GameObject around the Y axis.
         * @param zAngle Degrees to rotate the GameObject around the Z axis.
         */
        Rotate(xAngle: number, yAngle: number, zAngle: number): void
        /** Rotates the object around the given axis by the number of degrees defined by the given angle.
         * @param angle The degrees of rotation to apply.
         * @param axis The axis to apply rotation to.
         * @param relativeTo Determines whether to rotate the GameObject either locally to the GameObject or relative to the Scene in world space.
         */
        Rotate(axis: Vector3, angle: number, relativeTo: any): void
        /** Applies a rotation of eulerAngles.z degrees around the z-axis, eulerAngles.x degrees around the x-axis, and eulerAngles.y degrees around the y-axis (in that order).
         * @param eulers The rotation to apply in euler angles.
         * @param relativeTo Determines whether to rotate the GameObject either locally to  the GameObject or relative to the Scene in world space.
         */
        Rotate(eulers: Vector3, relativeTo: any): void
        /** Rotates the object around the given axis by the number of degrees defined by the given angle.
         * @param axis The axis to apply rotation to.
         * @param angle The degrees of rotation to apply.
         */
        Rotate(axis: Vector3, angle: number): void
        /** Applies a rotation of eulerAngles.z degrees around the z-axis, eulerAngles.x degrees around the x-axis, and eulerAngles.y degrees around the y-axis (in that order).
         * @param eulers The rotation to apply in euler angles.
         */
        Rotate(eulers: Vector3): void
        /** Rotates the transform about axis passing through point in world coordinates by angle degrees.
         */
        RotateAround(point: Vector3, axis: Vector3, angle: number): void
        /** Rotates the transform so the forward vector points at target's current position.
         * @param target Object to point towards.
         * @param worldUp Vector specifying the upward direction.
         */
        LookAt(target: Transform, worldUp: Vector3): void
        /** Rotates the transform so the forward vector points at worldPosition.
         * @param worldPosition Point to look at.
         * @param worldUp Vector specifying the upward direction.
         */
        LookAt(worldPosition: Vector3, worldUp: Vector3): void
        /** Rotates the transform so the forward vector points at target's current position.
         * @param target Object to point towards.
         * @param worldUp Vector specifying the upward direction.
         */
        LookAt(target: Transform): void
        /** Rotates the transform so the forward vector points at worldPosition.
         * @param worldPosition Point to look at.
         * @param worldUp Vector specifying the upward direction.
         */
        LookAt(worldPosition: Vector3): void
        /** Transforms direction x, y, z from local space to world space.
         */
        TransformDirection(x: number, y: number, z: number): Vector3
        /** Transforms direction from local space to world space.
         */
        TransformDirection(direction: Vector3): Vector3
        /** Transforms the direction x, y, z from world space to local space. The opposite of Transform.TransformDirection.
         */
        InverseTransformDirection(x: number, y: number, z: number): Vector3
        /** Transforms a direction from world space to local space. The opposite of Transform.TransformDirection.
         */
        InverseTransformDirection(direction: Vector3): Vector3
        /** Transforms vector x, y, z from local space to world space.
         */
        TransformVector(x: number, y: number, z: number): Vector3
        /** Transforms vector from local space to world space.
         */
        TransformVector(vector: Vector3): Vector3
        /** Transforms the vector x, y, z from world space to local space. The opposite of Transform.TransformVector.
         */
        InverseTransformVector(x: number, y: number, z: number): Vector3
        /** Transforms a vector from world space to local space. The opposite of Transform.TransformVector.
         */
        InverseTransformVector(vector: Vector3): Vector3
        /** Transforms the position x, y, z from local space to world space.
         */
        TransformPoint(x: number, y: number, z: number): Vector3
        /** Transforms position from local space to world space.
         */
        TransformPoint(position: Vector3): Vector3
        /** Transforms the position x, y, z from world space to local space. The opposite of Transform.TransformPoint.
         */
        InverseTransformPoint(x: number, y: number, z: number): Vector3
        /** Transforms position from world space to local space.
         */
        InverseTransformPoint(position: Vector3): Vector3
        DetachChildren(): void
        SetAsFirstSibling(): void
        SetAsLastSibling(): void
        /** Sets the sibling index.
         * @param index Index to set.
         */
        SetSiblingIndex(index: number): void
        GetSiblingIndex(): number
        /** Finds a child by n and returns it.
         * @param n Name of child to be found.
         * @returns The returned child transform or null if no child is found. 
         */
        Find(n: string): Transform
        /** Is this transform a child of parent?
         */
        IsChildOf(parent: Transform): boolean
        GetEnumerator(): IEnumerator
        /** Returns a transform child by index.
         * @param index Index of the child transform to return. Must be smaller than Transform.childCount.
         * @returns Transform child by index. 
         */
        GetChild(index: number): Transform
        ResetAll(): void
        TestWithArgs(pos: Vector3, rot: Quaternion, scale: Vector3): void
        TestWithArgsAndOut(pos: Vector3, rot: Quaternion, scale: Vector3, dist: jsb.Out<number>): boolean
        /*protected*/ constructor()
        /** The world space position of the Transform.
         */
        position: Vector3
        /** Position of the transform relative to the parent transform.
         */
        localPosition: Vector3
        /** The rotation as Euler angles in degrees.
         */
        eulerAngles: Vector3
        /** The rotation as Euler angles in degrees relative to the parent transform's rotation.
         */
        localEulerAngles: Vector3
        /** The red axis of the transform in world space.
         */
        right: Vector3
        /** The green axis of the transform in world space.
         */
        up: Vector3
        /** Returns a normalized vector representing the blue axis of the transform in world space.
         */
        forward: Vector3
        /** A Quaternion that stores the rotation of the Transform in world space.
         */
        rotation: Quaternion
        /** The rotation of the transform relative to the transform rotation of the parent.
         */
        localRotation: Quaternion
        /** The scale of the transform relative to the GameObjects parent.
         */
        localScale: Vector3
        /** The parent of the transform.
         */
        parent: Transform
        /** Matrix that transforms a point from world space into local space (Read Only).
         */
        readonly worldToLocalMatrix: Matrix4x4
        /** Matrix that transforms a point from local space into world space (Read Only).
         */
        readonly localToWorldMatrix: Matrix4x4
        /** Returns the topmost transform in the hierarchy.
         */
        readonly root: Transform
        /** The number of children the parent Transform has.
         */
        readonly childCount: number
        /** The global scale of the object (Read Only).
         */
        readonly lossyScale: Vector3
        /** Has the transform changed since the last time the flag was set to 'false'?
         */
        hasChanged: boolean
        /** The transform capacity of the transform's hierarchy data structure.
         */
        hierarchyCapacity: number
        /** The number of transforms in the transform's hierarchy data structure.
         */
        readonly hierarchyCount: number
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Array, Enum } from "System";
    /** Position, size, anchor and pivot information for a rectangle.
     */
    class RectTransform extends Transform {
        constructor()
        ForceUpdateRectTransforms(): void
        /** Get the corners of the calculated rectangle in the local space of its Transform.
         * @param fourCornersArray The array that corners are filled into.
         */
        GetLocalCorners(fourCornersArray: Array<Vector3>): void
        /** Get the corners of the calculated rectangle in world space.
         * @param fourCornersArray The array that corners are filled into.
         */
        GetWorldCorners(fourCornersArray: Array<Vector3>): void
        SetInsetAndSizeFromParentEdge(edge: any, inset: number, size: number): void
        SetSizeWithCurrentAnchors(axis: any, size: number): void
        /** The calculated rectangle in the local space of the Transform.
         */
        readonly rect: Rect
        /** The normalized position in the parent RectTransform that the lower left corner is anchored to.
         */
        anchorMin: Vector2
        /** The normalized position in the parent RectTransform that the upper right corner is anchored to.
         */
        anchorMax: Vector2
        /** The position of the pivot of this RectTransform relative to the anchor reference point.
         */
        anchoredPosition: Vector2
        /** The size of this RectTransform relative to the distances between the anchors.
         */
        sizeDelta: Vector2
        /** The normalized position in this RectTransform that it rotates around.
         */
        pivot: Vector2
        /** The 3D position of the pivot of this RectTransform relative to the anchor reference point.
         */
        anchoredPosition3D: Vector3
        /** The offset of the lower left corner of the rectangle relative to the lower left anchor.
         */
        offsetMin: Vector2
        /** The offset of the upper right corner of the rectangle relative to the upper right anchor.
         */
        offsetMax: Vector2
        static reapplyDrivenProperties(op: "add" | "remove", fn: (driven: RectTransform) => void): void
    }
}
declare module "UnityEngine" {
    import { Object as Object1 } from "System";
    import { IEnumerator } from "System.Collections";
    /** MonoBehaviour is the base class from which every Unity script derives.
     */
    class MonoBehaviour extends Behaviour {
        constructor()
        /** Is any invoke on methodName pending?
         */
        IsInvoking(methodName: string): boolean
        IsInvoking(): boolean
        /** Cancels all Invoke calls with name methodName on this behaviour.
         */
        CancelInvoke(methodName: string): void
        CancelInvoke(): void
        /** Invokes the method methodName in time seconds.
         */
        Invoke(methodName: string, time: number): void
        /** Invokes the method methodName in time seconds, then repeatedly every repeatRate seconds.
         */
        InvokeRepeating(methodName: string, time: number, repeatRate: number): void
        /** Starts a coroutine named methodName.
         */
        StartCoroutine(methodName: string, value: Object1): Coroutine
        /** Starts a coroutine named methodName.
         */
        StartCoroutine(methodName: string): Coroutine
        /** Starts a Coroutine.
         */
        StartCoroutine(routine: IEnumerator): Coroutine
        /** Stops the first coroutine named methodName, or the coroutine stored in routine running on this behaviour.
         * @param methodName Name of coroutine.
         * @param routine Name of the function in code, including coroutines.
         */
        StopCoroutine(routine: IEnumerator): void
        /** Stops the first coroutine named methodName, or the coroutine stored in routine running on this behaviour.
         * @param methodName Name of coroutine.
         * @param routine Name of the function in code, including coroutines.
         */
        StopCoroutine(routine: Coroutine): void
        /** Stops the first coroutine named methodName, or the coroutine stored in routine running on this behaviour.
         * @param methodName Name of coroutine.
         * @param routine Name of the function in code, including coroutines.
         */
        StopCoroutine(methodName: string): void
        StopAllCoroutines(): void
        /** Logs message to the Unity Console (identical to Debug.Log).
         */
        static print(message: Object1): void
        /** Disabling this lets you skip the GUI layout phase.
         */
        useGUILayout: boolean
    }
}
declare module "UnityEngine" {
    import { Object as Object1 } from "System";
    /** A class you can derive from if you want to create objects that don't need to be attached to game objects.
     */
    class ScriptableObject extends Object {
        constructor()
        /** Creates an instance of a scriptable object.
         * @param className The type of the ScriptableObject to create, as the name of the type.
         * @param type The type of the ScriptableObject to create, as a System.Type instance.
         * @returns The created ScriptableObject. 
         */
        static CreateInstance(className: string): ScriptableObject
        /** Creates an instance of a scriptable object.
         * @param className The type of the ScriptableObject to create, as the name of the type.
         * @param type The type of the ScriptableObject to create, as a System.Type instance.
         * @returns The created ScriptableObject. 
         */
        static CreateInstance(type: any): ScriptableObject
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Enum, Array, Object as Object1, ValueType } from "System";
    import { List, IList } from "System.Collections.Generic";
    /** Represents a Sprite object for use in 2D gameplay.
     */
    class Sprite extends Object {
        GetPhysicsShapeCount(): number
        /** The number of points in the selected physics shape for the Sprite.
         * @param shapeIdx The index of the physics shape to retrieve the number of points from.
         * @returns The number of points in the selected physics shape for the Sprite. 
         */
        GetPhysicsShapePointCount(shapeIdx: number): number
        GetPhysicsShape(shapeIdx: number, physicsShape: any): number
        OverridePhysicsShape(physicsShapes: any): void
        /** Sets up new Sprite geometry.
         * @param vertices Array of vertex positions in Sprite Rect space.
         * @param triangles Array of sprite mesh triangle indices.
         */
        OverrideGeometry(vertices: Array<Vector2>, triangles: Array<number>): void
        /** Returns an array of BindPoses.
         * @param sprite The sprite to retrieve the bind pose from.
         * @returns A list of bind poses for this sprite. There is no need to dispose the returned NativeArray. 
         */
        GetBindPoses(): any
        SetBindPoses(src: any): void
        /** Returns a list of indices. This is the same as Sprite.triangle.
         * @returns A read-only list of indices indicating how the triangles are formed between the vertices. The array is marked as undisposable. 
         */
        GetIndices(): any
        SetIndices(src: any): void
        /** Returns a list of SpriteBone in this Sprite.
         * @param sprite The sprite to get the list of SpriteBone from.
         * @returns An array of SpriteBone that belongs to this Sprite. 
         */
        GetBones(): Array<any>
        /** Sets the SpriteBones for this Sprite.
         */
        SetBones(src: Array<any>): void
        /** Checks if a specific channel exists for this Sprite.
         * @returns True if the channel exists. 
         */
        HasVertexAttribute(channel: any): boolean
        /** Sets the vertex count. This resizes the internal buffer. It also preserves any configurations of VertexAttributes.
         */
        SetVertexCount(count: number): void
        /** Returns the number of vertices in this Sprite.
         */
        GetVertexCount(): number
        /** Create a new Sprite object.
         * @param texture Texture from which to obtain the sprite graphic.
         * @param rect Rectangular section of the texture to use for the sprite.
         * @param pivot Sprite's pivot point relative to its graphic rectangle.
         * @param pixelsPerUnit The number of pixels in the sprite that correspond to one unit in world space.
         * @param extrude Amount by which the sprite mesh should be expanded outwards.
         * @param meshType Controls the type of mesh generated for the sprite.
         * @param border The border sizes of the sprite (X=left, Y=bottom, Z=right, W=top).
         * @param generateFallbackPhysicsShape Generates a default physics shape for the sprite.
         */
        static Create(texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: number, extrude: number, meshType: any, border: Vector4, generateFallbackPhysicsShape: boolean): Sprite
        /** Create a new Sprite object.
         * @param texture Texture from which to obtain the sprite graphic.
         * @param rect Rectangular section of the texture to use for the sprite.
         * @param pivot Sprite's pivot point relative to its graphic rectangle.
         * @param pixelsPerUnit The number of pixels in the sprite that correspond to one unit in world space.
         * @param extrude Amount by which the sprite mesh should be expanded outwards.
         * @param meshType Controls the type of mesh generated for the sprite.
         * @param border The border sizes of the sprite (X=left, Y=bottom, Z=right, W=top).
         * @param generateFallbackPhysicsShape Generates a default physics shape for the sprite.
         */
        static Create(texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: number, extrude: number, meshType: any, border: Vector4): Sprite
        /** Create a new Sprite object.
         * @param texture Texture from which to obtain the sprite graphic.
         * @param rect Rectangular section of the texture to use for the sprite.
         * @param pivot Sprite's pivot point relative to its graphic rectangle.
         * @param pixelsPerUnit The number of pixels in the sprite that correspond to one unit in world space.
         * @param extrude Amount by which the sprite mesh should be expanded outwards.
         * @param meshType Controls the type of mesh generated for the sprite.
         * @param border The border sizes of the sprite (X=left, Y=bottom, Z=right, W=top).
         * @param generateFallbackPhysicsShape Generates a default physics shape for the sprite.
         */
        static Create(texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: number, extrude: number, meshType: any): Sprite
        /** Create a new Sprite object.
         * @param texture Texture from which to obtain the sprite graphic.
         * @param rect Rectangular section of the texture to use for the sprite.
         * @param pivot Sprite's pivot point relative to its graphic rectangle.
         * @param pixelsPerUnit The number of pixels in the sprite that correspond to one unit in world space.
         * @param extrude Amount by which the sprite mesh should be expanded outwards.
         * @param meshType Controls the type of mesh generated for the sprite.
         * @param border The border sizes of the sprite (X=left, Y=bottom, Z=right, W=top).
         * @param generateFallbackPhysicsShape Generates a default physics shape for the sprite.
         */
        static Create(texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: number, extrude: number): Sprite
        /** Create a new Sprite object.
         * @param texture Texture from which to obtain the sprite graphic.
         * @param rect Rectangular section of the texture to use for the sprite.
         * @param pivot Sprite's pivot point relative to its graphic rectangle.
         * @param pixelsPerUnit The number of pixels in the sprite that correspond to one unit in world space.
         * @param extrude Amount by which the sprite mesh should be expanded outwards.
         * @param meshType Controls the type of mesh generated for the sprite.
         * @param border The border sizes of the sprite (X=left, Y=bottom, Z=right, W=top).
         * @param generateFallbackPhysicsShape Generates a default physics shape for the sprite.
         */
        static Create(texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: number): Sprite
        /** Create a new Sprite object.
         * @param texture Texture from which to obtain the sprite graphic.
         * @param rect Rectangular section of the texture to use for the sprite.
         * @param pivot Sprite's pivot point relative to its graphic rectangle.
         * @param pixelsPerUnit The number of pixels in the sprite that correspond to one unit in world space.
         * @param extrude Amount by which the sprite mesh should be expanded outwards.
         * @param meshType Controls the type of mesh generated for the sprite.
         * @param border The border sizes of the sprite (X=left, Y=bottom, Z=right, W=top).
         * @param generateFallbackPhysicsShape Generates a default physics shape for the sprite.
         */
        static Create(texture: Texture2D, rect: Rect, pivot: Vector2): Sprite
        protected constructor()
        /** Bounds of the Sprite, specified by its center and extents in world space units.
         */
        readonly bounds: Bounds
        /** Location of the Sprite on the original Texture, specified in pixels.
         */
        readonly rect: Rect
        /** Returns the border sizes of the sprite.
         */
        readonly border: Vector4
        /** Get the reference to the used texture. If packed this will point to the atlas, if not packed will point to the source sprite.
         */
        readonly texture: Texture2D
        /** The number of pixels in the sprite that correspond to one unit in world space. (Read Only)
         */
        readonly pixelsPerUnit: number
        /** The Variant scale of texture used by the Sprite. This is useful to check when a Variant SpriteAtlas is being used by Sprites.
         */
        readonly spriteAtlasTextureScale: number
        /** Returns the texture that contains the alpha channel from the source texture. Unity generates this texture under the hood for sprites that have alpha in the source, and need to be compressed using techniques like ETC1.

Returns NULL if there is no associated alpha texture for the source sprite. This is the case if the sprite has not been setup to use ETC1 compression.
         */
        readonly associatedAlphaSplitTexture: Texture2D
        /** Location of the Sprite's center point in the Rect on the original Texture, specified in pixels.
         */
        readonly pivot: Vector2
        /** Returns true if this Sprite is packed in an atlas.
         */
        readonly packed: boolean
        /** If Sprite is packed (see Sprite.packed), returns its SpritePackingMode.
         */
        readonly packingMode: any
        /** If Sprite is packed (see Sprite.packed), returns its SpritePackingRotation.
         */
        readonly packingRotation: any
        /** Get the rectangle this sprite uses on its texture. Raises an exception if this sprite is tightly packed in an atlas.
         */
        readonly textureRect: Rect
        /** Gets the offset of the rectangle this sprite uses on its texture to the original sprite bounds. If sprite mesh type is FullRect, offset is zero.
         */
        readonly textureRectOffset: Vector2
        /** Returns a copy of the array containing sprite mesh vertex positions.
         */
        readonly vertices: Array<Vector2>
        /** Returns a copy of the array containing sprite mesh triangles.
         */
        readonly triangles: Array<number>
        /** The base texture coordinates of the sprite mesh.
         */
        readonly uv: Array<Vector2>
    }
}
declare module "UnityEngine" {
    import { Enum } from "System";
    /** Renders a Sprite for 2D graphics.
     */
    class SpriteRenderer extends Renderer {
        constructor()
        /** Stop using the deformable buffer to render the Sprite and use the original mesh instead.
         */
        DeactivateDeformableBuffer(): void
        /** The Sprite to render.
         */
        sprite: Sprite
        /** The current draw mode of the Sprite Renderer.
         */
        drawMode: any
        /** Property to set/get the size to render when the SpriteRenderer.drawMode is set to SpriteDrawMode.Sliced.
         */
        size: Vector2
        /** The current threshold for Sprite Renderer tiling.
         */
        adaptiveModeThreshold: number
        /** The current tile mode of the Sprite Renderer.
         */
        tileMode: any
        /** Rendering color for the Sprite graphic.
         */
        color: Color
        /** Specifies how the sprite interacts with the masks.
         */
        maskInteraction: any
        /** Flips the sprite on the X axis.
         */
        flipX: boolean
        /** Flips the sprite on the Y axis.
         */
        flipY: boolean
        /** Determines the position of the Sprite used for sorting the SpriteRenderer.
         */
        spriteSortPoint: any
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Enum, Array, Object as Object1, ValueType } from "System";
    import { List } from "System.Collections.Generic";
    /** General functionality for all renderers.
     */
    class Renderer extends Component {
        constructor()
        HasPropertyBlock(): boolean
        /** Lets you set or clear per-renderer or per-material parameter overrides.
         * @param properties Property block with values you want to override.
         * @param materialIndex The index of the Material you want to override the parameters of. The index ranges from 0 to Renderer.sharedMaterial.Length-1.
         */
        SetPropertyBlock(properties: any, materialIndex: number): void
        /** Lets you set or clear per-renderer or per-material parameter overrides.
         * @param properties Property block with values you want to override.
         * @param materialIndex The index of the Material you want to override the parameters of. The index ranges from 0 to Renderer.sharedMaterial.Length-1.
         */
        SetPropertyBlock(properties: any): void
        /** Get per-Renderer or per-Material property block.
         * @param properties Material parameters to retrieve.
         * @param materialIndex The index of the Material you want to get overridden parameters from. The index ranges from 0 to Renderer.sharedMaterials.Length-1.
         */
        GetPropertyBlock(properties: any, materialIndex: number): void
        /** Get per-Renderer or per-Material property block.
         * @param properties Material parameters to retrieve.
         * @param materialIndex The index of the Material you want to get overridden parameters from. The index ranges from 0 to Renderer.sharedMaterials.Length-1.
         */
        GetPropertyBlock(properties: any): void
        GetMaterials(m: any): void
        GetSharedMaterials(m: any): void
        GetClosestReflectionProbes(result: any): void
        /** Schedules an update of the albedo and emissive Textures of a system that contains the Renderer.
         */
        UpdateGIMaterials(): void
        /** The bounding volume of the renderer (Read Only).
         */
        readonly bounds: Bounds
        /** Makes the rendered 3D object visible if enabled.
         */
        enabled: boolean
        /** Is this renderer visible in any camera? (Read Only)
         */
        readonly isVisible: boolean
        /** Does this object cast shadows?
         */
        shadowCastingMode: any
        /** Does this object receive shadows?
         */
        receiveShadows: boolean
        /** Allows turning off rendering for a specific component.
         */
        forceRenderingOff: boolean
        /** Specifies the mode for motion vector rendering.
         */
        motionVectorGenerationMode: any
        /** The light probe interpolation type.
         */
        lightProbeUsage: any
        /** Should reflection probes be used for this Renderer?
         */
        reflectionProbeUsage: any
        /** Determines which rendering layer this renderer lives on.
         */
        renderingLayerMask: number
        /** This value sorts renderers by priority. Lower values are rendered first and higher values are rendered last.
         */
        rendererPriority: number
        /** Describes how this renderer is updated for ray tracing.
         */
        rayTracingMode: any
        /** Name of the Renderer's sorting layer.
         */
        sortingLayerName: string
        /** Unique ID of the Renderer's sorting layer.
         */
        sortingLayerID: number
        /** Renderer's order within a sorting layer.
         */
        sortingOrder: number
        /** Controls if dynamic occlusion culling should be performed for this renderer.
         */
        allowOcclusionWhenDynamic: boolean
        /** Has this renderer been statically batched with any other renderers?
         */
        readonly isPartOfStaticBatch: boolean
        /** Matrix that transforms a point from world space into local space (Read Only).
         */
        readonly worldToLocalMatrix: Matrix4x4
        /** Matrix that transforms a point from local space into world space (Read Only).
         */
        readonly localToWorldMatrix: Matrix4x4
        /** If set, the Renderer will use the Light Probe Proxy Volume component attached to the source GameObject.
         */
        lightProbeProxyVolumeOverride: GameObject
        /** If set, Renderer will use this Transform's position to find the light or reflection probe.
         */
        probeAnchor: Transform
        /** The index of the baked lightmap applied to this renderer.
         */
        lightmapIndex: number
        /** The index of the realtime lightmap applied to this renderer.
         */
        realtimeLightmapIndex: number
        /** The UV scale & offset used for a lightmap.
         */
        lightmapScaleOffset: Vector4
        /** The UV scale & offset used for a realtime lightmap.
         */
        realtimeLightmapScaleOffset: Vector4
        /** Returns all the instantiated materials of this object.
         */
        materials: Array<Material>
        /** Returns the first instantiated Material assigned to the renderer.
         */
        material: Material
        /** The shared material of this object.
         */
        sharedMaterial: Material
        /** All the shared materials of this object.
         */
        sharedMaterials: Array<Material>
    }
}
declare module "UnityEngine" {
    import { Enum } from "System";
    import { IEnumerator } from "System.Collections";
    /** The animation component is used to play back animations.
     */
    class Animation extends Behaviour {
        constructor()
        $GetValue(name: string): AnimationState
        /** Stops an animation named name.
         */
        Stop(name: string): void
        Stop(): void
        /** Rewinds the animation named name.
         */
        Rewind(name: string): void
        Rewind(): void
        Sample(): void
        /** Is the animation named name playing?
         */
        IsPlaying(name: string): boolean
        /** Plays an animation without blending.
         */
        Play(animation: string, mode: any): boolean
        /** Plays an animation without blending.
         */
        Play(mode: any): boolean
        /** Plays an animation without blending.
         */
        Play(animation: string): boolean
        /** Plays an animation without blending.
         */
        Play(): boolean
        /** Fades the animation with name animation in over a period of time seconds and fades other animations out.
         */
        CrossFade(animation: string, fadeLength: number, mode: any): void
        /** Fades the animation with name animation in over a period of time seconds and fades other animations out.
         */
        CrossFade(animation: string, fadeLength: number): void
        /** Fades the animation with name animation in over a period of time seconds and fades other animations out.
         */
        CrossFade(animation: string): void
        /** Blends the animation named animation towards targetWeight over the next time seconds.
         */
        Blend(animation: string, targetWeight: number, fadeLength: number): void
        /** Blends the animation named animation towards targetWeight over the next time seconds.
         */
        Blend(animation: string, targetWeight: number): void
        /** Blends the animation named animation towards targetWeight over the next time seconds.
         */
        Blend(animation: string): void
        /** Cross fades an animation after previous animations has finished playing.
         */
        CrossFadeQueued(animation: string, fadeLength: number, queue: any, mode: any): AnimationState
        /** Cross fades an animation after previous animations has finished playing.
         */
        CrossFadeQueued(animation: string, fadeLength: number, queue: any): AnimationState
        /** Cross fades an animation after previous animations has finished playing.
         */
        CrossFadeQueued(animation: string, fadeLength: number): AnimationState
        /** Cross fades an animation after previous animations has finished playing.
         */
        CrossFadeQueued(animation: string): AnimationState
        /** Plays an animation after previous animations has finished playing.
         */
        PlayQueued(animation: string, queue: any, mode: any): AnimationState
        /** Plays an animation after previous animations has finished playing.
         */
        PlayQueued(animation: string, queue: any): AnimationState
        /** Plays an animation after previous animations has finished playing.
         */
        PlayQueued(animation: string): AnimationState
        /** Adds clip to the only play between firstFrame and lastFrame. The new clip will also be added to the animation with name newName.
         * @param addLoopFrame Should an extra frame be inserted at the end that matches the first frame? Turn this on if you are making a looping animation.
         */
        AddClip(clip: AnimationClip, newName: string, firstFrame: number, lastFrame: number, addLoopFrame: boolean): void
        /** Adds clip to the only play between firstFrame and lastFrame. The new clip will also be added to the animation with name newName.
         * @param addLoopFrame Should an extra frame be inserted at the end that matches the first frame? Turn this on if you are making a looping animation.
         */
        AddClip(clip: AnimationClip, newName: string, firstFrame: number, lastFrame: number): void
        /** Adds a clip to the animation with name newName.
         */
        AddClip(clip: AnimationClip, newName: string): void
        /** Remove clip from the animation list.
         */
        RemoveClip(clip: AnimationClip): void
        /** Remove clip from the animation list.
         */
        RemoveClip(clipName: string): void
        GetClipCount(): number
        SyncLayer(layer: number): void
        GetEnumerator(): IEnumerator
        GetClip(name: string): AnimationClip
        /** The default animation.
         */
        clip: AnimationClip
        /** Should the default animation clip (the Animation.clip property) automatically start playing on startup?
         */
        playAutomatically: boolean
        /** How should time beyond the playback range of the clip be treated?
         */
        wrapMode: WrapMode
        /** Is an animation currently being played?
         */
        readonly isPlaying: boolean
        /** When turned on, animations will be executed in the physics loop. This is only useful in conjunction with kinematic rigidbodies.
         */
        animatePhysics: boolean
        /** Controls culling of this Animation component.
         */
        cullingType: any
        /** AABB of this Animation animation component in local space.
         */
        localBounds: Bounds
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Array, Object as Object1 } from "System";
    /** Stores keyframe based animations.
     */
    class AnimationClip extends Motion {
        constructor()
        /** Samples an animation at a given time for any animated properties.
         * @param go The animated game object.
         * @param time The time to sample an animation.
         */
        SampleAnimation(go: GameObject, time: number): void
        /** Assigns the curve to animate a specific property.
         * @param relativePath Path to the game object this curve applies to. The relativePath
        is formatted similar to a pathname, e.g. "rootspineleftArm".  If relativePath
        is empty it refers to the game object the animation clip is attached to.
         * @param type The class type of the component that is animated.
         * @param propertyName The name or path to the property being animated.
         * @param curve The animation curve.
         */
        SetCurve(relativePath: string, type: any, propertyName: string, curve: AnimationCurve): void
        EnsureQuaternionContinuity(): void
        ClearCurves(): void
        /** Adds an animation event to the clip.
         * @param evt AnimationEvent to add.
         */
        AddEvent(evt: any): void
        /** Animation length in seconds. (Read Only)
         */
        readonly length: number
        /** Frame rate at which keyframes are sampled. (Read Only)
         */
        frameRate: number
        /** Sets the default wrap mode used in the animation state.
         */
        wrapMode: WrapMode
        /** AABB of this Animation Clip in local space of Animation component that it is attached too.
         */
        localBounds: Bounds
        /** Set to true if the AnimationClip will be used with the Legacy Animation component ( instead of the Animator ).
         */
        legacy: boolean
        /** Returns true if the animation contains curve that drives a humanoid rig.
         */
        readonly humanMotion: boolean
        /** Returns true if the animation clip has no curves and no events.
         */
        readonly empty: boolean
        /** Returns true if the Animation has animation on the root transform.
         */
        readonly hasGenericRootTransform: boolean
        /** Returns true if the AnimationClip has editor curves for its root motion.
         */
        readonly hasMotionFloatCurves: boolean
        /** Returns true if the AnimationClip has root motion curves.
         */
        readonly hasMotionCurves: boolean
        /** Returns true if the AnimationClip has root Curves.
         */
        readonly hasRootCurves: boolean
        /** Animation Events for this animation clip.
         */
        events: Array<any>
    }
}
declare module "UnityEngine" {
    /** Base class for AnimationClips and BlendTrees.
     */
    class Motion extends Object {
        protected constructor()
        readonly averageDuration: number
        readonly averageAngularSpeed: number
        readonly averageSpeed: Vector3
        readonly apparentSpeed: number
        readonly isLooping: boolean
        readonly legacy: boolean
        readonly isHumanMotion: boolean
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Enum, Array, Object as Object1, ValueType } from "System";
    import { List } from "System.Collections.Generic";
    /** Interface to control the Mecanim animation system.
     */
    class Animator extends Behaviour {
        constructor()
        /** Returns the value of the given float parameter.
         * @param name The parameter name.
         * @param id The parameter ID.
         * @returns The value of the parameter. 
         */
        GetFloat(name: string): number
        /** Returns the value of the given float parameter.
         * @param name The parameter name.
         * @param id The parameter ID.
         * @returns The value of the parameter. 
         */
        GetFloat(id: number): number
        /** Send float values to the Animator to affect transitions.
         * @param name The parameter name.
         * @param id The parameter ID.
         * @param value The new parameter value.
         * @param dampTime The damper total time.
         * @param deltaTime The delta time to give to the damper.
         */
        SetFloat(name: string, value: number, dampTime: number, deltaTime: number): void
        /** Send float values to the Animator to affect transitions.
         * @param name The parameter name.
         * @param id The parameter ID.
         * @param value The new parameter value.
         * @param dampTime The damper total time.
         * @param deltaTime The delta time to give to the damper.
         */
        SetFloat(id: number, value: number, dampTime: number, deltaTime: number): void
        /** Send float values to the Animator to affect transitions.
         * @param name The parameter name.
         * @param id The parameter ID.
         * @param value The new parameter value.
         * @param dampTime The damper total time.
         * @param deltaTime The delta time to give to the damper.
         */
        SetFloat(name: string, value: number): void
        /** Send float values to the Animator to affect transitions.
         * @param name The parameter name.
         * @param id The parameter ID.
         * @param value The new parameter value.
         * @param dampTime The damper total time.
         * @param deltaTime The delta time to give to the damper.
         */
        SetFloat(id: number, value: number): void
        /** Returns the value of the given boolean parameter.
         * @param name The parameter name.
         * @param id The parameter ID.
         * @returns The value of the parameter. 
         */
        GetBool(name: string): boolean
        /** Returns the value of the given boolean parameter.
         * @param name The parameter name.
         * @param id The parameter ID.
         * @returns The value of the parameter. 
         */
        GetBool(id: number): boolean
        /** Sets the value of the given boolean parameter.
         * @param name The parameter name.
         * @param id The parameter ID.
         * @param value The new parameter value.
         */
        SetBool(name: string, value: boolean): void
        /** Sets the value of the given boolean parameter.
         * @param name The parameter name.
         * @param id The parameter ID.
         * @param value The new parameter value.
         */
        SetBool(id: number, value: boolean): void
        /** Returns the value of the given integer parameter.
         * @param name The parameter name.
         * @param id The parameter ID.
         * @returns The value of the parameter. 
         */
        GetInteger(name: string): number
        /** Returns the value of the given integer parameter.
         * @param name The parameter name.
         * @param id The parameter ID.
         * @returns The value of the parameter. 
         */
        GetInteger(id: number): number
        /** Sets the value of the given integer parameter.
         * @param name The parameter name.
         * @param id The parameter ID.
         * @param value The new parameter value.
         */
        SetInteger(name: string, value: number): void
        /** Sets the value of the given integer parameter.
         * @param name The parameter name.
         * @param id The parameter ID.
         * @param value The new parameter value.
         */
        SetInteger(id: number, value: number): void
        /** Sets the value of the given trigger parameter.
         * @param name The parameter name.
         * @param id The parameter ID.
         */
        SetTrigger(name: string): void
        /** Sets the value of the given trigger parameter.
         * @param name The parameter name.
         * @param id The parameter ID.
         */
        SetTrigger(id: number): void
        /** Resets the value of the given trigger parameter.
         * @param name The parameter name.
         * @param id The parameter ID.
         */
        ResetTrigger(name: string): void
        /** Resets the value of the given trigger parameter.
         * @param name The parameter name.
         * @param id The parameter ID.
         */
        ResetTrigger(id: number): void
        /** Returns true if the parameter is controlled by a curve, false otherwise.
         * @param name The parameter name.
         * @param id The parameter ID.
         * @returns True if the parameter is controlled by a curve, false otherwise. 
         */
        IsParameterControlledByCurve(name: string): boolean
        /** Returns true if the parameter is controlled by a curve, false otherwise.
         * @param name The parameter name.
         * @param id The parameter ID.
         * @returns True if the parameter is controlled by a curve, false otherwise. 
         */
        IsParameterControlledByCurve(id: number): boolean
        /** Gets the position of an IK goal.
         * @param goal The AvatarIKGoal that is queried.
         * @returns Return the current position of this IK goal in world space. 
         */
        GetIKPosition(goal: any): Vector3
        /** Sets the position of an IK goal.
         * @param goal The AvatarIKGoal that is set.
         * @param goalPosition The position in world space.
         */
        SetIKPosition(goal: any, goalPosition: Vector3): void
        /** Gets the rotation of an IK goal.
         * @param goal The AvatarIKGoal that is is queried.
         */
        GetIKRotation(goal: any): Quaternion
        /** Sets the rotation of an IK goal.
         * @param goal The AvatarIKGoal that is set.
         * @param goalRotation The rotation in world space.
         */
        SetIKRotation(goal: any, goalRotation: Quaternion): void
        /** Gets the translative weight of an IK goal (0 = at the original animation before IK, 1 = at the goal).
         * @param goal The AvatarIKGoal that is queried.
         */
        GetIKPositionWeight(goal: any): number
        /** Sets the translative weight of an IK goal (0 = at the original animation before IK, 1 = at the goal).
         * @param goal The AvatarIKGoal that is set.
         * @param value The translative weight.
         */
        SetIKPositionWeight(goal: any, value: number): void
        /** Gets the rotational weight of an IK goal (0 = rotation before IK, 1 = rotation at the IK goal).
         * @param goal The AvatarIKGoal that is queried.
         */
        GetIKRotationWeight(goal: any): number
        /** Sets the rotational weight of an IK goal (0 = rotation before IK, 1 = rotation at the IK goal).
         * @param goal The AvatarIKGoal that is set.
         * @param value The rotational weight.
         */
        SetIKRotationWeight(goal: any, value: number): void
        /** Gets the position of an IK hint.
         * @param hint The AvatarIKHint that is queried.
         * @returns Return the current position of this IK hint in world space. 
         */
        GetIKHintPosition(hint: any): Vector3
        /** Sets the position of an IK hint.
         * @param hint The AvatarIKHint that is set.
         * @param hintPosition The position in world space.
         */
        SetIKHintPosition(hint: any, hintPosition: Vector3): void
        /** Gets the translative weight of an IK Hint (0 = at the original animation before IK, 1 = at the hint).
         * @param hint The AvatarIKHint that is queried.
         * @returns Return translative weight. 
         */
        GetIKHintPositionWeight(hint: any): number
        /** Sets the translative weight of an IK hint (0 = at the original animation before IK, 1 = at the hint).
         * @param hint The AvatarIKHint that is set.
         * @param value The translative weight.
         */
        SetIKHintPositionWeight(hint: any, value: number): void
        /** Sets the look at position.
         * @param lookAtPosition The position to lookAt.
         */
        SetLookAtPosition(lookAtPosition: Vector3): void
        /** Set look at weights.
         * @param weight (0-1) the global weight of the LookAt, multiplier for other parameters.
         * @param bodyWeight (0-1) determines how much the body is involved in the LookAt.
         * @param headWeight (0-1) determines how much the head is involved in the LookAt.
         * @param eyesWeight (0-1) determines how much the eyes are involved in the LookAt.
         * @param clampWeight (0-1) 0.0 means the character is completely unrestrained in motion, 1.0 means he's completely clamped (look at becomes impossible), and 0.5 means he'll be able to move on half of the possible range (180 degrees).
         */
        SetLookAtWeight(weight: number, bodyWeight: number, headWeight: number, eyesWeight: number, clampWeight: number): void
        /** Set look at weights.
         * @param weight (0-1) the global weight of the LookAt, multiplier for other parameters.
         * @param bodyWeight (0-1) determines how much the body is involved in the LookAt.
         * @param headWeight (0-1) determines how much the head is involved in the LookAt.
         * @param eyesWeight (0-1) determines how much the eyes are involved in the LookAt.
         * @param clampWeight (0-1) 0.0 means the character is completely unrestrained in motion, 1.0 means he's completely clamped (look at becomes impossible), and 0.5 means he'll be able to move on half of the possible range (180 degrees).
         */
        SetLookAtWeight(weight: number, bodyWeight: number, headWeight: number, eyesWeight: number): void
        /** Set look at weights.
         * @param weight (0-1) the global weight of the LookAt, multiplier for other parameters.
         * @param bodyWeight (0-1) determines how much the body is involved in the LookAt.
         * @param headWeight (0-1) determines how much the head is involved in the LookAt.
         * @param eyesWeight (0-1) determines how much the eyes are involved in the LookAt.
         * @param clampWeight (0-1) 0.0 means the character is completely unrestrained in motion, 1.0 means he's completely clamped (look at becomes impossible), and 0.5 means he'll be able to move on half of the possible range (180 degrees).
         */
        SetLookAtWeight(weight: number, bodyWeight: number, headWeight: number): void
        /** Set look at weights.
         * @param weight (0-1) the global weight of the LookAt, multiplier for other parameters.
         * @param bodyWeight (0-1) determines how much the body is involved in the LookAt.
         * @param headWeight (0-1) determines how much the head is involved in the LookAt.
         * @param eyesWeight (0-1) determines how much the eyes are involved in the LookAt.
         * @param clampWeight (0-1) 0.0 means the character is completely unrestrained in motion, 1.0 means he's completely clamped (look at becomes impossible), and 0.5 means he'll be able to move on half of the possible range (180 degrees).
         */
        SetLookAtWeight(weight: number, bodyWeight: number): void
        /** Set look at weights.
         * @param weight (0-1) the global weight of the LookAt, multiplier for other parameters.
         * @param bodyWeight (0-1) determines how much the body is involved in the LookAt.
         * @param headWeight (0-1) determines how much the head is involved in the LookAt.
         * @param eyesWeight (0-1) determines how much the eyes are involved in the LookAt.
         * @param clampWeight (0-1) 0.0 means the character is completely unrestrained in motion, 1.0 means he's completely clamped (look at becomes impossible), and 0.5 means he'll be able to move on half of the possible range (180 degrees).
         */
        SetLookAtWeight(weight: number): void
        /** Sets local rotation of a human bone during a IK pass.
         * @param humanBoneId The human bone Id.
         * @param rotation The local rotation.
         */
        SetBoneLocalRotation(humanBoneId: any, rotation: Quaternion): void
        GetBehaviours(fullPathHash: number, layerIndex: number): Array<any>
        /** Returns the layer name.
         * @param layerIndex The layer index.
         * @returns The layer name. 
         */
        GetLayerName(layerIndex: number): string
        /** Returns the index of the layer with the given name.
         * @param layerName The layer name.
         * @returns The layer index. 
         */
        GetLayerIndex(layerName: string): number
        /** Returns the weight of the layer at the specified index.
         * @param layerIndex The layer index.
         * @returns The layer weight. 
         */
        GetLayerWeight(layerIndex: number): number
        /** Sets the weight of the layer at the given index.
         * @param layerIndex The layer index.
         * @param weight The new layer weight.
         */
        SetLayerWeight(layerIndex: number, weight: number): void
        /** Returns an AnimatorStateInfo with the information on the current state.
         * @param layerIndex The layer index.
         * @returns An AnimatorStateInfo with the information on the current state. 
         */
        GetCurrentAnimatorStateInfo(layerIndex: number): any
        /** Returns an AnimatorStateInfo with the information on the next state.
         * @param layerIndex The layer index.
         * @returns An AnimatorStateInfo with the information on the next state. 
         */
        GetNextAnimatorStateInfo(layerIndex: number): any
        /** Returns an AnimatorTransitionInfo with the informations on the current transition.
         * @param layerIndex The layer's index.
         * @returns An AnimatorTransitionInfo with the informations on the current transition. 
         */
        GetAnimatorTransitionInfo(layerIndex: number): any
        /** Returns the number of AnimatorClipInfo in the current state.
         * @param layerIndex The layer index.
         * @returns The number of AnimatorClipInfo in the current state. 
         */
        GetCurrentAnimatorClipInfoCount(layerIndex: number): number
        /** Returns the number of AnimatorClipInfo in the next state.
         * @param layerIndex The layer index.
         * @returns The number of AnimatorClipInfo in the next state. 
         */
        GetNextAnimatorClipInfoCount(layerIndex: number): number
        GetCurrentAnimatorClipInfo(layerIndex: number, clips: any): void
        /** Returns an array of all the AnimatorClipInfo in the current state of the given layer.
         * @param layerIndex The layer index.
         * @returns An array of all the AnimatorClipInfo in the current state. 
         */
        GetCurrentAnimatorClipInfo(layerIndex: number): Array<any>
        GetNextAnimatorClipInfo(layerIndex: number, clips: any): void
        /** Returns an array of all the AnimatorClipInfo in the next state of the given layer.
         * @param layerIndex The layer index.
         * @returns An array of all the AnimatorClipInfo in the next state. 
         */
        GetNextAnimatorClipInfo(layerIndex: number): Array<any>
        /** Returns true if there is a transition on the given layer, false otherwise.
         * @param layerIndex The layer index.
         * @returns True if there is a transition on the given layer, false otherwise. 
         */
        IsInTransition(layerIndex: number): boolean
        /** See AnimatorController.parameters.
         */
        GetParameter(index: number): any
        MatchTarget(matchPosition: Vector3, matchRotation: Quaternion, targetBodyPart: any, weightMask: any, startNormalizedTime: number, targetNormalizedTime: number, completeMatch: boolean): void
        /** Automatically adjust the GameObject position and rotation.
         * @param matchPosition The position we want the body part to reach.
         * @param matchRotation The rotation in which we want the body part to be.
         * @param targetBodyPart The body part that is involved in the match.
         * @param weightMask Structure that contains weights for matching position and rotation.
         * @param startNormalizedTime Start time within the animation clip (0 - beginning of clip, 1 - end of clip).
         * @param targetNormalizedTime End time within the animation clip (0 - beginning of clip, 1 - end of clip), values greater than 1 can be set to trigger a match after a certain number of loops. Ex: 2.3 means at 30% of 2nd loop.
         * @param completeMatch Allows you to specify what should happen if the MatchTarget function is interrupted. A value of true causes the GameObject to immediately move to the matchPosition if interrupted. A value of false causes the GameObject to stay at its current position if interrupted.
         */
        MatchTarget(matchPosition: Vector3, matchRotation: Quaternion, targetBodyPart: any, weightMask: any, startNormalizedTime: number, targetNormalizedTime: number): void
        MatchTarget(matchPosition: Vector3, matchRotation: Quaternion, targetBodyPart: any, weightMask: any, startNormalizedTime: number): void
        /** Interrupts the automatic target matching.
         */
        InterruptMatchTarget(completeMatch: boolean): void
        InterruptMatchTarget(): void
        /** Creates a crossfade from the current state to any other state using times in seconds.
         * @param stateName The name of the state.
         * @param stateHashName The hash name of the state.
         * @param fixedTransitionDuration The duration of the transition (in seconds).
         * @param layer The layer where the crossfade occurs.
         * @param fixedTimeOffset The time of the state (in seconds).
         * @param normalizedTransitionTime The time of the transition (normalized).
         */
        CrossFadeInFixedTime(stateName: string, fixedTransitionDuration: number, layer: number, fixedTimeOffset: number, normalizedTransitionTime: number): void
        /** Creates a crossfade from the current state to any other state using times in seconds.
         * @param stateName The name of the state.
         * @param stateHashName The hash name of the state.
         * @param fixedTransitionDuration The duration of the transition (in seconds).
         * @param layer The layer where the crossfade occurs.
         * @param fixedTimeOffset The time of the state (in seconds).
         * @param normalizedTransitionTime The time of the transition (normalized).
         */
        CrossFadeInFixedTime(stateHashName: number, fixedTransitionDuration: number, layer: number, fixedTimeOffset: number, normalizedTransitionTime: number): void
        CrossFadeInFixedTime(stateName: string, fixedTransitionDuration: number, layer: number, fixedTimeOffset: number): void
        CrossFadeInFixedTime(stateHashName: number, fixedTransitionDuration: number, layer: number, fixedTimeOffset: number): void
        CrossFadeInFixedTime(stateName: string, fixedTransitionDuration: number, layer: number): void
        CrossFadeInFixedTime(stateHashName: number, fixedTransitionDuration: number, layer: number): void
        CrossFadeInFixedTime(stateName: string, fixedTransitionDuration: number): void
        CrossFadeInFixedTime(stateHashName: number, fixedTransitionDuration: number): void
        WriteDefaultValues(): void
        /** Creates a crossfade from the current state to any other state using normalized times.
         * @param stateName The name of the state.
         * @param stateHashName The hash name of the state.
         * @param normalizedTransitionDuration The duration of the transition (normalized).
         * @param layer The layer where the crossfade occurs.
         * @param normalizedTimeOffset The time of the state (normalized).
         * @param normalizedTransitionTime The time of the transition (normalized).
         */
        CrossFade(stateName: string, normalizedTransitionDuration: number, layer: number, normalizedTimeOffset: number, normalizedTransitionTime: number): void
        /** Creates a crossfade from the current state to any other state using normalized times.
         * @param stateName The name of the state.
         * @param stateHashName The hash name of the state.
         * @param normalizedTransitionDuration The duration of the transition (normalized).
         * @param layer The layer where the crossfade occurs.
         * @param normalizedTimeOffset The time of the state (normalized).
         * @param normalizedTransitionTime The time of the transition (normalized).
         */
        CrossFade(stateHashName: number, normalizedTransitionDuration: number, layer: number, normalizedTimeOffset: number, normalizedTransitionTime: number): void
        CrossFade(stateName: string, normalizedTransitionDuration: number, layer: number, normalizedTimeOffset: number): void
        CrossFade(stateHashName: number, normalizedTransitionDuration: number, layer: number, normalizedTimeOffset: number): void
        CrossFade(stateName: string, normalizedTransitionDuration: number, layer: number): void
        CrossFade(stateHashName: number, normalizedTransitionDuration: number, layer: number): void
        CrossFade(stateName: string, normalizedTransitionDuration: number): void
        CrossFade(stateHashName: number, normalizedTransitionDuration: number): void
        /** Plays a state.
         * @param stateName The state name.
         * @param stateNameHash The state hash name. If stateNameHash is 0, it changes the current state time.
         * @param layer The layer index. If layer is -1, it plays the first state with the given state name or hash.
         * @param fixedTime The time offset (in seconds).
         */
        PlayInFixedTime(stateName: string, layer: number, fixedTime: number): void
        /** Plays a state.
         * @param stateName The state name.
         * @param stateNameHash The state hash name. If stateNameHash is 0, it changes the current state time.
         * @param layer The layer index. If layer is -1, it plays the first state with the given state name or hash.
         * @param fixedTime The time offset (in seconds).
         */
        PlayInFixedTime(stateNameHash: number, layer: number, fixedTime: number): void
        PlayInFixedTime(stateName: string, layer: number): void
        PlayInFixedTime(stateNameHash: number, layer: number): void
        PlayInFixedTime(stateName: string): void
        PlayInFixedTime(stateNameHash: number): void
        /** Plays a state.
         * @param stateName The state name.
         * @param stateNameHash The state hash name. If stateNameHash is 0, it changes the current state time.
         * @param layer The layer index. If layer is -1, it plays the first state with the given state name or hash.
         * @param normalizedTime The time offset between zero and one.
         */
        Play(stateName: string, layer: number, normalizedTime: number): void
        /** Plays a state.
         * @param stateName The state name.
         * @param stateNameHash The state hash name. If stateNameHash is 0, it changes the current state time.
         * @param layer The layer index. If layer is -1, it plays the first state with the given state name or hash.
         * @param normalizedTime The time offset between zero and one.
         */
        Play(stateNameHash: number, layer: number, normalizedTime: number): void
        Play(stateName: string, layer: number): void
        Play(stateNameHash: number, layer: number): void
        Play(stateName: string): void
        Play(stateNameHash: number): void
        /** Sets an AvatarTarget and a targetNormalizedTime for the current state.
         * @param targetIndex The avatar body part that is queried.
         * @param targetNormalizedTime The current state Time that is queried.
         */
        SetTarget(targetIndex: any, targetNormalizedTime: number): void
        /** Returns Transform mapped to this human bone id.
         * @param humanBoneId The human bone that is queried, see enum HumanBodyBones for a list of possible values.
         */
        GetBoneTransform(humanBoneId: any): Transform
        StartPlayback(): void
        StopPlayback(): void
        /** Sets the animator in recording mode, and allocates a circular buffer of size frameCount.
         * @param frameCount The number of frames (updates) that will be recorded. If frameCount is 0, the recording will continue until the user calls StopRecording. The maximum value for frameCount is 10000.
         */
        StartRecording(frameCount: number): void
        StopRecording(): void
        /** Returns true if the state exists in this layer, false otherwise.
         * @param layerIndex The layer index.
         * @param stateID The state ID.
         * @returns True if the state exists in this layer, false otherwise. 
         */
        HasState(layerIndex: number, stateID: number): boolean
        /** Evaluates the animator based on deltaTime.
         * @param deltaTime The time delta.
         */
        Update(deltaTime: number): void
        Rebind(): void
        ApplyBuiltinRootMotion(): void
        /** Creates a dependency between animator jobs and the job represented by the supplied job handle. To add multiple job dependencies, call this method for each job that need to run before the Animator's jobs.
         * @param animator The Animator instance that calls this method.
         * @param jobHandle The JobHandle of the job that needs to run before animator jobs.
         */
        AddJobDependency(jobHandle: any): void
        /** Create a TransformStreamHandle representing the new binding between the Animator and a Transform already bound to the Animator.
         * @param animator The Animator instance that calls this method.
         * @param transform The Transform to bind.
         * @returns Returns the TransformStreamHandle that represents the new binding. 
         */
        BindStreamTransform(transform: Transform): any
        /** Create a PropertyStreamHandle representing the new binding on the Component property of a Transform already bound to the Animator.
         * @param animator The Animator instance that calls this method.
         * @param transform The Transform to target.
         * @param type The Component type.
         * @param property The property to bind.
         * @param isObjectReference isObjectReference need to be set to true if the property to bind does animate an Object like SpriteRenderer.sprite.
         * @returns Returns the PropertyStreamHandle that represents the new binding. 
         */
        BindStreamProperty(transform: Transform, type: any, property: string, isObjectReference: boolean): any
        /** Create a PropertyStreamHandle representing the new binding on the Component property of a Transform already bound to the Animator.
         * @param animator The Animator instance that calls this method.
         * @param transform The Transform to target.
         * @param type The Component type.
         * @param property The property to bind.
         * @param isObjectReference isObjectReference need to be set to true if the property to bind does animate an Object like SpriteRenderer.sprite.
         * @returns Returns the PropertyStreamHandle that represents the new binding. 
         */
        BindStreamProperty(transform: Transform, type: any, property: string): any
        /** Create a custom property in the AnimationStream to pass extra data to downstream animation jobs in your graph. Custom properties created in the AnimationStream do not exist in the scene.
         * @param animator The Animator instance that calls this method.
         * @param name The name of the property.
         * @param type The type of property to create (float, integer or boolean).
         * @returns Returns the PropertyStreamHandle that represents the new binding. 
         */
        BindCustomStreamProperty(property: string, type: any): any
        /** Create a TransformSceneHandle representing the new binding between the Animator and a Transform in the Scene.
         * @param animator The Animator instance that calls this method.
         * @param transform The Transform to bind.
         * @returns Returns the TransformSceneHandle that represents the new binding. 
         */
        BindSceneTransform(transform: Transform): any
        /** Create a PropertySceneHandle representing the new binding on the Component property of a Transform in the Scene.
         * @param animator The Animator instance that calls this method.
         * @param transform The Transform to target.
         * @param type The Component type.
         * @param property The property to bind.
         * @param isObjectReference isObjectReference need to be set to true if the property to bind does access an Object like SpriteRenderer.sprite.
         * @returns Returns the PropertySceneHandle that represents the new binding. 
         */
        BindSceneProperty(transform: Transform, type: any, property: string, isObjectReference: boolean): any
        /** Create a PropertySceneHandle representing the new binding on the Component property of a Transform in the Scene.
         * @param animator The Animator instance that calls this method.
         * @param transform The Transform to target.
         * @param type The Component type.
         * @param property The property to bind.
         * @param isObjectReference isObjectReference need to be set to true if the property to bind does access an Object like SpriteRenderer.sprite.
         * @returns Returns the PropertySceneHandle that represents the new binding. 
         */
        BindSceneProperty(transform: Transform, type: any, property: string): any
        /** Open a new stream on the Animator.
         * @param animator The Animator instance that calls this method.
         * @param stream The new stream.
         * @returns Returns whether or not the stream has been opened. 
         */
        OpenAnimationStream(stream: jsb.Ref<any>): boolean
        /** Close a stream that has been opened using OpenAnimationStream.
         * @param animator The Animator instance that calls this method.
         * @param stream The stream to close.
         */
        CloseAnimationStream(stream: jsb.Ref<any>): void
        /** Newly created handles are always resolved lazily on the next access when the jobs are run. To avoid a cpu spike while evaluating the jobs you can manually resolve all handles from the main thread.
         * @param animator The Animator instance that calls this method.
         */
        ResolveAllStreamHandles(): void
        /** Newly created handles are always resolved lazily on the next access when the jobs are run. To avoid a cpu spike while evaluating the jobs you can manually resolve all handles from the main thread.
         * @param animator The Animator instance that calls this method.
         */
        ResolveAllSceneHandles(): void
        /** Generates an parameter id from a string.
         * @param name The string to convert to Id.
         */
        static StringToHash(name: string): number
        /** Returns true if the current rig is optimizable with AnimatorUtility.OptimizeTransformHierarchy.
         */
        readonly isOptimizable: boolean
        /** Returns true if the current rig is humanoid, false if it is generic.
         */
        readonly isHuman: boolean
        /** Returns true if the current rig has root motion.
         */
        readonly hasRootMotion: boolean
        /** Returns the scale of the current Avatar for a humanoid rig, (1 by default if the rig is generic).
         */
        readonly humanScale: number
        /** Returns whether the animator is initialized successfully.
         */
        readonly isInitialized: boolean
        /** Gets the avatar delta position for the last evaluated frame.
         */
        readonly deltaPosition: Vector3
        /** Gets the avatar delta rotation for the last evaluated frame.
         */
        readonly deltaRotation: Quaternion
        /** Gets the avatar velocity  for the last evaluated frame.
         */
        readonly velocity: Vector3
        /** Gets the avatar angular velocity for the last evaluated frame.
         */
        readonly angularVelocity: Vector3
        /** The root position, the position of the game object.
         */
        rootPosition: Vector3
        /** The root rotation, the rotation of the game object.
         */
        rootRotation: Quaternion
        /** Should root motion be applied?
         */
        applyRootMotion: boolean
        /** Specifies the update mode of the Animator.
         */
        updateMode: any
        /** Returns true if the object has a transform hierarchy.
         */
        readonly hasTransformHierarchy: boolean
        /** The current gravity weight based on current animations that are played.
         */
        readonly gravityWeight: number
        /** The position of the body center of mass.
         */
        bodyPosition: Vector3
        /** The rotation of the body center of mass.
         */
        bodyRotation: Quaternion
        /** Automatic stabilization of feet during transition and blending.
         */
        stabilizeFeet: boolean
        /** Returns the number of layers in the controller.
         */
        readonly layerCount: number
        /** The AnimatorControllerParameter list used by the animator. (Read Only)
         */
        readonly parameters: Array<any>
        /** Returns the number of parameters in the controller.
         */
        readonly parameterCount: number
        /** Blends pivot point between body center of mass and feet pivot.
         */
        feetPivotActive: number
        /** Gets the pivot weight.
         */
        readonly pivotWeight: number
        /** Get the current position of the pivot.
         */
        readonly pivotPosition: Vector3
        /** If automatic matching is active.
         */
        readonly isMatchingTarget: boolean
        /** The playback speed of the Animator. 1 is normal playback speed.
         */
        speed: number
        /** Returns the position of the target specified by SetTarget.
         */
        readonly targetPosition: Vector3
        /** Returns the rotation of the target specified by SetTarget.
         */
        readonly targetRotation: Quaternion
        /** Controls culling of this Animator component.
         */
        cullingMode: any
        /** Sets the playback position in the recording buffer.
         */
        playbackTime: number
        /** Start time of the first frame of the buffer relative to the frame at which StartRecording was called.
         */
        recorderStartTime: number
        /** End time of the recorded clip relative to when StartRecording was called.
         */
        recorderStopTime: number
        /** Gets the mode of the Animator recorder.
         */
        readonly recorderMode: any
        /** The runtime representation of AnimatorController that controls the Animator.
         */
        runtimeAnimatorController: any
        /** Returns true if Animator has any playables assigned to it.
         */
        readonly hasBoundPlayables: boolean
        /** Gets/Sets the current Avatar.
         */
        avatar: any
        /** The PlayableGraph created by the Animator.
         */
        readonly playableGraph: any
        /** Additional layers affects the center of mass.
         */
        layersAffectMassCenter: boolean
        /** Get left foot bottom height.
         */
        readonly leftFeetBottomHeight: number
        /** Get right foot bottom height.
         */
        readonly rightFeetBottomHeight: number
        logWarnings: boolean
        /** Sets whether the Animator sends events of type AnimationEvent.
         */
        fireEvents: boolean
        /** Controls the behaviour of the Animator component when a GameObject is disabled.
         */
        keepAnimatorControllerStateOnDisable: boolean
    }
}
declare module "UnityEngine" {
    import { Enum } from "System";
    /** The AnimationState gives full control over animation blending.
     */
    class AnimationState extends TrackedReference {
        constructor()
        /** Adds a transform which should be animated. This allows you to reduce the number of animations you have to create.
         * @param mix The transform to animate.
         * @param recursive Whether to also animate all children of the specified transform.
         */
        AddMixingTransform(mix: Transform, recursive: boolean): void
        /** Adds a transform which should be animated. This allows you to reduce the number of animations you have to create.
         * @param mix The transform to animate.
         * @param recursive Whether to also animate all children of the specified transform.
         */
        AddMixingTransform(mix: Transform): void
        /** Removes a transform which should be animated.
         */
        RemoveMixingTransform(mix: Transform): void
        /** Enables / disables the animation.
         */
        enabled: boolean
        /** The weight of animation.
         */
        weight: number
        /** Wrapping mode of the animation.
         */
        wrapMode: WrapMode
        /** The current time of the animation.
         */
        time: number
        /** The normalized time of the animation.
         */
        normalizedTime: number
        /** The playback speed of the animation. 1 is normal playback speed.
         */
        speed: number
        /** The normalized playback speed.
         */
        normalizedSpeed: number
        /** The length of the animation clip in seconds.
         */
        readonly length: number
        layer: number
        /** The clip that is being played by this animation state.
         */
        readonly clip: AnimationClip
        /** The name of the animation.
         */
        name: string
        /** Which blend mode should be used?
         */
        blendMode: any
    }
}
declare module "UnityEngine" {
    import { Object as Object1 } from "System";
    class TrackedReference extends Object1 {
        Equals(o: Object1): boolean
        GetHashCode(): number
        static op_Inequality(x: TrackedReference, y: TrackedReference): boolean
        static op_Implicit(exists: TrackedReference): boolean
        // js_op_overloading: static ==(x: TrackedReference, y: TrackedReference): boolean
        protected constructor()
    }
}
declare module "System" {
    class Object {
        constructor()
        Equals(obj: Object): boolean
        GetHashCode(): number
        GetType(): any
        toString(): string
        static Equals(objA: Object, objB: Object): boolean
        static ReferenceEquals(objA: Object, objB: Object): boolean
    }
}
declare module "UnityEngine" {
    import { Enum } from "System";
    /** Determines how time is treated outside of the keyframed range of an AnimationClip or AnimationCurve.
     */
    enum WrapMode {
        /** Reads the default repeat mode set higher up.
         */
        Default = 0,
        Once = 1,
        Clamp = 1,
        /** When time reaches the end of the animation clip, time will continue at the beginning.
         */
        Loop = 2,
        /** When time reaches the end of the animation clip, time will ping pong back between beginning and end.
         */
        PingPong = 4,
        /** Plays back the animation. When it reaches the end, it will keep playing the last frame and never stop playing.
         */
        ClampForever = 8,
    }
}
declare module "System" {
    import * as jsb from "jsb";
    abstract class Enum extends ValueType {
        Equals(obj: Object): boolean
        GetHashCode(): number
        toString(format: string): string
        toString(): string
        CompareTo(target: Object): number
        HasFlag(flag: Enum): boolean
        GetTypeCode(): any
        static Parse(enumType: any, value: string, ignoreCase: boolean): Object
        static Parse(enumType: any, value: string): Object
        static GetUnderlyingType(enumType: any): any
        static GetValues(enumType: any): Array<any>
        static GetName(enumType: any, value: Object): string
        static GetNames(enumType: any): Array<string>
        static ToObject(enumType: any, value: Object): Object
        static ToObject(enumType: any, value: number): Object
        static ToObject(enumType: any, value: number): Object
        static ToObject(enumType: any, value: number): Object
        static ToObject(enumType: any, value: jsb.byte): Object
        static ToObject(enumType: any, value: number): Object
        static ToObject(enumType: any, value: number): Object
        static ToObject(enumType: any, value: number): Object
        static ToObject(enumType: any, value: number): Object
        static IsDefined(enumType: any, value: Object): boolean
        static Format(enumType: any, value: Object, format: string): string
    }
}
declare module "System" {
    abstract class ValueType extends Object {
        Equals(obj: Object): boolean
        GetHashCode(): number
        toString(): string
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1, Enum, Array } from "System";
    /** Class containing methods to ease debugging while developing a game.
     */
    class Debug extends Object1 {
        constructor()
        /** Draws a line between specified start and end points.
         * @param start Point in world space where the line should start.
         * @param end Point in world space where the line should end.
         * @param color Color of the line.
         * @param duration How long the line should be visible for.
         * @param depthTest Should the line be obscured by objects closer to the camera?
         */
        static DrawLine(start: Vector3, end: Vector3, color: Color, duration: number, depthTest: boolean): void
        /** Draws a line between specified start and end points.
         * @param start Point in world space where the line should start.
         * @param end Point in world space where the line should end.
         * @param color Color of the line.
         * @param duration How long the line should be visible for.
         * @param depthTest Should the line be obscured by objects closer to the camera?
         */
        static DrawLine(start: Vector3, end: Vector3, color: Color, duration: number): void
        /** Draws a line between specified start and end points.
         * @param start Point in world space where the line should start.
         * @param end Point in world space where the line should end.
         * @param color Color of the line.
         * @param duration How long the line should be visible for.
         * @param depthTest Should the line be obscured by objects closer to the camera?
         */
        static DrawLine(start: Vector3, end: Vector3, color: Color): void
        /** Draws a line between specified start and end points.
         * @param start Point in world space where the line should start.
         * @param end Point in world space where the line should end.
         * @param color Color of the line.
         * @param duration How long the line should be visible for.
         * @param depthTest Should the line be obscured by objects closer to the camera?
         */
        static DrawLine(start: Vector3, end: Vector3): void
        /** Draws a line from start to start + dir in world coordinates.
         * @param start Point in world space where the ray should start.
         * @param dir Direction and length of the ray.
         * @param color Color of the drawn line.
         * @param duration How long the line will be visible for (in seconds).
         * @param depthTest Should the line be obscured by other objects closer to the camera?
         */
        static DrawRay(start: Vector3, dir: Vector3, color: Color, duration: number, depthTest: boolean): void
        /** Draws a line from start to start + dir in world coordinates.
         * @param start Point in world space where the ray should start.
         * @param dir Direction and length of the ray.
         * @param color Color of the drawn line.
         * @param duration How long the line will be visible for (in seconds).
         * @param depthTest Should the line be obscured by other objects closer to the camera?
         */
        static DrawRay(start: Vector3, dir: Vector3, color: Color, duration: number): void
        /** Draws a line from start to start + dir in world coordinates.
         * @param start Point in world space where the ray should start.
         * @param dir Direction and length of the ray.
         * @param color Color of the drawn line.
         * @param duration How long the line will be visible for (in seconds).
         * @param depthTest Should the line be obscured by other objects closer to the camera?
         */
        static DrawRay(start: Vector3, dir: Vector3, color: Color): void
        /** Draws a line from start to start + dir in world coordinates.
         * @param start Point in world space where the ray should start.
         * @param dir Direction and length of the ray.
         * @param color Color of the drawn line.
         * @param duration How long the line will be visible for (in seconds).
         * @param depthTest Should the line be obscured by other objects closer to the camera?
         */
        static DrawRay(start: Vector3, dir: Vector3): void
        static Break(): void
        static DebugBreak(): void
        /** Logs a message to the Unity Console.
         * @param message String or object to be converted to string representation for display.
         * @param context Object to which the message applies.
         */
        static Log(message: Object1, context: Object): void
        /** Logs a message to the Unity Console.
         * @param message String or object to be converted to string representation for display.
         * @param context Object to which the message applies.
         */
        static Log(message: Object1): void
        /** Logs a formatted message to the Unity Console.
         * @param format A composite format string.
         * @param args Format arguments.
         * @param context Object to which the message applies.
         * @param logType Type of message e.g. warn or error etc.
         * @param logOptions Option flags to treat the log message special.
         */
        static LogFormat(logType: any, logOptions: any, context: Object, format: string, ...args: Object1[]): void
        /** Logs a formatted message to the Unity Console.
         * @param format A composite format string.
         * @param args Format arguments.
         * @param context Object to which the message applies.
         * @param logType Type of message e.g. warn or error etc.
         * @param logOptions Option flags to treat the log message special.
         */
        static LogFormat(context: Object, format: string, ...args: Object1[]): void
        /** Logs a formatted message to the Unity Console.
         * @param format A composite format string.
         * @param args Format arguments.
         * @param context Object to which the message applies.
         * @param logType Type of message e.g. warn or error etc.
         * @param logOptions Option flags to treat the log message special.
         */
        static LogFormat(format: string, ...args: Object1[]): void
        /** A variant of Debug.Log that logs an error message to the console.
         * @param message String or object to be converted to string representation for display.
         * @param context Object to which the message applies.
         */
        static LogError(message: Object1, context: Object): void
        /** A variant of Debug.Log that logs an error message to the console.
         * @param message String or object to be converted to string representation for display.
         * @param context Object to which the message applies.
         */
        static LogError(message: Object1): void
        /** Logs a formatted error message to the Unity console.
         * @param format A composite format string.
         * @param args Format arguments.
         * @param context Object to which the message applies.
         */
        static LogErrorFormat(context: Object, format: string, ...args: Object1[]): void
        /** Logs a formatted error message to the Unity console.
         * @param format A composite format string.
         * @param args Format arguments.
         * @param context Object to which the message applies.
         */
        static LogErrorFormat(format: string, ...args: Object1[]): void
        static ClearDeveloperConsole(): void
        /** A variant of Debug.Log that logs an error message to the console.
         * @param context Object to which the message applies.
         * @param exception Runtime Exception.
         */
        static LogException(exception: any, context: Object): void
        /** A variant of Debug.Log that logs an error message to the console.
         * @param context Object to which the message applies.
         * @param exception Runtime Exception.
         */
        static LogException(exception: any): void
        /** A variant of Debug.Log that logs a warning message to the console.
         * @param message String or object to be converted to string representation for display.
         * @param context Object to which the message applies.
         */
        static LogWarning(message: Object1, context: Object): void
        /** A variant of Debug.Log that logs a warning message to the console.
         * @param message String or object to be converted to string representation for display.
         * @param context Object to which the message applies.
         */
        static LogWarning(message: Object1): void
        /** Logs a formatted warning message to the Unity Console.
         * @param format A composite format string.
         * @param args Format arguments.
         * @param context Object to which the message applies.
         */
        static LogWarningFormat(context: Object, format: string, ...args: Object1[]): void
        /** Logs a formatted warning message to the Unity Console.
         * @param format A composite format string.
         * @param args Format arguments.
         * @param context Object to which the message applies.
         */
        static LogWarningFormat(format: string, ...args: Object1[]): void
        /** Assert a condition and logs an error message to the Unity console on failure.
         * @param condition Condition you expect to be true.
         * @param context Object to which the message applies.
         * @param message String or object to be converted to string representation for display.
         */
        static Assert(condition: boolean, message: Object1, context: Object): void
        static Assert(condition: boolean, message: string, context: Object): void
        /** Assert a condition and logs an error message to the Unity console on failure.
         * @param condition Condition you expect to be true.
         * @param context Object to which the message applies.
         * @param message String or object to be converted to string representation for display.
         */
        static Assert(condition: boolean, context: Object): void
        /** Assert a condition and logs an error message to the Unity console on failure.
         * @param condition Condition you expect to be true.
         * @param context Object to which the message applies.
         * @param message String or object to be converted to string representation for display.
         */
        static Assert(condition: boolean, message: Object1): void
        static Assert(condition: boolean, message: string): void
        /** Assert a condition and logs an error message to the Unity console on failure.
         * @param condition Condition you expect to be true.
         * @param context Object to which the message applies.
         * @param message String or object to be converted to string representation for display.
         */
        static Assert(condition: boolean): void
        /** Assert a condition and logs a formatted error message to the Unity console on failure.
         * @param condition Condition you expect to be true.
         * @param format A composite format string.
         * @param args Format arguments.
         * @param context Object to which the message applies.
         */
        static AssertFormat(condition: boolean, context: Object, format: string, ...args: Object1[]): void
        /** Assert a condition and logs a formatted error message to the Unity console on failure.
         * @param condition Condition you expect to be true.
         * @param format A composite format string.
         * @param args Format arguments.
         * @param context Object to which the message applies.
         */
        static AssertFormat(condition: boolean, format: string, ...args: Object1[]): void
        /** A variant of Debug.Log that logs an assertion message to the console.
         * @param message String or object to be converted to string representation for display.
         * @param context Object to which the message applies.
         */
        static LogAssertion(message: Object1, context: Object): void
        /** A variant of Debug.Log that logs an assertion message to the console.
         * @param message String or object to be converted to string representation for display.
         * @param context Object to which the message applies.
         */
        static LogAssertion(message: Object1): void
        /** Logs a formatted assertion message to the Unity console.
         * @param format A composite format string.
         * @param args Format arguments.
         * @param context Object to which the message applies.
         */
        static LogAssertionFormat(context: Object, format: string, ...args: Object1[]): void
        /** Logs a formatted assertion message to the Unity console.
         * @param format A composite format string.
         * @param args Format arguments.
         * @param context Object to which the message applies.
         */
        static LogAssertionFormat(format: string, ...args: Object1[]): void
        /** Get default debug logger.
         */
        static readonly unityLogger: any
        /** Reports whether the development console is visible. The development console cannot be made to appear using:
         */
        static developerConsoleVisible: boolean
        /** In the Build Settings dialog there is a check box called "Development Build".
         */
        static readonly isDebugBuild: boolean
    }
}
declare module "UnityEngine" {
    /** Suspends the coroutine execution for the given amount of seconds using scaled time.
     */
    class WaitForSeconds extends YieldInstruction {
        constructor(seconds: number)
    }
}
declare module "UnityEngine" {
    import { Object as Object1 } from "System";
    /** Base class for all yield instructions.
     */
    class YieldInstruction extends Object1 {
        constructor()
    }
}
declare module "UnityEngine" {
    /** Waits until the end of the frame after Unity has rendererd every Camera and GUI, just before displaying the frame on screen.
     */
    class WaitForEndOfFrame extends YieldInstruction {
        constructor()
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1, Enum, Array, ValueType } from "System";
    /** Interface into the Input system.
     */
    class Input extends Object1 {
        constructor()
        /** Returns the value of the virtual axis identified by axisName.
         */
        static GetAxis(axisName: string): number
        /** Returns the value of the virtual axis identified by axisName with no smoothing filtering applied.
         */
        static GetAxisRaw(axisName: string): number
        /** Returns true while the virtual button identified by buttonName is held down.
         * @param buttonName The name of the button such as Jump.
         * @returns True when an axis has been pressed and not released. 
         */
        static GetButton(buttonName: string): boolean
        /** Returns true during the frame the user pressed down the virtual button identified by buttonName.
         */
        static GetButtonDown(buttonName: string): boolean
        /** Returns true the first frame the user releases the virtual button identified by buttonName.
         */
        static GetButtonUp(buttonName: string): boolean
        /** Returns whether the given mouse button is held down.
         */
        static GetMouseButton(button: number): boolean
        /** Returns true during the frame the user pressed the given mouse button.
         */
        static GetMouseButtonDown(button: number): boolean
        /** Returns true during the frame the user releases the given mouse button.
         */
        static GetMouseButtonUp(button: number): boolean
        static ResetInputAxes(): void
        static GetJoystickNames(): Array<string>
        /** Call Input.GetTouch to obtain a Touch struct.
         * @param index The touch input on the device screen.
         * @returns Touch details in the struct. 
         */
        static GetTouch(index: number): any
        /** Returns specific acceleration measurement which occurred during last frame. (Does not allocate temporary variables).
         */
        static GetAccelerationEvent(index: number): any
        /** Returns true while the user holds down the key identified by the key KeyCode enum parameter.
         */
        static GetKey(key: KeyCode): boolean
        /** Returns true while the user holds down the key identified by name.
         */
        static GetKey(name: string): boolean
        /** Returns true during the frame the user releases the key identified by the key KeyCode enum parameter.
         */
        static GetKeyUp(key: KeyCode): boolean
        /** Returns true during the frame the user releases the key identified by name.
         */
        static GetKeyUp(name: string): boolean
        /** Returns true during the frame the user starts pressing down the key identified by the key KeyCode enum parameter.
         */
        static GetKeyDown(key: KeyCode): boolean
        /** Returns true during the frame the user starts pressing down the key identified by name.
         */
        static GetKeyDown(name: string): boolean
        /** Enables/Disables mouse simulation with touches. By default this option is enabled.
         */
        static simulateMouseWithTouches: boolean
        /** Is any key or mouse button currently held down? (Read Only)
         */
        static readonly anyKey: boolean
        /** Returns true the first frame the user hits any key or mouse button. (Read Only)
         */
        static readonly anyKeyDown: boolean
        /** Returns the keyboard input entered this frame. (Read Only)
         */
        static readonly inputString: string
        /** The current mouse position in pixel coordinates. (Read Only)
         */
        static readonly mousePosition: Vector3
        /** The current mouse scroll delta. (Read Only)
         */
        static readonly mouseScrollDelta: Vector2
        /** Controls enabling and disabling of IME input composition.
         */
        static imeCompositionMode: any
        /** The current IME composition string being typed by the user.
         */
        static readonly compositionString: string
        /** Does the user have an IME keyboard input source selected?
         */
        static readonly imeIsSelected: boolean
        /** The current text input position used by IMEs to open windows.
         */
        static compositionCursorPos: Vector2
        /** Indicates if a mouse device is detected.
         */
        static readonly mousePresent: boolean
        /** Number of touches. Guaranteed not to change throughout the frame. (Read Only)
         */
        static readonly touchCount: number
        /** Bool value which let's users check if touch pressure is supported.
         */
        static readonly touchPressureSupported: boolean
        /** Returns true when Stylus Touch is supported by a device or platform.
         */
        static readonly stylusTouchSupported: boolean
        /** Returns whether the device on which application is currently running supports touch input.
         */
        static readonly touchSupported: boolean
        /** Property indicating whether the system handles multiple touches.
         */
        static multiTouchEnabled: boolean
        /** Device physical orientation as reported by OS. (Read Only)
         */
        static readonly deviceOrientation: any
        /** Last measured linear acceleration of a device in three-dimensional space. (Read Only)
         */
        static readonly acceleration: Vector3
        /** This property controls if input sensors should be compensated for screen orientation.
         */
        static compensateSensors: boolean
        /** Number of acceleration measurements which occurred during last frame.
         */
        static readonly accelerationEventCount: number
        /** Should  Back button quit the application?

Only usable on Android, Windows Phone or Windows Tablets.
         */
        static backButtonLeavesApp: boolean
        /** Property for accessing device location (handheld devices only). (Read Only)
         */
        static readonly location: any
        /** Property for accessing compass (handheld devices only). (Read Only)
         */
        static readonly compass: any
        /** Returns default gyroscope.
         */
        static readonly gyro: any
        /** Returns list of objects representing status of all touches during last frame. (Read Only) (Allocates temporary variables).
         */
        static readonly touches: Array<any>
        /** Returns list of acceleration measurements which occurred during the last frame. (Read Only) (Allocates temporary variables).
         */
        static readonly accelerationEvents: Array<any>
    }
}
declare module "UnityEngine" {
    import { ValueType } from "System";
    /** Representation of rays.
     */
    class Ray extends ValueType {
        constructor(origin: Vector3, direction: Vector3)
        /** Returns a point at distance units along the ray.
         */
        GetPoint(distance: number): Vector3
        /** Returns a nicely formatted string for this ray.
         */
        toString(format: string): string
        toString(): string
        /** The origin point of the ray.
         */
        origin: Vector3
        /** The direction of the ray.
         */
        direction: Vector3
    }
}
declare module "UnityEngine" {
    import { ValueType } from "System";
    /** Structure used to get information back from a raycast.
     */
    class RaycastHit extends ValueType {
        constructor()
        /** The Collider that was hit.
         */
        readonly collider: Collider
        /** The impact point in world space where the ray hit the collider.
         */
        point: Vector3
        /** The normal of the surface the ray hit.
         */
        normal: Vector3
        /** The barycentric coordinate of the triangle we hit.
         */
        barycentricCoordinate: Vector3
        /** The distance from the ray's origin to the impact point.
         */
        distance: number
        /** The index of the triangle that was hit.
         */
        readonly triangleIndex: number
        /** The uv texture coordinate at the collision location.
         */
        readonly textureCoord: Vector2
        /** The secondary uv texture coordinate at the impact point.
         */
        readonly textureCoord2: Vector2
        /** The Transform of the rigidbody or collider that was hit.
         */
        readonly transform: Transform
        /** The Rigidbody of the collider that was hit. If the collider is not attached to a rigidbody then it is null.
         */
        readonly rigidbody: Rigidbody
        /** The uv lightmap coordinate at the impact point.
         */
        readonly lightmapCoord: Vector2
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1, ValueType, Array, Enum } from "System";
    /** Global physics properties and helper methods.
     */
    class Physics extends Object1 {
        constructor()
        /** Makes the collision detection system ignore all collisions between collider1 and collider2.
         * @param collider1 Any collider.
         * @param collider2 Another collider you want to have collider1 to start or stop ignoring collisions with.
         * @param ignore Whether or not the collisions between the two colliders should be ignored or not.
         */
        static IgnoreCollision(collider1: Collider, collider2: Collider, ignore: boolean): void
        static IgnoreCollision(collider1: Collider, collider2: Collider): void
        /** Makes the collision detection system ignore all collisions between any collider in layer1 and any collider in layer2.

Note that IgnoreLayerCollision will reset the trigger state of affected colliders, so you might receive OnTriggerExit and OnTriggerEnter messages in response to calling this.
         */
        static IgnoreLayerCollision(layer1: number, layer2: number, ignore: boolean): void
        static IgnoreLayerCollision(layer1: number, layer2: number): void
        /** Are collisions between layer1 and layer2 being ignored?
         */
        static GetIgnoreLayerCollision(layer1: number, layer2: number): boolean
        /** Checks whether the collision detection system will ignore all collisionstriggers between collider1 and collider2/ or not.
         * @param collider1 The first collider to compare to collider2.
         * @param collider2 The second collider to compare to collider1.
         * @returns Whether the collision detection system will ignore all collisionstriggers between collider1 and collider2/ or not. 
         */
        static GetIgnoreCollision(collider1: Collider, collider2: Collider): boolean
        /** Casts a ray against all colliders in the Scene and returns detailed information on what was hit.
         * @param origin The starting point of the ray in world coordinates.
         * @param direction The direction of the ray.
         * @param hitInfo If true is returned, hitInfo will contain more information about where the closest collider was hit. (See Also: RaycastHit).
         * @param maxDistance The max distance the ray should check for collisions.
         * @param layerMask A that is used to selectively ignore colliders when casting a ray.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns Returns true when the ray intersects any collider, otherwise false. 
         */
        static Raycast(origin: Vector3, direction: Vector3, hitInfo: jsb.Out<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: any): boolean
        /** Casts a ray, from point origin, in direction direction, of length maxDistance, against all colliders in the Scene.
         * @param origin The starting point of the ray in world coordinates.
         * @param direction The direction of the ray.
         * @param maxDistance The max distance the ray should check for collisions.
         * @param layerMask A that is used to selectively ignore Colliders when casting a ray.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns Returns true if the ray intersects with a Collider, otherwise false. 
         */
        static Raycast(origin: Vector3, direction: Vector3, maxDistance: number, layerMask: number, queryTriggerInteraction: any): boolean
        static Raycast(origin: Vector3, direction: Vector3, hitInfo: jsb.Out<RaycastHit>, maxDistance: number, layerMask: number): boolean
        /** Same as above using ray.origin and ray.direction instead of origin and direction.
         * @param ray The starting point and direction of the ray.
         * @param hitInfo If true is returned, hitInfo will contain more information about where the closest collider was hit. (See Also: RaycastHit).
         * @param maxDistance The max distance the ray should check for collisions.
         * @param layerMask A that is used to selectively ignore colliders when casting a ray.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns Returns true when the ray intersects any collider, otherwise false. 
         */
        static Raycast(ray: Ray, hitInfo: jsb.Out<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: any): boolean
        static Raycast(origin: Vector3, direction: Vector3, maxDistance: number, layerMask: number): boolean
        static Raycast(origin: Vector3, direction: Vector3, hitInfo: jsb.Out<RaycastHit>, maxDistance: number): boolean
        /** Same as above using ray.origin and ray.direction instead of origin and direction.
         * @param ray The starting point and direction of the ray.
         * @param maxDistance The max distance the ray should check for collisions.
         * @param layerMask A that is used to selectively ignore colliders when casting a ray.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns Returns true when the ray intersects any collider, otherwise false. 
         */
        static Raycast(ray: Ray, maxDistance: number, layerMask: number, queryTriggerInteraction: any): boolean
        static Raycast(ray: Ray, hitInfo: jsb.Out<RaycastHit>, maxDistance: number, layerMask: number): boolean
        static Raycast(origin: Vector3, direction: Vector3, maxDistance: number): boolean
        static Raycast(origin: Vector3, direction: Vector3, hitInfo: jsb.Out<RaycastHit>): boolean
        static Raycast(ray: Ray, maxDistance: number, layerMask: number): boolean
        static Raycast(ray: Ray, hitInfo: jsb.Out<RaycastHit>, maxDistance: number): boolean
        static Raycast(origin: Vector3, direction: Vector3): boolean
        static Raycast(ray: Ray, maxDistance: number): boolean
        static Raycast(ray: Ray, hitInfo: jsb.Out<RaycastHit>): boolean
        static Raycast(ray: Ray): boolean
        /** Returns true if there is any collider intersecting the line between start and end.
         * @param start Start point.
         * @param end End point.
         * @param layerMask A that is used to selectively ignore colliders when casting a ray.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @param hitInfo If true is returned, hitInfo will contain more information about where the collider was hit. (See Also: RaycastHit).
         */
        static Linecast(start: Vector3, end: Vector3, hitInfo: jsb.Out<RaycastHit>, layerMask: number, queryTriggerInteraction: any): boolean
        /** Returns true if there is any collider intersecting the line between start and end.
         * @param start Start point.
         * @param end End point.
         * @param layerMask A that is used to selectively ignore colliders when casting a ray.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         */
        static Linecast(start: Vector3, end: Vector3, layerMask: number, queryTriggerInteraction: any): boolean
        static Linecast(start: Vector3, end: Vector3, hitInfo: jsb.Out<RaycastHit>, layerMask: number): boolean
        static Linecast(start: Vector3, end: Vector3, layerMask: number): boolean
        static Linecast(start: Vector3, end: Vector3, hitInfo: jsb.Out<RaycastHit>): boolean
        static Linecast(start: Vector3, end: Vector3): boolean
        /**
         * @param point1 The center of the sphere at the start of the capsule.
         * @param point2 The center of the sphere at the end of the capsule.
         * @param radius The radius of the capsule.
         * @param direction The direction into which to sweep the capsule.
         * @param maxDistance The max length of the sweep.
         * @param hitInfo If true is returned, hitInfo will contain more information about where the collider was hit. (See Also: RaycastHit).
         * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         */
        static CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, hitInfo: jsb.Out<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: any): boolean
        /** Casts a capsule against all colliders in the Scene and returns detailed information on what was hit.
         * @param point1 The center of the sphere at the start of the capsule.
         * @param point2 The center of the sphere at the end of the capsule.
         * @param radius The radius of the capsule.
         * @param direction The direction into which to sweep the capsule.
         * @param maxDistance The max length of the sweep.
         * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns True when the capsule sweep intersects any collider, otherwise false. 
         */
        static CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, maxDistance: number, layerMask: number, queryTriggerInteraction: any): boolean
        static CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, hitInfo: jsb.Out<RaycastHit>, maxDistance: number, layerMask: number): boolean
        static CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, maxDistance: number, layerMask: number): boolean
        static CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, hitInfo: jsb.Out<RaycastHit>, maxDistance: number): boolean
        static CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, maxDistance: number): boolean
        static CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, hitInfo: jsb.Out<RaycastHit>): boolean
        static CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3): boolean
        /** Casts a sphere along a ray and returns detailed information on what was hit.
         * @param origin The center of the sphere at the start of the sweep.
         * @param radius The radius of the sphere.
         * @param direction The direction into which to sweep the sphere.
         * @param hitInfo If true is returned, hitInfo will contain more information about where the collider was hit. (See Also: RaycastHit).
         * @param maxDistance The max length of the cast.
         * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns True when the sphere sweep intersects any collider, otherwise false. 
         */
        static SphereCast(origin: Vector3, radius: number, direction: Vector3, hitInfo: jsb.Out<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: any): boolean
        static SphereCast(origin: Vector3, radius: number, direction: Vector3, hitInfo: jsb.Out<RaycastHit>, maxDistance: number, layerMask: number): boolean
        /**
         * @param ray The starting point and direction of the ray into which the sphere sweep is cast.
         * @param radius The radius of the sphere.
         * @param hitInfo If true is returned, hitInfo will contain more information about where the collider was hit. (See Also: RaycastHit).
         * @param maxDistance The max length of the cast.
         * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         */
        static SphereCast(ray: Ray, radius: number, hitInfo: jsb.Out<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: any): boolean
        static SphereCast(origin: Vector3, radius: number, direction: Vector3, hitInfo: jsb.Out<RaycastHit>, maxDistance: number): boolean
        /** Casts a sphere along a ray and returns detailed information on what was hit.
         * @param ray The starting point and direction of the ray into which the sphere sweep is cast.
         * @param radius The radius of the sphere.
         * @param maxDistance The max length of the cast.
         * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns True when the sphere sweep intersects any collider, otherwise false. 
         */
        static SphereCast(ray: Ray, radius: number, maxDistance: number, layerMask: number, queryTriggerInteraction: any): boolean
        static SphereCast(ray: Ray, radius: number, hitInfo: jsb.Out<RaycastHit>, maxDistance: number, layerMask: number): boolean
        static SphereCast(origin: Vector3, radius: number, direction: Vector3, hitInfo: jsb.Out<RaycastHit>): boolean
        static SphereCast(ray: Ray, radius: number, maxDistance: number, layerMask: number): boolean
        static SphereCast(ray: Ray, radius: number, hitInfo: jsb.Out<RaycastHit>, maxDistance: number): boolean
        static SphereCast(ray: Ray, radius: number, maxDistance: number): boolean
        static SphereCast(ray: Ray, radius: number, hitInfo: jsb.Out<RaycastHit>): boolean
        static SphereCast(ray: Ray, radius: number): boolean
        /** Casts the box along a ray and returns detailed information on what was hit.
         * @param center Center of the box.
         * @param halfExtents Half the size of the box in each dimension.
         * @param direction The direction in which to cast the box.
         * @param hitInfo If true is returned, hitInfo will contain more information about where the collider was hit. (See Also: RaycastHit).
         * @param orientation Rotation of the box.
         * @param maxDistance The max length of the cast.
         * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns True, if any intersections were found. 
         */
        static BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, hitInfo: jsb.Out<RaycastHit>, orientation: Quaternion, maxDistance: number, layerMask: number, queryTriggerInteraction: any): boolean
        /** Casts the box along a ray and returns detailed information on what was hit.
         * @param center Center of the box.
         * @param halfExtents Half the size of the box in each dimension.
         * @param direction The direction in which to cast the box.
         * @param orientation Rotation of the box.
         * @param maxDistance The max length of the cast.
         * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns True, if any intersections were found. 
         */
        static BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion, maxDistance: number, layerMask: number, queryTriggerInteraction: any): boolean
        static BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, hitInfo: jsb.Out<RaycastHit>, orientation: Quaternion, maxDistance: number, layerMask: number): boolean
        static BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion, maxDistance: number, layerMask: number): boolean
        static BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, hitInfo: jsb.Out<RaycastHit>, orientation: Quaternion, maxDistance: number): boolean
        static BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion, maxDistance: number): boolean
        static BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, hitInfo: jsb.Out<RaycastHit>, orientation: Quaternion): boolean
        static BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion): boolean
        static BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, hitInfo: jsb.Out<RaycastHit>): boolean
        static BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3): boolean
        /** See Also: Raycast.
         * @param origin The starting point of the ray in world coordinates.
         * @param direction The direction of the ray.
         * @param maxDistance The max distance the rayhit is allowed to be from the start of the ray.
         * @param layermask A that is used to selectively ignore colliders when casting a ray.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         */
        static RaycastAll(origin: Vector3, direction: Vector3, maxDistance: number, layerMask: number, queryTriggerInteraction: any): Array<RaycastHit>
        static RaycastAll(origin: Vector3, direction: Vector3, maxDistance: number, layerMask: number): Array<RaycastHit>
        /** Casts a ray through the Scene and returns all hits. Note that order of the results is undefined.
         * @param ray The starting point and direction of the ray.
         * @param maxDistance The max distance the rayhit is allowed to be from the start of the ray.
         * @param layerMask A that is used to selectively ignore colliders when casting a ray.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns An array of RaycastHit objects. Note that the order of the results is undefined. 
         */
        static RaycastAll(ray: Ray, maxDistance: number, layerMask: number, queryTriggerInteraction: any): Array<RaycastHit>
        static RaycastAll(origin: Vector3, direction: Vector3, maxDistance: number): Array<RaycastHit>
        static RaycastAll(ray: Ray, maxDistance: number, layerMask: number): Array<RaycastHit>
        static RaycastAll(origin: Vector3, direction: Vector3): Array<RaycastHit>
        static RaycastAll(ray: Ray, maxDistance: number): Array<RaycastHit>
        static RaycastAll(ray: Ray): Array<RaycastHit>
        /** Cast a ray through the Scene and store the hits into the buffer.
         * @param origin The starting point and direction of the ray.
         * @param results The buffer to store the hits into.
         * @param direction The direction of the ray.
         * @param maxDistance The max distance the rayhit is allowed to be from the start of the ray.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @param layerMask A that is used to selectively ignore colliders when casting a ray.
         * @returns The amount of hits stored into the results buffer. 
         */
        static RaycastNonAlloc(origin: Vector3, direction: Vector3, results: Array<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: any): number
        /** Cast a ray through the Scene and store the hits into the buffer.
         * @param ray The starting point and direction of the ray.
         * @param results The buffer to store the hits into.
         * @param maxDistance The max distance the rayhit is allowed to be from the start of the ray.
         * @param layerMask A that is used to selectively ignore colliders when casting a ray.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns The amount of hits stored into the results buffer. 
         */
        static RaycastNonAlloc(ray: Ray, results: Array<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: any): number
        static RaycastNonAlloc(origin: Vector3, direction: Vector3, results: Array<RaycastHit>, maxDistance: number, layerMask: number): number
        static RaycastNonAlloc(ray: Ray, results: Array<RaycastHit>, maxDistance: number, layerMask: number): number
        static RaycastNonAlloc(origin: Vector3, direction: Vector3, results: Array<RaycastHit>, maxDistance: number): number
        static RaycastNonAlloc(ray: Ray, results: Array<RaycastHit>, maxDistance: number): number
        static RaycastNonAlloc(origin: Vector3, direction: Vector3, results: Array<RaycastHit>): number
        static RaycastNonAlloc(ray: Ray, results: Array<RaycastHit>): number
        /** Like Physics.CapsuleCast, but this function will return all hits the capsule sweep intersects.
         * @param point1 The center of the sphere at the start of the capsule.
         * @param point2 The center of the sphere at the end of the capsule.
         * @param radius The radius of the capsule.
         * @param direction The direction into which to sweep the capsule.
         * @param maxDistance The max length of the sweep.
         * @param layermask A that is used to selectively ignore colliders when casting a capsule.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns An array of all colliders hit in the sweep. 
         */
        static CapsuleCastAll(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, maxDistance: number, layerMask: number, queryTriggerInteraction: any): Array<RaycastHit>
        static CapsuleCastAll(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, maxDistance: number, layerMask: number): Array<RaycastHit>
        static CapsuleCastAll(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, maxDistance: number): Array<RaycastHit>
        static CapsuleCastAll(point1: Vector3, point2: Vector3, radius: number, direction: Vector3): Array<RaycastHit>
        /** Like Physics.SphereCast, but this function will return all hits the sphere sweep intersects.
         * @param origin The center of the sphere at the start of the sweep.
         * @param radius The radius of the sphere.
         * @param direction The direction in which to sweep the sphere.
         * @param maxDistance The max length of the sweep.
         * @param layerMask A that is used to selectively ignore colliders when casting a sphere.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns An array of all colliders hit in the sweep. 
         */
        static SphereCastAll(origin: Vector3, radius: number, direction: Vector3, maxDistance: number, layerMask: number, queryTriggerInteraction: any): Array<RaycastHit>
        static SphereCastAll(origin: Vector3, radius: number, direction: Vector3, maxDistance: number, layerMask: number): Array<RaycastHit>
        /** Like Physics.SphereCast, but this function will return all hits the sphere sweep intersects.
         * @param ray The starting point and direction of the ray into which the sphere sweep is cast.
         * @param radius The radius of the sphere.
         * @param maxDistance The max length of the sweep.
         * @param layerMask A that is used to selectively ignore colliders when casting a sphere.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         */
        static SphereCastAll(ray: Ray, radius: number, maxDistance: number, layerMask: number, queryTriggerInteraction: any): Array<RaycastHit>
        static SphereCastAll(origin: Vector3, radius: number, direction: Vector3, maxDistance: number): Array<RaycastHit>
        static SphereCastAll(ray: Ray, radius: number, maxDistance: number, layerMask: number): Array<RaycastHit>
        static SphereCastAll(origin: Vector3, radius: number, direction: Vector3): Array<RaycastHit>
        static SphereCastAll(ray: Ray, radius: number, maxDistance: number): Array<RaycastHit>
        static SphereCastAll(ray: Ray, radius: number): Array<RaycastHit>
        /** Check the given capsule against the physics world and return all overlapping colliders.
         * @param point0 The center of the sphere at the start of the capsule.
         * @param point1 The center of the sphere at the end of the capsule.
         * @param radius The radius of the capsule.
         * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns Colliders touching or inside the capsule. 
         */
        static OverlapCapsule(point0: Vector3, point1: Vector3, radius: number, layerMask: number, queryTriggerInteraction: any): Array<Collider>
        static OverlapCapsule(point0: Vector3, point1: Vector3, radius: number, layerMask: number): Array<Collider>
        static OverlapCapsule(point0: Vector3, point1: Vector3, radius: number): Array<Collider>
        /** Computes and stores colliders touching or inside the sphere.
         * @param position Center of the sphere.
         * @param radius Radius of the sphere.
         * @param layerMask A defines which layers of colliders to include in the query.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns Returns an array with all colliders touching or inside the sphere. 
         */
        static OverlapSphere(position: Vector3, radius: number, layerMask: number, queryTriggerInteraction: any): Array<Collider>
        static OverlapSphere(position: Vector3, radius: number, layerMask: number): Array<Collider>
        static OverlapSphere(position: Vector3, radius: number): Array<Collider>
        /** Simulate physics in the Scene.
         * @param step The time to advance physics by.
         */
        static Simulate(step: number): void
        static SyncTransforms(): void
        /** Compute the minimal translation required to separate the given colliders apart at specified poses.
         * @param colliderA The first collider.
         * @param positionA Position of the first collider.
         * @param rotationA Rotation of the first collider.
         * @param colliderB The second collider.
         * @param positionB Position of the second collider.
         * @param rotationB Rotation of the second collider.
         * @param direction Direction along which the translation required to separate the colliders apart is minimal.
         * @param distance The distance along direction that is required to separate the colliders apart.
         * @returns True, if the colliders overlap at the given poses. 
         */
        static ComputePenetration(colliderA: Collider, positionA: Vector3, rotationA: Quaternion, colliderB: Collider, positionB: Vector3, rotationB: Quaternion, direction: jsb.Out<Vector3>, distance: jsb.Out<number>): boolean
        /** Returns a point on the given collider that is closest to the specified location.
         * @param point Location you want to find the closest point to.
         * @param collider The collider that you find the closest point on.
         * @param position The position of the collider.
         * @param rotation The rotation of the collider.
         * @returns The point on the collider that is closest to the specified location. 
         */
        static ClosestPoint(point: Vector3, collider: Collider, position: Vector3, rotation: Quaternion): Vector3
        /** Computes and stores colliders touching or inside the sphere into the provided buffer.
         * @param position Center of the sphere.
         * @param radius Radius of the sphere.
         * @param results The buffer to store the results into.
         * @param layerMask A defines which layers of colliders to include in the query.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns Returns the amount of colliders stored into the results buffer. 
         */
        static OverlapSphereNonAlloc(position: Vector3, radius: number, results: Array<Collider>, layerMask: number, queryTriggerInteraction: any): number
        static OverlapSphereNonAlloc(position: Vector3, radius: number, results: Array<Collider>, layerMask: number): number
        static OverlapSphereNonAlloc(position: Vector3, radius: number, results: Array<Collider>): number
        /** Returns true if there are any colliders overlapping the sphere defined by position and radius in world coordinates.
         * @param position Center of the sphere.
         * @param radius Radius of the sphere.
         * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         */
        static CheckSphere(position: Vector3, radius: number, layerMask: number, queryTriggerInteraction: any): boolean
        static CheckSphere(position: Vector3, radius: number, layerMask: number): boolean
        static CheckSphere(position: Vector3, radius: number): boolean
        /** Casts a capsule against all colliders in the Scene and returns detailed information on what was hit into the buffer.
         * @param point1 The center of the sphere at the start of the capsule.
         * @param point2 The center of the sphere at the end of the capsule.
         * @param radius The radius of the capsule.
         * @param direction The direction into which to sweep the capsule.
         * @param results The buffer to store the hits into.
         * @param maxDistance The max length of the sweep.
         * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns The amount of hits stored into the buffer. 
         */
        static CapsuleCastNonAlloc(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, results: Array<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: any): number
        static CapsuleCastNonAlloc(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, results: Array<RaycastHit>, maxDistance: number, layerMask: number): number
        static CapsuleCastNonAlloc(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, results: Array<RaycastHit>, maxDistance: number): number
        static CapsuleCastNonAlloc(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, results: Array<RaycastHit>): number
        /** Cast sphere along the direction and store the results into buffer.
         * @param origin The center of the sphere at the start of the sweep.
         * @param radius The radius of the sphere.
         * @param direction The direction in which to sweep the sphere.
         * @param results The buffer to save the hits into.
         * @param maxDistance The max length of the sweep.
         * @param layerMask A that is used to selectively ignore colliders when casting a sphere.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns The amount of hits stored into the results buffer. 
         */
        static SphereCastNonAlloc(origin: Vector3, radius: number, direction: Vector3, results: Array<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: any): number
        static SphereCastNonAlloc(origin: Vector3, radius: number, direction: Vector3, results: Array<RaycastHit>, maxDistance: number, layerMask: number): number
        /** Cast sphere along the direction and store the results into buffer.
         * @param ray The starting point and direction of the ray into which the sphere sweep is cast.
         * @param radius The radius of the sphere.
         * @param results The buffer to save the results to.
         * @param maxDistance The max length of the sweep.
         * @param layerMask A that is used to selectively ignore colliders when casting a sphere.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns The amount of hits stored into the results buffer. 
         */
        static SphereCastNonAlloc(ray: Ray, radius: number, results: Array<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: any): number
        static SphereCastNonAlloc(origin: Vector3, radius: number, direction: Vector3, results: Array<RaycastHit>, maxDistance: number): number
        static SphereCastNonAlloc(ray: Ray, radius: number, results: Array<RaycastHit>, maxDistance: number, layerMask: number): number
        static SphereCastNonAlloc(origin: Vector3, radius: number, direction: Vector3, results: Array<RaycastHit>): number
        static SphereCastNonAlloc(ray: Ray, radius: number, results: Array<RaycastHit>, maxDistance: number): number
        static SphereCastNonAlloc(ray: Ray, radius: number, results: Array<RaycastHit>): number
        /** Checks if any colliders overlap a capsule-shaped volume in world space.
         * @param start The center of the sphere at the start of the capsule.
         * @param end The center of the sphere at the end of the capsule.
         * @param radius The radius of the capsule.
         * @param layermask A that is used to selectively ignore colliders when casting a capsule.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         */
        static CheckCapsule(start: Vector3, end: Vector3, radius: number, layerMask: number, queryTriggerInteraction: any): boolean
        static CheckCapsule(start: Vector3, end: Vector3, radius: number, layerMask: number): boolean
        static CheckCapsule(start: Vector3, end: Vector3, radius: number): boolean
        /** Check whether the given box overlaps with other colliders or not.
         * @param center Center of the box.
         * @param halfExtents Half the size of the box in each dimension.
         * @param orientation Rotation of the box.
         * @param layermask A that is used to selectively ignore colliders when casting a ray.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns True, if the box overlaps with any colliders. 
         */
        static CheckBox(center: Vector3, halfExtents: Vector3, orientation: Quaternion, layermask: number, queryTriggerInteraction: any): boolean
        static CheckBox(center: Vector3, halfExtents: Vector3, orientation: Quaternion, layerMask: number): boolean
        static CheckBox(center: Vector3, halfExtents: Vector3, orientation: Quaternion): boolean
        static CheckBox(center: Vector3, halfExtents: Vector3): boolean
        /** Find all colliders touching or inside of the given box.
         * @param center Center of the box.
         * @param halfExtents Half of the size of the box in each dimension.
         * @param orientation Rotation of the box.
         * @param layerMask A that is used to selectively ignore colliders when casting a ray.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns Colliders that overlap with the given box. 
         */
        static OverlapBox(center: Vector3, halfExtents: Vector3, orientation: Quaternion, layerMask: number, queryTriggerInteraction: any): Array<Collider>
        static OverlapBox(center: Vector3, halfExtents: Vector3, orientation: Quaternion, layerMask: number): Array<Collider>
        static OverlapBox(center: Vector3, halfExtents: Vector3, orientation: Quaternion): Array<Collider>
        static OverlapBox(center: Vector3, halfExtents: Vector3): Array<Collider>
        /** Find all colliders touching or inside of the given box, and store them into the buffer.
         * @param center Center of the box.
         * @param halfExtents Half of the size of the box in each dimension.
         * @param results The buffer to store the results in.
         * @param orientation Rotation of the box.
         * @param layerMask A that is used to selectively ignore colliders when casting a ray.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns The amount of colliders stored in results. 
         */
        static OverlapBoxNonAlloc(center: Vector3, halfExtents: Vector3, results: Array<Collider>, orientation: Quaternion, mask: number, queryTriggerInteraction: any): number
        static OverlapBoxNonAlloc(center: Vector3, halfExtents: Vector3, results: Array<Collider>, orientation: Quaternion, mask: number): number
        static OverlapBoxNonAlloc(center: Vector3, halfExtents: Vector3, results: Array<Collider>, orientation: Quaternion): number
        static OverlapBoxNonAlloc(center: Vector3, halfExtents: Vector3, results: Array<Collider>): number
        /** Cast the box along the direction, and store hits in the provided buffer.
         * @param center Center of the box.
         * @param halfExtents Half the size of the box in each dimension.
         * @param direction The direction in which to cast the box.
         * @param results The buffer to store the results in.
         * @param orientation Rotation of the box.
         * @param maxDistance The max length of the cast.
         * @param layermask A that is used to selectively ignore colliders when casting a capsule.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns The amount of hits stored to the results buffer. 
         */
        static BoxCastNonAlloc(center: Vector3, halfExtents: Vector3, direction: Vector3, results: Array<RaycastHit>, orientation: Quaternion, maxDistance: number, layerMask: number, queryTriggerInteraction: any): number
        static BoxCastNonAlloc(center: Vector3, halfExtents: Vector3, direction: Vector3, results: Array<RaycastHit>, orientation: Quaternion, maxDistance: number, layerMask: number): number
        static BoxCastNonAlloc(center: Vector3, halfExtents: Vector3, direction: Vector3, results: Array<RaycastHit>, orientation: Quaternion, maxDistance: number): number
        static BoxCastNonAlloc(center: Vector3, halfExtents: Vector3, direction: Vector3, results: Array<RaycastHit>, orientation: Quaternion): number
        static BoxCastNonAlloc(center: Vector3, halfExtents: Vector3, direction: Vector3, results: Array<RaycastHit>): number
        /** Like Physics.BoxCast, but returns all hits.
         * @param center Center of the box.
         * @param halfExtents Half the size of the box in each dimension.
         * @param direction The direction in which to cast the box.
         * @param orientation Rotation of the box.
         * @param maxDistance The max length of the cast.
         * @param layermask A that is used to selectively ignore colliders when casting a capsule.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns All colliders that were hit. 
         */
        static BoxCastAll(center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion, maxDistance: number, layerMask: number, queryTriggerInteraction: any): Array<RaycastHit>
        static BoxCastAll(center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion, maxDistance: number, layerMask: number): Array<RaycastHit>
        static BoxCastAll(center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion, maxDistance: number): Array<RaycastHit>
        static BoxCastAll(center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion): Array<RaycastHit>
        static BoxCastAll(center: Vector3, halfExtents: Vector3, direction: Vector3): Array<RaycastHit>
        /** Check the given capsule against the physics world and return all overlapping colliders in the user-provided buffer.
         * @param point0 The center of the sphere at the start of the capsule.
         * @param point1 The center of the sphere at the end of the capsule.
         * @param radius The radius of the capsule.
         * @param results The buffer to store the results into.
         * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns The amount of entries written to the buffer. 
         */
        static OverlapCapsuleNonAlloc(point0: Vector3, point1: Vector3, radius: number, results: Array<Collider>, layerMask: number, queryTriggerInteraction: any): number
        static OverlapCapsuleNonAlloc(point0: Vector3, point1: Vector3, radius: number, results: Array<Collider>, layerMask: number): number
        static OverlapCapsuleNonAlloc(point0: Vector3, point1: Vector3, radius: number, results: Array<Collider>): number
        /** Rebuild the broadphase interest regions as well as set the world boundaries.
         * @param worldBounds Boundaries of the physics world.
         * @param subdivisions How many cells to create along x and z axis.
         */
        static RebuildBroadphaseRegions(worldBounds: Bounds, subdivisions: number): void
        /** Prepares the Mesh for use with a MeshCollider.
         * @param meshID The instance ID of the Mesh to bake collision data from.
         * @param convex A flag to indicate whether to bake convex geometry or not.
         */
        static BakeMesh(meshID: number, convex: boolean): void
        /** The gravity applied to all rigid bodies in the Scene.
         */
        static gravity: Vector3
        /** The default contact offset of the newly created colliders.
         */
        static defaultContactOffset: number
        /** The mass-normalized energy threshold, below which objects start going to sleep.
         */
        static sleepThreshold: number
        /** Specifies whether queries (raycasts, spherecasts, overlap tests, etc.) hit Triggers by default.
         */
        static queriesHitTriggers: boolean
        /** Whether physics queries should hit back-face triangles.
         */
        static queriesHitBackfaces: boolean
        /** Two colliding objects with a relative velocity below this will not bounce (default 2). Must be positive.
         */
        static bounceThreshold: number
        /** The defaultSolverIterations determines how accurately Rigidbody joints and collision contacts are resolved. (default 6). Must be positive.
         */
        static defaultSolverIterations: number
        /** The defaultSolverVelocityIterations affects how accurately the Rigidbody joints and collision contacts are resolved. (default 1). Must be positive.
         */
        static defaultSolverVelocityIterations: number
        /** Default maximum angular speed of the dynamic Rigidbody, in radians (default 50).
         */
        static defaultMaxAngularSpeed: number
        /** The PhysicsScene automatically created when Unity starts.
         */
        static readonly defaultPhysicsScene: any
        /** Sets whether the physics should be simulated automatically or not.
         */
        static autoSimulation: boolean
        /** Whether or not to automatically sync transform changes with the physics system whenever a Transform component changes.
         */
        static autoSyncTransforms: boolean
        /** Determines whether the garbage collector should reuse only a single instance of a Collision type for all collision callbacks.
         */
        static reuseCollisionCallbacks: boolean
        /** Sets the minimum separation distance for cloth inter-collision.
         */
        static interCollisionDistance: number
        /** Sets the cloth inter-collision stiffness.
         */
        static interCollisionStiffness: number
        static interCollisionSettingsToggle: boolean
        /** Cloth Gravity setting.
Set gravity for all cloth components.
         */
        static clothGravity: Vector3
        /** Layer mask constant to select ignore raycast layer.
         */
        static readonly IgnoreRaycastLayer: number
        /** Layer mask constant to select default raycast layers.
         */
        static readonly DefaultRaycastLayers: number
        /** Layer mask constant to select all layers.
         */
        static readonly AllLayers: number
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Array } from "System";
    /** A base class of all colliders.
     */
    class Collider extends Component {
        constructor()
        /** Returns a point on the collider that is closest to a given location.
         * @param position Location you want to find the closest point to.
         * @returns The point on the collider that is closest to the specified location. 
         */
        ClosestPoint(position: Vector3): Vector3
        /** Casts a Ray that ignores all Colliders except this one.
         * @param ray The starting point and direction of the ray.
         * @param hitInfo If true is returned, hitInfo will contain more information about where the collider was hit.
         * @param maxDistance The max length of the ray.
         * @returns True when the ray intersects the collider, otherwise false. 
         */
        Raycast(ray: Ray, hitInfo: jsb.Out<RaycastHit>, maxDistance: number): boolean
        /** The closest point to the bounding box of the attached collider.
         */
        ClosestPointOnBounds(position: Vector3): Vector3
        /** Enabled Colliders will collide with other Colliders, disabled Colliders won't.
         */
        enabled: boolean
        /** The rigidbody the collider is attached to.
         */
        readonly attachedRigidbody: Rigidbody
        /** Is the collider a trigger?
         */
        isTrigger: boolean
        /** Contact offset value of this collider.
         */
        contactOffset: number
        /** The world space bounding volume of the collider (Read Only).
         */
        readonly bounds: Bounds
        /** The shared physic material of this collider.
         */
        sharedMaterial: any
        /** The material used by the collider.
         */
        material: any
    }
}
declare module "UnityEngine" {
    /** A box-shaped primitive collider.
     */
    class BoxCollider extends Collider {
        constructor()
        /** The center of the box, measured in the object's local space.
         */
        center: Vector3
        /** The size of the box, measured in the object's local space.
         */
        size: Vector3
    }
}
declare module "UnityEngine" {
    /** A sphere-shaped primitive collider.
     */
    class SphereCollider extends Collider {
        constructor()
        /** The center of the sphere in the object's local space.
         */
        center: Vector3
        /** The radius of the sphere measured in the object's local space.
         */
        radius: number
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Enum, Array } from "System";
    /** Control of an object's position through physics simulation.
     */
    class Rigidbody extends Component {
        constructor()
        /** Sets the mass based on the attached colliders assuming a constant density.
         */
        SetDensity(density: number): void
        /** Moves the kinematic Rigidbody towards position.
         * @param position Provides the new position for the Rigidbody object.
         */
        MovePosition(position: Vector3): void
        /** Rotates the rigidbody to rotation.
         * @param rot The new rotation for the Rigidbody.
         */
        MoveRotation(rot: Quaternion): void
        Sleep(): void
        IsSleeping(): boolean
        WakeUp(): void
        ResetCenterOfMass(): void
        ResetInertiaTensor(): void
        /** The velocity relative to the rigidbody at the point relativePoint.
         */
        GetRelativePointVelocity(relativePoint: Vector3): Vector3
        /** The velocity of the rigidbody at the point worldPoint in global space.
         */
        GetPointVelocity(worldPoint: Vector3): Vector3
        /** Adds a force to the Rigidbody.
         * @param x Size of force along the world x-axis.
         * @param y Size of force along the world y-axis.
         * @param z Size of force along the world z-axis.
         * @param mode Type of force to apply.
         */
        AddForce(x: number, y: number, z: number, mode: any): void
        /** Adds a force to the Rigidbody.
         * @param x Size of force along the world x-axis.
         * @param y Size of force along the world y-axis.
         * @param z Size of force along the world z-axis.
         * @param mode Type of force to apply.
         */
        AddForce(x: number, y: number, z: number): void
        /** Adds a force to the Rigidbody.
         * @param force Force vector in world coordinates.
         * @param mode Type of force to apply.
         */
        AddForce(force: Vector3, mode: any): void
        /** Adds a force to the Rigidbody.
         * @param force Force vector in world coordinates.
         * @param mode Type of force to apply.
         */
        AddForce(force: Vector3): void
        /** Adds a force to the rigidbody relative to its coordinate system.
         * @param x Size of force along the local x-axis.
         * @param y Size of force along the local y-axis.
         * @param z Size of force along the local z-axis.
         */
        AddRelativeForce(x: number, y: number, z: number, mode: any): void
        /** Adds a force to the rigidbody relative to its coordinate system.
         * @param x Size of force along the local x-axis.
         * @param y Size of force along the local y-axis.
         * @param z Size of force along the local z-axis.
         */
        AddRelativeForce(x: number, y: number, z: number): void
        /** Adds a force to the rigidbody relative to its coordinate system.
         * @param force Force vector in local coordinates.
         */
        AddRelativeForce(force: Vector3, mode: any): void
        /** Adds a force to the rigidbody relative to its coordinate system.
         * @param force Force vector in local coordinates.
         */
        AddRelativeForce(force: Vector3): void
        /** Adds a torque to the rigidbody.
         * @param x Size of torque along the world x-axis.
         * @param y Size of torque along the world y-axis.
         * @param z Size of torque along the world z-axis.
         */
        AddTorque(x: number, y: number, z: number, mode: any): void
        /** Adds a torque to the rigidbody.
         * @param x Size of torque along the world x-axis.
         * @param y Size of torque along the world y-axis.
         * @param z Size of torque along the world z-axis.
         */
        AddTorque(x: number, y: number, z: number): void
        /** Adds a torque to the rigidbody.
         * @param torque Torque vector in world coordinates.
         */
        AddTorque(torque: Vector3, mode: any): void
        /** Adds a torque to the rigidbody.
         * @param torque Torque vector in world coordinates.
         */
        AddTorque(torque: Vector3): void
        /** Adds a torque to the rigidbody relative to its coordinate system.
         * @param x Size of torque along the local x-axis.
         * @param y Size of torque along the local y-axis.
         * @param z Size of torque along the local z-axis.
         */
        AddRelativeTorque(x: number, y: number, z: number, mode: any): void
        /** Adds a torque to the rigidbody relative to its coordinate system.
         * @param x Size of torque along the local x-axis.
         * @param y Size of torque along the local y-axis.
         * @param z Size of torque along the local z-axis.
         */
        AddRelativeTorque(x: number, y: number, z: number): void
        /** Adds a torque to the rigidbody relative to its coordinate system.
         * @param torque Torque vector in local coordinates.
         */
        AddRelativeTorque(torque: Vector3, mode: any): void
        /** Adds a torque to the rigidbody relative to its coordinate system.
         * @param torque Torque vector in local coordinates.
         */
        AddRelativeTorque(torque: Vector3): void
        /** Applies force at position. As a result this will apply a torque and force on the object.
         * @param force Force vector in world coordinates.
         * @param position Position in world coordinates.
         */
        AddForceAtPosition(force: Vector3, position: Vector3, mode: any): void
        /** Applies force at position. As a result this will apply a torque and force on the object.
         * @param force Force vector in world coordinates.
         * @param position Position in world coordinates.
         */
        AddForceAtPosition(force: Vector3, position: Vector3): void
        /** Applies a force to a rigidbody that simulates explosion effects.
         * @param explosionForce The force of the explosion (which may be modified by distance).
         * @param explosionPosition The centre of the sphere within which the explosion has its effect.
         * @param explosionRadius The radius of the sphere within which the explosion has its effect.
         * @param upwardsModifier Adjustment to the apparent position of the explosion to make it seem to lift objects.
         * @param mode The method used to apply the force to its targets.
         */
        AddExplosionForce(explosionForce: number, explosionPosition: Vector3, explosionRadius: number, upwardsModifier: number, mode: any): void
        /** Applies a force to a rigidbody that simulates explosion effects.
         * @param explosionForce The force of the explosion (which may be modified by distance).
         * @param explosionPosition The centre of the sphere within which the explosion has its effect.
         * @param explosionRadius The radius of the sphere within which the explosion has its effect.
         * @param upwardsModifier Adjustment to the apparent position of the explosion to make it seem to lift objects.
         * @param mode The method used to apply the force to its targets.
         */
        AddExplosionForce(explosionForce: number, explosionPosition: Vector3, explosionRadius: number, upwardsModifier: number): void
        /** Applies a force to a rigidbody that simulates explosion effects.
         * @param explosionForce The force of the explosion (which may be modified by distance).
         * @param explosionPosition The centre of the sphere within which the explosion has its effect.
         * @param explosionRadius The radius of the sphere within which the explosion has its effect.
         * @param upwardsModifier Adjustment to the apparent position of the explosion to make it seem to lift objects.
         * @param mode The method used to apply the force to its targets.
         */
        AddExplosionForce(explosionForce: number, explosionPosition: Vector3, explosionRadius: number): void
        /** The closest point to the bounding box of the attached colliders.
         */
        ClosestPointOnBounds(position: Vector3): Vector3
        /** Tests if a rigidbody would collide with anything, if it was moved through the Scene.
         * @param direction The direction into which to sweep the rigidbody.
         * @param hitInfo If true is returned, hitInfo will contain more information about where the collider was hit (See Also: RaycastHit).
         * @param maxDistance The length of the sweep.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns True when the rigidbody sweep intersects any collider, otherwise false. 
         */
        SweepTest(direction: Vector3, hitInfo: jsb.Out<RaycastHit>, maxDistance: number, queryTriggerInteraction: any): boolean
        SweepTest(direction: Vector3, hitInfo: jsb.Out<RaycastHit>, maxDistance: number): boolean
        SweepTest(direction: Vector3, hitInfo: jsb.Out<RaycastHit>): boolean
        /** Like Rigidbody.SweepTest, but returns all hits.
         * @param direction The direction into which to sweep the rigidbody.
         * @param maxDistance The length of the sweep.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns An array of all colliders hit in the sweep. 
         */
        SweepTestAll(direction: Vector3, maxDistance: number, queryTriggerInteraction: any): Array<RaycastHit>
        SweepTestAll(direction: Vector3, maxDistance: number): Array<RaycastHit>
        SweepTestAll(direction: Vector3): Array<RaycastHit>
        /** The velocity vector of the rigidbody. It represents the rate of change of Rigidbody position.
         */
        velocity: Vector3
        /** The angular velocity vector of the rigidbody measured in radians per second.
         */
        angularVelocity: Vector3
        /** The drag of the object.
         */
        drag: number
        /** The angular drag of the object.
         */
        angularDrag: number
        /** The mass of the rigidbody.
         */
        mass: number
        /** Controls whether gravity affects this rigidbody.
         */
        useGravity: boolean
        /** Maximum velocity of a rigidbody when moving out of penetrating state.
         */
        maxDepenetrationVelocity: number
        /** Controls whether physics affects the rigidbody.
         */
        isKinematic: boolean
        /** Controls whether physics will change the rotation of the object.
         */
        freezeRotation: boolean
        /** Controls which degrees of freedom are allowed for the simulation of this Rigidbody.
         */
        constraints: any
        /** The Rigidbody's collision detection mode.
         */
        collisionDetectionMode: any
        /** The center of mass relative to the transform's origin.
         */
        centerOfMass: Vector3
        /** The center of mass of the rigidbody in world space (Read Only).
         */
        readonly worldCenterOfMass: Vector3
        /** The rotation of the inertia tensor.
         */
        inertiaTensorRotation: Quaternion
        /** The diagonal inertia tensor of mass relative to the center of mass.
         */
        inertiaTensor: Vector3
        /** Should collision detection be enabled? (By default always enabled).
         */
        detectCollisions: boolean
        /** The position of the rigidbody.
         */
        position: Vector3
        /** The rotation of the Rigidbody.
         */
        rotation: Quaternion
        /** Interpolation allows you to smooth out the effect of running physics at a fixed frame rate.
         */
        interpolation: any
        /** The solverIterations determines how accurately Rigidbody joints and collision contacts are resolved. Overrides Physics.defaultSolverIterations. Must be positive.
         */
        solverIterations: number
        /** The mass-normalized energy threshold, below which objects start going to sleep.
         */
        sleepThreshold: number
        /** The maximimum angular velocity of the rigidbody measured in radians per second. (Default 7) range { 0, infinity }.
         */
        maxAngularVelocity: number
        /** The solverVelocityIterations affects how how accurately Rigidbody joints and collision contacts are resolved. Overrides Physics.defaultSolverVelocityIterations. Must be positive.
         */
        solverVelocityIterations: number
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1, Array } from "System";
    /** The Resources class allows you to find and access Objects including assets.
     */
    class Resources extends Object1 {
        /** Returns a list of all objects of Type type.
         */
        static FindObjectsOfTypeAll(type: any): Array<Object>
        /** Loads an asset stored at path in a Resources folder.
         * @param path Path to the target resource to load. When using an empty string (i.e., ""), the function loads the entire contents of the Resources folder.
         * @param systemTypeInstance Type filter for objects returned.
         * @returns The requested asset returned as an Object. 
         */
        static Load(path: string, systemTypeInstance: any): Object
        /** Loads an asset stored at path in a Resources folder.
         * @param path Path to the target resource to load. When using an empty string (i.e., ""), the function loads the entire contents of the Resources folder.
         * @param systemTypeInstance Type filter for objects returned.
         * @returns The requested asset returned as an Object. 
         */
        static Load(path: string): Object
        /** Asynchronously loads an asset stored at path in a Resources folder.
         * @param path Pathname of the target folder. When using the empty string (i.e., ""), the function will load the entire contents of the Resources folder.
         * @param systemTypeInstance Type filter for objects returned.
         */
        static LoadAsync(path: string, type: any): any
        /** Asynchronously loads an asset stored at path in a Resources folder.
         * @param path Pathname of the target folder. When using the empty string (i.e., ""), the function will load the entire contents of the Resources folder.
         */
        static LoadAsync(path: string): any
        /** Loads all assets in a folder or file at path in a Resources folder.
         * @param path Pathname of the target folder. When using the empty string (i.e., ""), the function will load the entire contents of the Resources folder.
         * @param systemTypeInstance Type filter for objects returned.
         */
        static LoadAll(path: string, systemTypeInstance: any): Array<Object>
        /** Loads all assets in a folder or file at path in a Resources folder.
         * @param path Pathname of the target folder. When using the empty string (i.e., ""), the function will load the entire contents of the Resources folder.
         */
        static LoadAll(path: string): Array<Object>
        static GetBuiltinResource(type: any, path: string): Object
        /** Unloads assetToUnload from memory.
         */
        static UnloadAsset(assetToUnload: Object): void
        static UnloadUnusedAssets(): any
        protected constructor()
    }
}
declare module "QuickJS.Unity" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Object as Object1 } from "UnityEngine";
    import { ByteBuffer } from "QuickJS.IO";
    class JSScriptProperties extends Object {
        constructor()
        ForEach(cb: (arg1: string, arg2: Object1) => void): void
        ForEach(cb: (arg1: string, arg2: string) => void): void
        ForEach(cb: (arg1: string, arg2: number) => void): void
        ForEach(cb: (arg1: string, arg2: number) => void): void
        SetObject(key: string, value: Object1): void
        GetObject(key: string): Object1
        SetString(key: string, value: string): void
        GetString(key: string): string
        SetInteger(key: string, value: number): void
        GetInteger(key: string): number
        SetNumber(key: string, value: number): void
        GetNumber(key: string): number
        SetGenericValue(buffer: ByteBuffer): void
        Clear(): void
        readonly IsEmpty: boolean
        genericValueData: Array<jsb.byte>
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1, Array, Enum } from "System";
    /** The GUI class is the interface for Unity's GUI with manual positioning.
     */
    class GUI extends Object1 {
        /** Set the name of the next control.
         */
        static SetNextControlName(name: string): void
        static GetNameOfFocusedControl(): string
        /** Move keyboard focus to a named control.
         * @param name Name set using SetNextControlName.
         */
        static FocusControl(name: string): void
        /** Make a window draggable.
         * @param position The part of the window that can be dragged. This is clipped to the actual window.
         */
        static DragWindow(position: Rect): void
        static DragWindow(): void
        /** Bring a specific window to front of the floating windows.
         * @param windowID The identifier used when you created the window in the Window call.
         */
        static BringWindowToFront(windowID: number): void
        /** Bring a specific window to back of the floating windows.
         * @param windowID The identifier used when you created the window in the Window call.
         */
        static BringWindowToBack(windowID: number): void
        /** Make a window become the active window.
         * @param windowID The identifier used when you created the window in the Window call.
         */
        static FocusWindow(windowID: number): void
        static UnfocusWindow(): void
        /** Make a text or texture label on screen.
         * @param position Rectangle on the screen to use for the label.
         * @param text Text to display on the label.
         * @param image Texture to display on the label.
         * @param content Text, image and tooltip for this label.
         * @param style The style to use. If left out, the label style from the current GUISkin is used.
         */
        static Label(position: Rect, text: string, style: GUIStyle): void
        /** Make a text or texture label on screen.
         * @param position Rectangle on the screen to use for the label.
         * @param text Text to display on the label.
         * @param image Texture to display on the label.
         * @param content Text, image and tooltip for this label.
         * @param style The style to use. If left out, the label style from the current GUISkin is used.
         */
        static Label(position: Rect, image: Texture, style: GUIStyle): void
        /** Make a text or texture label on screen.
         * @param position Rectangle on the screen to use for the label.
         * @param text Text to display on the label.
         * @param image Texture to display on the label.
         * @param content Text, image and tooltip for this label.
         * @param style The style to use. If left out, the label style from the current GUISkin is used.
         */
        static Label(position: Rect, content: GUIContent, style: GUIStyle): void
        /** Make a text or texture label on screen.
         * @param position Rectangle on the screen to use for the label.
         * @param text Text to display on the label.
         * @param image Texture to display on the label.
         * @param content Text, image and tooltip for this label.
         * @param style The style to use. If left out, the label style from the current GUISkin is used.
         */
        static Label(position: Rect, text: string): void
        /** Make a text or texture label on screen.
         * @param position Rectangle on the screen to use for the label.
         * @param text Text to display on the label.
         * @param image Texture to display on the label.
         * @param content Text, image and tooltip for this label.
         * @param style The style to use. If left out, the label style from the current GUISkin is used.
         */
        static Label(position: Rect, image: Texture): void
        /** Make a text or texture label on screen.
         * @param position Rectangle on the screen to use for the label.
         * @param text Text to display on the label.
         * @param image Texture to display on the label.
         * @param content Text, image and tooltip for this label.
         * @param style The style to use. If left out, the label style from the current GUISkin is used.
         */
        static Label(position: Rect, content: GUIContent): void
        /** Draws a border with rounded corners within a rectangle. The texture is used to pattern the border.  Note that this method only works on shader model 2.5 and above.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param alphaBlend Whether to apply alpha blending when drawing the image (enabled by default).
         * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.  Pass in w/h for the desired aspect ratio.  This allows the aspect ratio of the source image to be adjusted without changing the pixel width and height.
         * @param color A tint color to apply on the texture.
         * @param borderWidth The width of the border. If 0, the full texture is drawn.
         * @param borderWidths The width of the borders (left, top, right and bottom). If Vector4.zero, the full texture is drawn.
         * @param borderRadius The radius for rounded corners. If 0, corners will not be rounded.
         * @param borderRadiuses The radiuses for rounded corners (top-left, top-right, bottom-right and bottom-left). If Vector4.zero, corners will not be rounded.
         */
        static DrawTexture(position: Rect, image: Texture, scaleMode: ScaleMode, alphaBlend: boolean, imageAspect: number, color: Color, borderWidth: number, borderRadius: number): void
        /** Draws a border with rounded corners within a rectangle. The texture is used to pattern the border.  Note that this method only works on shader model 2.5 and above.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param alphaBlend Whether to apply alpha blending when drawing the image (enabled by default).
         * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.  Pass in w/h for the desired aspect ratio.  This allows the aspect ratio of the source image to be adjusted without changing the pixel width and height.
         * @param color A tint color to apply on the texture.
         * @param borderWidth The width of the border. If 0, the full texture is drawn.
         * @param borderWidths The width of the borders (left, top, right and bottom). If Vector4.zero, the full texture is drawn.
         * @param borderRadius The radius for rounded corners. If 0, corners will not be rounded.
         * @param borderRadiuses The radiuses for rounded corners (top-left, top-right, bottom-right and bottom-left). If Vector4.zero, corners will not be rounded.
         */
        static DrawTexture(position: Rect, image: Texture, scaleMode: ScaleMode, alphaBlend: boolean, imageAspect: number, color: Color, borderWidths: Vector4, borderRadius: number): void
        static DrawTexture(position: Rect, image: Texture, scaleMode: ScaleMode, alphaBlend: boolean, imageAspect: number, color: Color, borderWidths: Vector4, borderRadiuses: Vector4): void
        /** Draw a texture within a rectangle.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param alphaBlend Whether to apply alpha blending when drawing the image (enabled by default).
         * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.  Pass in w/h for the desired aspect ratio.  This allows the aspect ratio of the source image to be adjusted without changing the pixel width and height.
         */
        static DrawTexture(position: Rect, image: Texture, scaleMode: ScaleMode, alphaBlend: boolean, imageAspect: number): void
        /** Draw a texture within a rectangle.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param alphaBlend Whether to apply alpha blending when drawing the image (enabled by default).
         * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.  Pass in w/h for the desired aspect ratio.  This allows the aspect ratio of the source image to be adjusted without changing the pixel width and height.
         */
        static DrawTexture(position: Rect, image: Texture, scaleMode: ScaleMode, alphaBlend: boolean): void
        /** Draw a texture within a rectangle.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param alphaBlend Whether to apply alpha blending when drawing the image (enabled by default).
         * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.  Pass in w/h for the desired aspect ratio.  This allows the aspect ratio of the source image to be adjusted without changing the pixel width and height.
         */
        static DrawTexture(position: Rect, image: Texture, scaleMode: ScaleMode): void
        /** Draw a texture within a rectangle.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param alphaBlend Whether to apply alpha blending when drawing the image (enabled by default).
         * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.  Pass in w/h for the desired aspect ratio.  This allows the aspect ratio of the source image to be adjusted without changing the pixel width and height.
         */
        static DrawTexture(position: Rect, image: Texture): void
        /** Draw a texture within a rectangle with the given texture coordinates.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param texCoords How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param alphaBlend Whether to alpha blend the image on to the display (the default). If false, the picture is drawn on to the display.
         */
        static DrawTextureWithTexCoords(position: Rect, image: Texture, texCoords: Rect, alphaBlend: boolean): void
        /** Draw a texture within a rectangle with the given texture coordinates.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param texCoords How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param alphaBlend Whether to alpha blend the image on to the display (the default). If false, the picture is drawn on to the display.
         */
        static DrawTextureWithTexCoords(position: Rect, image: Texture, texCoords: Rect): void
        /** Create a Box on the GUI Layer.
         * @param position Rectangle on the screen to use for the box.
         * @param text Text to display on the box.
         * @param image Texture to display on the box.
         * @param content Text, image and tooltip for this box.
         * @param style The style to use. If left out, the box style from the current GUISkin is used.
         */
        static Box(position: Rect, text: string, style: GUIStyle): void
        /** Create a Box on the GUI Layer.
         * @param position Rectangle on the screen to use for the box.
         * @param text Text to display on the box.
         * @param image Texture to display on the box.
         * @param content Text, image and tooltip for this box.
         * @param style The style to use. If left out, the box style from the current GUISkin is used.
         */
        static Box(position: Rect, image: Texture, style: GUIStyle): void
        /** Create a Box on the GUI Layer.
         * @param position Rectangle on the screen to use for the box.
         * @param text Text to display on the box.
         * @param image Texture to display on the box.
         * @param content Text, image and tooltip for this box.
         * @param style The style to use. If left out, the box style from the current GUISkin is used.
         */
        static Box(position: Rect, content: GUIContent, style: GUIStyle): void
        /** Create a Box on the GUI Layer.
         * @param position Rectangle on the screen to use for the box.
         * @param text Text to display on the box.
         * @param image Texture to display on the box.
         * @param content Text, image and tooltip for this box.
         * @param style The style to use. If left out, the box style from the current GUISkin is used.
         */
        static Box(position: Rect, text: string): void
        /** Create a Box on the GUI Layer.
         * @param position Rectangle on the screen to use for the box.
         * @param text Text to display on the box.
         * @param image Texture to display on the box.
         * @param content Text, image and tooltip for this box.
         * @param style The style to use. If left out, the box style from the current GUISkin is used.
         */
        static Box(position: Rect, image: Texture): void
        /** Create a Box on the GUI Layer.
         * @param position Rectangle on the screen to use for the box.
         * @param text Text to display on the box.
         * @param image Texture to display on the box.
         * @param content Text, image and tooltip for this box.
         * @param style The style to use. If left out, the box style from the current GUISkin is used.
         */
        static Box(position: Rect, content: GUIContent): void
        /** Make a single press button. The user clicks them and something happens immediately.
         * @param position Rectangle on the screen to use for the button.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @returns true when the users clicks the button. 
         */
        static Button(position: Rect, text: string, style: GUIStyle): boolean
        /** Make a single press button. The user clicks them and something happens immediately.
         * @param position Rectangle on the screen to use for the button.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @returns true when the users clicks the button. 
         */
        static Button(position: Rect, image: Texture, style: GUIStyle): boolean
        /** Make a single press button. The user clicks them and something happens immediately.
         * @param position Rectangle on the screen to use for the button.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @returns true when the users clicks the button. 
         */
        static Button(position: Rect, content: GUIContent, style: GUIStyle): boolean
        /** Make a single press button. The user clicks them and something happens immediately.
         * @param position Rectangle on the screen to use for the button.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @returns true when the users clicks the button. 
         */
        static Button(position: Rect, text: string): boolean
        /** Make a single press button. The user clicks them and something happens immediately.
         * @param position Rectangle on the screen to use for the button.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @returns true when the users clicks the button. 
         */
        static Button(position: Rect, image: Texture): boolean
        /** Make a single press button. The user clicks them and something happens immediately.
         * @param position Rectangle on the screen to use for the button.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @returns true when the users clicks the button. 
         */
        static Button(position: Rect, content: GUIContent): boolean
        /** Make a button that is active as long as the user holds it down.
         * @param position Rectangle on the screen to use for the button.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @returns True when the users clicks the button. 
         */
        static RepeatButton(position: Rect, text: string, style: GUIStyle): boolean
        /** Make a button that is active as long as the user holds it down.
         * @param position Rectangle on the screen to use for the button.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @returns True when the users clicks the button. 
         */
        static RepeatButton(position: Rect, image: Texture, style: GUIStyle): boolean
        /** Make a button that is active as long as the user holds it down.
         * @param position Rectangle on the screen to use for the button.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @returns True when the users clicks the button. 
         */
        static RepeatButton(position: Rect, content: GUIContent, style: GUIStyle): boolean
        /** Make a button that is active as long as the user holds it down.
         * @param position Rectangle on the screen to use for the button.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @returns True when the users clicks the button. 
         */
        static RepeatButton(position: Rect, text: string): boolean
        /** Make a button that is active as long as the user holds it down.
         * @param position Rectangle on the screen to use for the button.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @returns True when the users clicks the button. 
         */
        static RepeatButton(position: Rect, image: Texture): boolean
        /** Make a button that is active as long as the user holds it down.
         * @param position Rectangle on the screen to use for the button.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @returns True when the users clicks the button. 
         */
        static RepeatButton(position: Rect, content: GUIContent): boolean
        /** Make a single-line text field where the user can edit a string.
         * @param position Rectangle on the screen to use for the text field.
         * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textField style from the current GUISkin is used.
         * @returns The edited string. 
         */
        static TextField(position: Rect, text: string, maxLength: number, style: GUIStyle): string
        /** Make a single-line text field where the user can edit a string.
         * @param position Rectangle on the screen to use for the text field.
         * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textField style from the current GUISkin is used.
         * @returns The edited string. 
         */
        static TextField(position: Rect, text: string, maxLength: number): string
        /** Make a single-line text field where the user can edit a string.
         * @param position Rectangle on the screen to use for the text field.
         * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textField style from the current GUISkin is used.
         * @returns The edited string. 
         */
        static TextField(position: Rect, text: string, style: GUIStyle): string
        /** Make a single-line text field where the user can edit a string.
         * @param position Rectangle on the screen to use for the text field.
         * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textField style from the current GUISkin is used.
         * @returns The edited string. 
         */
        static TextField(position: Rect, text: string): string
        /** Make a text field where the user can enter a password.
         * @param position Rectangle on the screen to use for the text field.
         * @param password Password to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maskChar Character to mask the password with.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textField style from the current GUISkin is used.
         * @returns The edited password. 
         */
        static PasswordField(position: Rect, password: string, maskChar: string, maxLength: number, style: GUIStyle): string
        /** Make a text field where the user can enter a password.
         * @param position Rectangle on the screen to use for the text field.
         * @param password Password to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maskChar Character to mask the password with.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textField style from the current GUISkin is used.
         * @returns The edited password. 
         */
        static PasswordField(position: Rect, password: string, maskChar: string, maxLength: number): string
        /** Make a text field where the user can enter a password.
         * @param position Rectangle on the screen to use for the text field.
         * @param password Password to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maskChar Character to mask the password with.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textField style from the current GUISkin is used.
         * @returns The edited password. 
         */
        static PasswordField(position: Rect, password: string, maskChar: string, style: GUIStyle): string
        /** Make a text field where the user can enter a password.
         * @param position Rectangle on the screen to use for the text field.
         * @param password Password to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maskChar Character to mask the password with.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textField style from the current GUISkin is used.
         * @returns The edited password. 
         */
        static PasswordField(position: Rect, password: string, maskChar: string): string
        /** Make a Multi-line text area where the user can edit a string.
         * @param position Rectangle on the screen to use for the text field.
         * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textArea style from the current GUISkin is used.
         * @returns The edited string. 
         */
        static TextArea(position: Rect, text: string, maxLength: number, style: GUIStyle): string
        /** Make a Multi-line text area where the user can edit a string.
         * @param position Rectangle on the screen to use for the text field.
         * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textArea style from the current GUISkin is used.
         * @returns The edited string. 
         */
        static TextArea(position: Rect, text: string, maxLength: number): string
        /** Make a Multi-line text area where the user can edit a string.
         * @param position Rectangle on the screen to use for the text field.
         * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textArea style from the current GUISkin is used.
         * @returns The edited string. 
         */
        static TextArea(position: Rect, text: string, style: GUIStyle): string
        /** Make a Multi-line text area where the user can edit a string.
         * @param position Rectangle on the screen to use for the text field.
         * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textArea style from the current GUISkin is used.
         * @returns The edited string. 
         */
        static TextArea(position: Rect, text: string): string
        static Toggle(position: Rect, id: number, value: boolean, content: GUIContent, style: GUIStyle): boolean
        /** Make an on/off toggle button.
         * @param position Rectangle on the screen to use for the button.
         * @param value Is this button on or off?
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the toggle style from the current GUISkin is used.
         * @returns The new value of the button. 
         */
        static Toggle(position: Rect, value: boolean, text: string, style: GUIStyle): boolean
        /** Make an on/off toggle button.
         * @param position Rectangle on the screen to use for the button.
         * @param value Is this button on or off?
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the toggle style from the current GUISkin is used.
         * @returns The new value of the button. 
         */
        static Toggle(position: Rect, value: boolean, image: Texture, style: GUIStyle): boolean
        /** Make an on/off toggle button.
         * @param position Rectangle on the screen to use for the button.
         * @param value Is this button on or off?
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the toggle style from the current GUISkin is used.
         * @returns The new value of the button. 
         */
        static Toggle(position: Rect, value: boolean, content: GUIContent, style: GUIStyle): boolean
        /** Make an on/off toggle button.
         * @param position Rectangle on the screen to use for the button.
         * @param value Is this button on or off?
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the toggle style from the current GUISkin is used.
         * @returns The new value of the button. 
         */
        static Toggle(position: Rect, value: boolean, text: string): boolean
        /** Make an on/off toggle button.
         * @param position Rectangle on the screen to use for the button.
         * @param value Is this button on or off?
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the toggle style from the current GUISkin is used.
         * @returns The new value of the button. 
         */
        static Toggle(position: Rect, value: boolean, image: Texture): boolean
        /** Make an on/off toggle button.
         * @param position Rectangle on the screen to use for the button.
         * @param value Is this button on or off?
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the toggle style from the current GUISkin is used.
         * @returns The new value of the button. 
         */
        static Toggle(position: Rect, value: boolean, content: GUIContent): boolean
        static Toolbar(position: Rect, selected: number, contents: Array<GUIContent>, style: GUIStyle, buttonSize: any): number
        /** Make a toolbar.
         * @param position Rectangle on the screen to use for the toolbar.
         * @param selected The index of the selected button.
         * @param texts An array of strings to show on the toolbar buttons.
         * @param images An array of textures on the toolbar buttons.
         * @param contents An array of text, image and tooltips for the toolbar buttons.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param buttonSize Determines how toolbar button size is calculated.
         * @returns The index of the selected button. 
         */
        static Toolbar(position: Rect, selected: number, texts: Array<string>, style: GUIStyle): number
        /** Make a toolbar.
         * @param position Rectangle on the screen to use for the toolbar.
         * @param selected The index of the selected button.
         * @param texts An array of strings to show on the toolbar buttons.
         * @param images An array of textures on the toolbar buttons.
         * @param contents An array of text, image and tooltips for the toolbar buttons.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param buttonSize Determines how toolbar button size is calculated.
         * @returns The index of the selected button. 
         */
        static Toolbar(position: Rect, selected: number, images: Array<Texture>, style: GUIStyle): number
        /** Make a toolbar.
         * @param position Rectangle on the screen to use for the toolbar.
         * @param selected The index of the selected button.
         * @param texts An array of strings to show on the toolbar buttons.
         * @param images An array of textures on the toolbar buttons.
         * @param contents An array of text, image and tooltips for the toolbar buttons.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param buttonSize Determines how toolbar button size is calculated.
         * @returns The index of the selected button. 
         */
        static Toolbar(position: Rect, selected: number, contents: Array<GUIContent>, style: GUIStyle): number
        /** Make a toolbar.
         * @param position Rectangle on the screen to use for the toolbar.
         * @param selected The index of the selected button.
         * @param texts An array of strings to show on the toolbar buttons.
         * @param images An array of textures on the toolbar buttons.
         * @param contents An array of text, image and tooltips for the toolbar buttons.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param buttonSize Determines how toolbar button size is calculated.
         * @returns The index of the selected button. 
         */
        static Toolbar(position: Rect, selected: number, texts: Array<string>): number
        /** Make a toolbar.
         * @param position Rectangle on the screen to use for the toolbar.
         * @param selected The index of the selected button.
         * @param texts An array of strings to show on the toolbar buttons.
         * @param images An array of textures on the toolbar buttons.
         * @param contents An array of text, image and tooltips for the toolbar buttons.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param buttonSize Determines how toolbar button size is calculated.
         * @returns The index of the selected button. 
         */
        static Toolbar(position: Rect, selected: number, images: Array<Texture>): number
        /** Make a toolbar.
         * @param position Rectangle on the screen to use for the toolbar.
         * @param selected The index of the selected button.
         * @param texts An array of strings to show on the toolbar buttons.
         * @param images An array of textures on the toolbar buttons.
         * @param contents An array of text, image and tooltips for the toolbar buttons.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param buttonSize Determines how toolbar button size is calculated.
         * @returns The index of the selected button. 
         */
        static Toolbar(position: Rect, selected: number, contents: Array<GUIContent>): number
        /** Make a grid of buttons.
         * @param position Rectangle on the screen to use for the grid.
         * @param selected The index of the selected grid button.
         * @param texts An array of strings to show on the grid buttons.
         * @param images An array of textures on the grid buttons.
         * @param contents An array of text, image and tooltips for the grid button.
         * @param xCount How many elements to fit in the horizontal direction. The controls will be scaled to fit unless the style defines a fixedWidth to use.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @returns The index of the selected button. 
         */
        static SelectionGrid(position: Rect, selected: number, texts: Array<string>, xCount: number, style: GUIStyle): number
        /** Make a grid of buttons.
         * @param position Rectangle on the screen to use for the grid.
         * @param selected The index of the selected grid button.
         * @param texts An array of strings to show on the grid buttons.
         * @param images An array of textures on the grid buttons.
         * @param contents An array of text, image and tooltips for the grid button.
         * @param xCount How many elements to fit in the horizontal direction. The controls will be scaled to fit unless the style defines a fixedWidth to use.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @returns The index of the selected button. 
         */
        static SelectionGrid(position: Rect, selected: number, images: Array<Texture>, xCount: number, style: GUIStyle): number
        /** Make a grid of buttons.
         * @param position Rectangle on the screen to use for the grid.
         * @param selected The index of the selected grid button.
         * @param texts An array of strings to show on the grid buttons.
         * @param images An array of textures on the grid buttons.
         * @param contents An array of text, image and tooltips for the grid button.
         * @param xCount How many elements to fit in the horizontal direction. The controls will be scaled to fit unless the style defines a fixedWidth to use.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @returns The index of the selected button. 
         */
        static SelectionGrid(position: Rect, selected: number, contents: Array<GUIContent>, xCount: number, style: GUIStyle): number
        /** Make a grid of buttons.
         * @param position Rectangle on the screen to use for the grid.
         * @param selected The index of the selected grid button.
         * @param texts An array of strings to show on the grid buttons.
         * @param images An array of textures on the grid buttons.
         * @param contents An array of text, image and tooltips for the grid button.
         * @param xCount How many elements to fit in the horizontal direction. The controls will be scaled to fit unless the style defines a fixedWidth to use.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @returns The index of the selected button. 
         */
        static SelectionGrid(position: Rect, selected: number, texts: Array<string>, xCount: number): number
        /** Make a grid of buttons.
         * @param position Rectangle on the screen to use for the grid.
         * @param selected The index of the selected grid button.
         * @param texts An array of strings to show on the grid buttons.
         * @param images An array of textures on the grid buttons.
         * @param contents An array of text, image and tooltips for the grid button.
         * @param xCount How many elements to fit in the horizontal direction. The controls will be scaled to fit unless the style defines a fixedWidth to use.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @returns The index of the selected button. 
         */
        static SelectionGrid(position: Rect, selected: number, images: Array<Texture>, xCount: number): number
        /** Make a grid of buttons.
         * @param position Rectangle on the screen to use for the grid.
         * @param selected The index of the selected grid button.
         * @param texts An array of strings to show on the grid buttons.
         * @param images An array of textures on the grid buttons.
         * @param contents An array of text, image and tooltips for the grid button.
         * @param xCount How many elements to fit in the horizontal direction. The controls will be scaled to fit unless the style defines a fixedWidth to use.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @returns The index of the selected button. 
         */
        static SelectionGrid(position: Rect, selected: number, content: Array<GUIContent>, xCount: number): number
        static HorizontalSlider(position: Rect, value: number, leftValue: number, rightValue: number, slider: GUIStyle, thumb: GUIStyle, thumbExtent: GUIStyle): number
        /** A horizontal slider the user can drag to change a value between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @param slider The GUIStyle to use for displaying the dragging area. If left out, the horizontalSlider style from the current GUISkin is used.
         * @param thumb The GUIStyle to use for displaying draggable thumb. If left out, the horizontalSliderThumb style from the current GUISkin is used.
         * @returns The value that has been set by the user. 
         */
        static HorizontalSlider(position: Rect, value: number, leftValue: number, rightValue: number, slider: GUIStyle, thumb: GUIStyle): number
        /** A horizontal slider the user can drag to change a value between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @param slider The GUIStyle to use for displaying the dragging area. If left out, the horizontalSlider style from the current GUISkin is used.
         * @param thumb The GUIStyle to use for displaying draggable thumb. If left out, the horizontalSliderThumb style from the current GUISkin is used.
         * @returns The value that has been set by the user. 
         */
        static HorizontalSlider(position: Rect, value: number, leftValue: number, rightValue: number): number
        static VerticalSlider(position: Rect, value: number, topValue: number, bottomValue: number, slider: GUIStyle, thumb: GUIStyle, thumbExtent: GUIStyle): number
        /** A vertical slider the user can drag to change a value between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param topValue The value at the top end of the slider.
         * @param bottomValue The value at the bottom end of the slider.
         * @param slider The GUIStyle to use for displaying the dragging area. If left out, the horizontalSlider style from the current GUISkin is used.
         * @param thumb The GUIStyle to use for displaying draggable thumb. If left out, the horizontalSliderThumb style from the current GUISkin is used.
         * @returns The value that has been set by the user. 
         */
        static VerticalSlider(position: Rect, value: number, topValue: number, bottomValue: number, slider: GUIStyle, thumb: GUIStyle): number
        /** A vertical slider the user can drag to change a value between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param topValue The value at the top end of the slider.
         * @param bottomValue The value at the bottom end of the slider.
         * @param slider The GUIStyle to use for displaying the dragging area. If left out, the horizontalSlider style from the current GUISkin is used.
         * @param thumb The GUIStyle to use for displaying draggable thumb. If left out, the horizontalSliderThumb style from the current GUISkin is used.
         * @returns The value that has been set by the user. 
         */
        static VerticalSlider(position: Rect, value: number, topValue: number, bottomValue: number): number
        static Slider(position: Rect, value: number, size: number, start: number, end: number, slider: GUIStyle, thumb: GUIStyle, horiz: boolean, id: number, thumbExtent: GUIStyle): number
        /** Make a horizontal scrollbar. Scrollbars are what you use to scroll through a document. Most likely, you want to use scrollViews instead.
         * @param position Rectangle on the screen to use for the scrollbar.
         * @param value The position between min and max.
         * @param size How much can we see?
         * @param leftValue The value at the left end of the scrollbar.
         * @param rightValue The value at the right end of the scrollbar.
         * @param style The style to use for the scrollbar background. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @returns The modified value. This can be changed by the user by dragging the scrollbar, or clicking the arrows at the end. 
         */
        static HorizontalScrollbar(position: Rect, value: number, size: number, leftValue: number, rightValue: number, style: GUIStyle): number
        /** Make a horizontal scrollbar. Scrollbars are what you use to scroll through a document. Most likely, you want to use scrollViews instead.
         * @param position Rectangle on the screen to use for the scrollbar.
         * @param value The position between min and max.
         * @param size How much can we see?
         * @param leftValue The value at the left end of the scrollbar.
         * @param rightValue The value at the right end of the scrollbar.
         * @param style The style to use for the scrollbar background. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @returns The modified value. This can be changed by the user by dragging the scrollbar, or clicking the arrows at the end. 
         */
        static HorizontalScrollbar(position: Rect, value: number, size: number, leftValue: number, rightValue: number): number
        /** Make a vertical scrollbar. Scrollbars are what you use to scroll through a document. Most likely, you want to use scrollViews instead.
         * @param position Rectangle on the screen to use for the scrollbar.
         * @param value The position between min and max.
         * @param size How much can we see?
         * @param topValue The value at the top of the scrollbar.
         * @param bottomValue The value at the bottom of the scrollbar.
         * @param style The style to use for the scrollbar background. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @returns The modified value. This can be changed by the user by dragging the scrollbar, or clicking the arrows at the end. 
         */
        static VerticalScrollbar(position: Rect, value: number, size: number, topValue: number, bottomValue: number, style: GUIStyle): number
        /** Make a vertical scrollbar. Scrollbars are what you use to scroll through a document. Most likely, you want to use scrollViews instead.
         * @param position Rectangle on the screen to use for the scrollbar.
         * @param value The position between min and max.
         * @param size How much can we see?
         * @param topValue The value at the top of the scrollbar.
         * @param bottomValue The value at the bottom of the scrollbar.
         * @param style The style to use for the scrollbar background. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @returns The modified value. This can be changed by the user by dragging the scrollbar, or clicking the arrows at the end. 
         */
        static VerticalScrollbar(position: Rect, value: number, size: number, topValue: number, bottomValue: number): number
        static BeginClip(position: Rect, scrollOffset: Vector2, renderOffset: Vector2, resetOffset: boolean): void
        static BeginClip(position: Rect): void
        /** Begin a group. Must be matched with a call to EndGroup.
         * @param position Rectangle on the screen to use for the group.
         * @param text Text to display on the group.
         * @param image Texture to display on the group.
         * @param content Text, image and tooltip for this group. If supplied, any mouse clicks are "captured" by the group and not If left out, no background is rendered, and mouse clicks are passed.
         * @param style The style to use for the background.
         */
        static BeginGroup(position: Rect, text: string, style: GUIStyle): void
        /** Begin a group. Must be matched with a call to EndGroup.
         * @param position Rectangle on the screen to use for the group.
         * @param text Text to display on the group.
         * @param image Texture to display on the group.
         * @param content Text, image and tooltip for this group. If supplied, any mouse clicks are "captured" by the group and not If left out, no background is rendered, and mouse clicks are passed.
         * @param style The style to use for the background.
         */
        static BeginGroup(position: Rect, image: Texture, style: GUIStyle): void
        /** Begin a group. Must be matched with a call to EndGroup.
         * @param position Rectangle on the screen to use for the group.
         * @param text Text to display on the group.
         * @param image Texture to display on the group.
         * @param content Text, image and tooltip for this group. If supplied, any mouse clicks are "captured" by the group and not If left out, no background is rendered, and mouse clicks are passed.
         * @param style The style to use for the background.
         */
        static BeginGroup(position: Rect, content: GUIContent, style: GUIStyle): void
        /** Begin a group. Must be matched with a call to EndGroup.
         * @param position Rectangle on the screen to use for the group.
         * @param text Text to display on the group.
         * @param image Texture to display on the group.
         * @param content Text, image and tooltip for this group. If supplied, any mouse clicks are "captured" by the group and not If left out, no background is rendered, and mouse clicks are passed.
         * @param style The style to use for the background.
         */
        static BeginGroup(position: Rect, text: string): void
        /** Begin a group. Must be matched with a call to EndGroup.
         * @param position Rectangle on the screen to use for the group.
         * @param text Text to display on the group.
         * @param image Texture to display on the group.
         * @param content Text, image and tooltip for this group. If supplied, any mouse clicks are "captured" by the group and not If left out, no background is rendered, and mouse clicks are passed.
         * @param style The style to use for the background.
         */
        static BeginGroup(position: Rect, image: Texture): void
        /** Begin a group. Must be matched with a call to EndGroup.
         * @param position Rectangle on the screen to use for the group.
         * @param text Text to display on the group.
         * @param image Texture to display on the group.
         * @param content Text, image and tooltip for this group. If supplied, any mouse clicks are "captured" by the group and not If left out, no background is rendered, and mouse clicks are passed.
         * @param style The style to use for the background.
         */
        static BeginGroup(position: Rect, content: GUIContent): void
        /** Begin a group. Must be matched with a call to EndGroup.
         * @param position Rectangle on the screen to use for the group.
         * @param text Text to display on the group.
         * @param image Texture to display on the group.
         * @param content Text, image and tooltip for this group. If supplied, any mouse clicks are "captured" by the group and not If left out, no background is rendered, and mouse clicks are passed.
         * @param style The style to use for the background.
         */
        static BeginGroup(position: Rect, style: GUIStyle): void
        /** Begin a group. Must be matched with a call to EndGroup.
         * @param position Rectangle on the screen to use for the group.
         * @param text Text to display on the group.
         * @param image Texture to display on the group.
         * @param content Text, image and tooltip for this group. If supplied, any mouse clicks are "captured" by the group and not If left out, no background is rendered, and mouse clicks are passed.
         * @param style The style to use for the background.
         */
        static BeginGroup(position: Rect): void
        static EndGroup(): void
        static EndClip(): void
        /** Begin a scrolling view inside your GUI.
         * @param position Rectangle on the screen to use for the ScrollView.
         * @param scrollPosition The pixel distance that the view is scrolled in the X and Y directions.
         * @param viewRect The rectangle used inside the scrollview.
         * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
         * @param alwaysShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when viewRect is wider than position.
         * @param alwaysShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when viewRect is taller than position.
         * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
         */
        static BeginScrollView(position: Rect, scrollPosition: Vector2, viewRect: Rect, alwaysShowHorizontal: boolean, alwaysShowVertical: boolean, horizontalScrollbar: GUIStyle, verticalScrollbar: GUIStyle): Vector2
        /** Begin a scrolling view inside your GUI.
         * @param position Rectangle on the screen to use for the ScrollView.
         * @param scrollPosition The pixel distance that the view is scrolled in the X and Y directions.
         * @param viewRect The rectangle used inside the scrollview.
         * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
         * @param alwaysShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when viewRect is wider than position.
         * @param alwaysShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when viewRect is taller than position.
         * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
         */
        static BeginScrollView(position: Rect, scrollPosition: Vector2, viewRect: Rect, alwaysShowHorizontal: boolean, alwaysShowVertical: boolean): Vector2
        /** Begin a scrolling view inside your GUI.
         * @param position Rectangle on the screen to use for the ScrollView.
         * @param scrollPosition The pixel distance that the view is scrolled in the X and Y directions.
         * @param viewRect The rectangle used inside the scrollview.
         * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
         * @param alwaysShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when viewRect is wider than position.
         * @param alwaysShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when viewRect is taller than position.
         * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
         */
        static BeginScrollView(position: Rect, scrollPosition: Vector2, viewRect: Rect, horizontalScrollbar: GUIStyle, verticalScrollbar: GUIStyle): Vector2
        /** Begin a scrolling view inside your GUI.
         * @param position Rectangle on the screen to use for the ScrollView.
         * @param scrollPosition The pixel distance that the view is scrolled in the X and Y directions.
         * @param viewRect The rectangle used inside the scrollview.
         * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
         * @param alwaysShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when viewRect is wider than position.
         * @param alwaysShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when viewRect is taller than position.
         * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
         */
        static BeginScrollView(position: Rect, scrollPosition: Vector2, viewRect: Rect): Vector2
        /** Ends a scrollview started with a call to BeginScrollView.
         */
        static EndScrollView(handleScrollWheel: boolean): void
        static EndScrollView(): void
        /** Scrolls all enclosing scrollviews so they try to make position visible.
         */
        static ScrollTo(position: Rect): void
        static ScrollTowards(position: Rect, maxDelta: number): boolean
        static Window(id: number, clientRect: Rect, func: (id: number) => void, text: string, style: GUIStyle): Rect
        static Window(id: number, clientRect: Rect, func: (id: number) => void, image: Texture, style: GUIStyle): Rect
        static Window(id: number, clientRect: Rect, func: (id: number) => void, title: GUIContent, style: GUIStyle): Rect
        static Window(id: number, clientRect: Rect, func: (id: number) => void, text: string): Rect
        static Window(id: number, clientRect: Rect, func: (id: number) => void, image: Texture): Rect
        static Window(id: number, clientRect: Rect, func: (id: number) => void, content: GUIContent): Rect
        static ModalWindow(id: number, clientRect: Rect, func: (id: number) => void, text: string, style: GUIStyle): Rect
        static ModalWindow(id: number, clientRect: Rect, func: (id: number) => void, image: Texture, style: GUIStyle): Rect
        static ModalWindow(id: number, clientRect: Rect, func: (id: number) => void, content: GUIContent, style: GUIStyle): Rect
        static ModalWindow(id: number, clientRect: Rect, func: (id: number) => void, text: string): Rect
        static ModalWindow(id: number, clientRect: Rect, func: (id: number) => void, image: Texture): Rect
        static ModalWindow(id: number, clientRect: Rect, func: (id: number) => void, content: GUIContent): Rect
        protected constructor()
        /** Global tinting color for the GUI.
         */
        static color: Color
        /** Global tinting color for all background elements rendered by the GUI.
         */
        static backgroundColor: Color
        /** Tinting color for all text rendered by the GUI.
         */
        static contentColor: Color
        /** Returns true if any controls changed the value of the input data.
         */
        static changed: boolean
        /** Is the GUI enabled?
         */
        static enabled: boolean
        /** The sorting depth of the currently executing GUI behaviour.
         */
        static depth: number
        /** The global skin to use.
         */
        static skin: GUISkin
        /** The GUI transform matrix.
         */
        static matrix: Matrix4x4
        /** The tooltip of the control the mouse is currently over, or which has keyboard focus. (Read Only).
         */
        static tooltip: string
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1, Array } from "System";
    /** Utility class for making new GUI controls.
     */
    class GUIUtility extends Object1 {
        /** Get a unique ID for a control, using an integer as a hint to help ensure correct matching of IDs to controls.
         */
        static GetControlID(hint: number, focusType: FocusType, rect: Rect): number
        /** Get a unique ID for a control, using a the label content as a hint to help ensure correct matching of IDs to controls.
         */
        static GetControlID(contents: GUIContent, focus: FocusType, position: Rect): number
        /** Get a unique ID for a control, using a the label content as a hint to help ensure correct matching of IDs to controls.
         */
        static GetControlID(contents: GUIContent, focus: FocusType): number
        /** Get a unique ID for a control.
         */
        static GetControlID(focus: FocusType, position: Rect): number
        /** Get a unique ID for a control, using an integer as a hint to help ensure correct matching of IDs to controls.
         */
        static GetControlID(hint: number, focus: FocusType): number
        /** Get a unique ID for a control.
         */
        static GetControlID(focus: FocusType): number
        /** Align a local space rectangle to the pixel grid.
         * @param local The local space rectangle that needs to be processed.
         * @param widthInPixels Width, in pixel units, of the axis-aligned bounding box that encompasses the aligned points.
         * @param heightInPixels Height, in pixel units, of the axis-aligned bounding box that encompasses the aligned points.
         * @returns The aligned rectangle in local space. 
         */
        static AlignRectToDevice(rect: Rect, widthInPixels: jsb.Out<number>, heightInPixels: jsb.Out<number>): Rect
        /** Align a local space rectangle to the pixel grid.
         * @param local The local space rectangle that needs to be processed.
         * @param widthInPixels Width, in pixel units, of the axis-aligned bounding box that encompasses the aligned points.
         * @param heightInPixels Height, in pixel units, of the axis-aligned bounding box that encompasses the aligned points.
         * @returns The aligned rectangle in local space. 
         */
        static AlignRectToDevice(rect: Rect): Rect
        /** Get a state object from a controlID.
         */
        static GetStateObject(t: any, controlID: number): Object1
        /** Get an existing state object from a controlID.
         */
        static QueryStateObject(t: any, controlID: number): Object1
        static ExitGUI(): void
        /** Convert a point from GUI position to screen space.
         */
        static GUIToScreenPoint(guiPoint: Vector2): Vector2
        /** Convert a rect from GUI position to screen space.
         */
        static GUIToScreenRect(guiRect: Rect): Rect
        /** Convert a point from screen space to GUI position.
         */
        static ScreenToGUIPoint(screenPoint: Vector2): Vector2
        /** Convert a rect from screen space to GUI position.
         */
        static ScreenToGUIRect(screenRect: Rect): Rect
        /** Helper function to rotate the GUI around a point.
         */
        static RotateAroundPivot(angle: number, pivotPoint: Vector2): void
        /** Helper function to scale the GUI around a point.
         */
        static ScaleAroundPivot(scale: Vector2, pivotPoint: Vector2): void
        protected constructor()
        /** A global property, which is true if a ModalWindow is being displayed, false otherwise.
         */
        static readonly hasModalWindow: boolean
        /** Get access to the system-wide clipboard.
         */
        static systemCopyBuffer: string
        /** The controlID of the current hot control.
         */
        static hotControl: number
        /** The controlID of the control that has keyboard focus.
         */
        static keyboardControl: number
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1, Array, Enum } from "System";
    /** The GUILayout class is the interface for Unity gui with automatic layout.
     */
    class GUILayout extends Object1 {
        /** Make an auto-layout label.
         * @param text Text to display on the label.
         * @param image Texture to display on the label.
         * @param content Text, image and tooltip for this label.
         * @param style The style to use. If left out, the label style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static Label(image: Texture, style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Make an auto-layout label.
         * @param text Text to display on the label.
         * @param image Texture to display on the label.
         * @param content Text, image and tooltip for this label.
         * @param style The style to use. If left out, the label style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static Label(text: string, style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Make an auto-layout label.
         * @param text Text to display on the label.
         * @param image Texture to display on the label.
         * @param content Text, image and tooltip for this label.
         * @param style The style to use. If left out, the label style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static Label(content: GUIContent, style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Make an auto-layout label.
         * @param text Text to display on the label.
         * @param image Texture to display on the label.
         * @param content Text, image and tooltip for this label.
         * @param style The style to use. If left out, the label style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static Label(image: Texture, ...options: GUILayoutOption[]): void
        /** Make an auto-layout label.
         * @param text Text to display on the label.
         * @param image Texture to display on the label.
         * @param content Text, image and tooltip for this label.
         * @param style The style to use. If left out, the label style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static Label(text: string, ...options: GUILayoutOption[]): void
        /** Make an auto-layout label.
         * @param text Text to display on the label.
         * @param image Texture to display on the label.
         * @param content Text, image and tooltip for this label.
         * @param style The style to use. If left out, the label style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static Label(content: GUIContent, ...options: GUILayoutOption[]): void
        /** Make an auto-layout box.
         * @param text Text to display on the box.
         * @param image Texture to display on the box.
         * @param content Text, image and tooltip for this box.
         * @param style The style to use. If left out, the box style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static Box(image: Texture, style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Make an auto-layout box.
         * @param text Text to display on the box.
         * @param image Texture to display on the box.
         * @param content Text, image and tooltip for this box.
         * @param style The style to use. If left out, the box style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static Box(text: string, style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Make an auto-layout box.
         * @param text Text to display on the box.
         * @param image Texture to display on the box.
         * @param content Text, image and tooltip for this box.
         * @param style The style to use. If left out, the box style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static Box(content: GUIContent, style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Make an auto-layout box.
         * @param text Text to display on the box.
         * @param image Texture to display on the box.
         * @param content Text, image and tooltip for this box.
         * @param style The style to use. If left out, the box style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static Box(image: Texture, ...options: GUILayoutOption[]): void
        /** Make an auto-layout box.
         * @param text Text to display on the box.
         * @param image Texture to display on the box.
         * @param content Text, image and tooltip for this box.
         * @param style The style to use. If left out, the box style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static Box(text: string, ...options: GUILayoutOption[]): void
        /** Make an auto-layout box.
         * @param text Text to display on the box.
         * @param image Texture to display on the box.
         * @param content Text, image and tooltip for this box.
         * @param style The style to use. If left out, the box style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static Box(content: GUIContent, ...options: GUILayoutOption[]): void
        /** Make a single press button.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns true when the users clicks the button. 
         */
        static Button(image: Texture, style: GUIStyle, ...options: GUILayoutOption[]): boolean
        /** Make a single press button.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns true when the users clicks the button. 
         */
        static Button(text: string, style: GUIStyle, ...options: GUILayoutOption[]): boolean
        /** Make a single press button.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns true when the users clicks the button. 
         */
        static Button(content: GUIContent, style: GUIStyle, ...options: GUILayoutOption[]): boolean
        /** Make a single press button.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns true when the users clicks the button. 
         */
        static Button(image: Texture, ...options: GUILayoutOption[]): boolean
        /** Make a single press button.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns true when the users clicks the button. 
         */
        static Button(text: string, ...options: GUILayoutOption[]): boolean
        /** Make a single press button.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns true when the users clicks the button. 
         */
        static Button(content: GUIContent, ...options: GUILayoutOption[]): boolean
        /** Make a repeating button. The button returns true as long as the user holds down the mouse.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns true when the holds down the mouse. 
         */
        static RepeatButton(image: Texture, style: GUIStyle, ...options: GUILayoutOption[]): boolean
        /** Make a repeating button. The button returns true as long as the user holds down the mouse.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns true when the holds down the mouse. 
         */
        static RepeatButton(text: string, style: GUIStyle, ...options: GUILayoutOption[]): boolean
        /** Make a repeating button. The button returns true as long as the user holds down the mouse.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns true when the holds down the mouse. 
         */
        static RepeatButton(content: GUIContent, style: GUIStyle, ...options: GUILayoutOption[]): boolean
        /** Make a repeating button. The button returns true as long as the user holds down the mouse.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns true when the holds down the mouse. 
         */
        static RepeatButton(image: Texture, ...options: GUILayoutOption[]): boolean
        /** Make a repeating button. The button returns true as long as the user holds down the mouse.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns true when the holds down the mouse. 
         */
        static RepeatButton(text: string, ...options: GUILayoutOption[]): boolean
        /** Make a repeating button. The button returns true as long as the user holds down the mouse.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns true when the holds down the mouse. 
         */
        static RepeatButton(content: GUIContent, ...options: GUILayoutOption[]): boolean
        /** Make a single-line text field where the user can edit a string.
         * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textArea style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The edited string. 
         */
        static TextField(text: string, maxLength: number, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a single-line text field where the user can edit a string.
         * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textArea style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The edited string. 
         */
        static TextField(text: string, maxLength: number, ...options: GUILayoutOption[]): string
        /** Make a single-line text field where the user can edit a string.
         * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textArea style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The edited string. 
         */
        static TextField(text: string, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a single-line text field where the user can edit a string.
         * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textArea style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The edited string. 
         */
        static TextField(text: string, ...options: GUILayoutOption[]): string
        /** Make a text field where the user can enter a password.
         * @param password Password to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maskChar Character to mask the password with.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textField style from the current GUISkin is used.
         * @returns The edited password. 
         */
        static PasswordField(password: string, maskChar: string, maxLength: number, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a text field where the user can enter a password.
         * @param password Password to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maskChar Character to mask the password with.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textField style from the current GUISkin is used.
         * @returns The edited password. 
         */
        static PasswordField(password: string, maskChar: string, maxLength: number, ...options: GUILayoutOption[]): string
        /** Make a text field where the user can enter a password.
         * @param password Password to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maskChar Character to mask the password with.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textField style from the current GUISkin is used.
         * @returns The edited password. 
         */
        static PasswordField(password: string, maskChar: string, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a text field where the user can enter a password.
         * @param password Password to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maskChar Character to mask the password with.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textField style from the current GUISkin is used.
         * @returns The edited password. 
         */
        static PasswordField(password: string, maskChar: string, ...options: GUILayoutOption[]): string
        /** Make a multi-line text field where the user can edit a string.
         * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textField style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.&amp;lt;br&amp;gt;
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The edited string. 
         */
        static TextArea(text: string, maxLength: number, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a multi-line text field where the user can edit a string.
         * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textField style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.&amp;lt;br&amp;gt;
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The edited string. 
         */
        static TextArea(text: string, maxLength: number, ...options: GUILayoutOption[]): string
        /** Make a multi-line text field where the user can edit a string.
         * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textField style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.&amp;lt;br&amp;gt;
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The edited string. 
         */
        static TextArea(text: string, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a multi-line text field where the user can edit a string.
         * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textField style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.&amp;lt;br&amp;gt;
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The edited string. 
         */
        static TextArea(text: string, ...options: GUILayoutOption[]): string
        /** Make an on/off toggle button.
         * @param value Is the button on or off?
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The new value of the button. 
         */
        static Toggle(value: boolean, image: Texture, style: GUIStyle, ...options: GUILayoutOption[]): boolean
        /** Make an on/off toggle button.
         * @param value Is the button on or off?
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The new value of the button. 
         */
        static Toggle(value: boolean, text: string, style: GUIStyle, ...options: GUILayoutOption[]): boolean
        /** Make an on/off toggle button.
         * @param value Is the button on or off?
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The new value of the button. 
         */
        static Toggle(value: boolean, content: GUIContent, style: GUIStyle, ...options: GUILayoutOption[]): boolean
        /** Make an on/off toggle button.
         * @param value Is the button on or off?
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The new value of the button. 
         */
        static Toggle(value: boolean, image: Texture, ...options: GUILayoutOption[]): boolean
        /** Make an on/off toggle button.
         * @param value Is the button on or off?
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The new value of the button. 
         */
        static Toggle(value: boolean, text: string, ...options: GUILayoutOption[]): boolean
        /** Make an on/off toggle button.
         * @param value Is the button on or off?
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The new value of the button. 
         */
        static Toggle(value: boolean, content: GUIContent, ...options: GUILayoutOption[]): boolean
        static Toolbar(selected: number, contents: Array<GUIContent>, enabled: Array<boolean>, style: GUIStyle, buttonSize: any, ...options: GUILayoutOption[]): number
        static Toolbar(selected: number, texts: Array<string>, style: GUIStyle, buttonSize: any, ...options: GUILayoutOption[]): number
        static Toolbar(selected: number, images: Array<Texture>, style: GUIStyle, buttonSize: any, ...options: GUILayoutOption[]): number
        static Toolbar(selected: number, contents: Array<GUIContent>, style: GUIStyle, buttonSize: any, ...options: GUILayoutOption[]): number
        static Toolbar(selected: number, contents: Array<GUIContent>, enabled: Array<boolean>, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a toolbar.
         * @param selected The index of the selected button.
         * @param texts An array of strings to show on the buttons.
         * @param images An array of textures on the buttons.
         * @param contents An array of text, image and tooltips for the button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param buttonSize Determines how toolbar button size is calculated.
         * @returns The index of the selected button. 
         */
        static Toolbar(selected: number, texts: Array<string>, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a toolbar.
         * @param selected The index of the selected button.
         * @param texts An array of strings to show on the buttons.
         * @param images An array of textures on the buttons.
         * @param contents An array of text, image and tooltips for the button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param buttonSize Determines how toolbar button size is calculated.
         * @returns The index of the selected button. 
         */
        static Toolbar(selected: number, images: Array<Texture>, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a toolbar.
         * @param selected The index of the selected button.
         * @param texts An array of strings to show on the buttons.
         * @param images An array of textures on the buttons.
         * @param contents An array of text, image and tooltips for the button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param buttonSize Determines how toolbar button size is calculated.
         * @returns The index of the selected button. 
         */
        static Toolbar(selected: number, contents: Array<GUIContent>, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a toolbar.
         * @param selected The index of the selected button.
         * @param texts An array of strings to show on the buttons.
         * @param images An array of textures on the buttons.
         * @param contents An array of text, image and tooltips for the button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param buttonSize Determines how toolbar button size is calculated.
         * @returns The index of the selected button. 
         */
        static Toolbar(selected: number, texts: Array<string>, ...options: GUILayoutOption[]): number
        /** Make a toolbar.
         * @param selected The index of the selected button.
         * @param texts An array of strings to show on the buttons.
         * @param images An array of textures on the buttons.
         * @param contents An array of text, image and tooltips for the button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param buttonSize Determines how toolbar button size is calculated.
         * @returns The index of the selected button. 
         */
        static Toolbar(selected: number, images: Array<Texture>, ...options: GUILayoutOption[]): number
        /** Make a toolbar.
         * @param selected The index of the selected button.
         * @param texts An array of strings to show on the buttons.
         * @param images An array of textures on the buttons.
         * @param contents An array of text, image and tooltips for the button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param buttonSize Determines how toolbar button size is calculated.
         * @returns The index of the selected button. 
         */
        static Toolbar(selected: number, contents: Array<GUIContent>, ...options: GUILayoutOption[]): number
        /** Make a Selection Grid.
         * @param selected The index of the selected button.
         * @param texts An array of strings to show on the buttons.
         * @param images An array of textures on the buttons.
         * @param contents An array of text, image and tooltips for the button.
         * @param xCount How many elements to fit in the horizontal direction. The elements will be scaled to fit unless the style defines a fixedWidth to use. The height of the control will be determined from the number of elements.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The index of the selected button. 
         */
        static SelectionGrid(selected: number, texts: Array<string>, xCount: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a Selection Grid.
         * @param selected The index of the selected button.
         * @param texts An array of strings to show on the buttons.
         * @param images An array of textures on the buttons.
         * @param contents An array of text, image and tooltips for the button.
         * @param xCount How many elements to fit in the horizontal direction. The elements will be scaled to fit unless the style defines a fixedWidth to use. The height of the control will be determined from the number of elements.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The index of the selected button. 
         */
        static SelectionGrid(selected: number, images: Array<Texture>, xCount: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a Selection Grid.
         * @param selected The index of the selected button.
         * @param texts An array of strings to show on the buttons.
         * @param images An array of textures on the buttons.
         * @param contents An array of text, image and tooltips for the button.
         * @param xCount How many elements to fit in the horizontal direction. The elements will be scaled to fit unless the style defines a fixedWidth to use. The height of the control will be determined from the number of elements.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The index of the selected button. 
         */
        static SelectionGrid(selected: number, contents: Array<GUIContent>, xCount: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a Selection Grid.
         * @param selected The index of the selected button.
         * @param texts An array of strings to show on the buttons.
         * @param images An array of textures on the buttons.
         * @param contents An array of text, image and tooltips for the button.
         * @param xCount How many elements to fit in the horizontal direction. The elements will be scaled to fit unless the style defines a fixedWidth to use. The height of the control will be determined from the number of elements.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The index of the selected button. 
         */
        static SelectionGrid(selected: number, texts: Array<string>, xCount: number, ...options: GUILayoutOption[]): number
        /** Make a Selection Grid.
         * @param selected The index of the selected button.
         * @param texts An array of strings to show on the buttons.
         * @param images An array of textures on the buttons.
         * @param contents An array of text, image and tooltips for the button.
         * @param xCount How many elements to fit in the horizontal direction. The elements will be scaled to fit unless the style defines a fixedWidth to use. The height of the control will be determined from the number of elements.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The index of the selected button. 
         */
        static SelectionGrid(selected: number, images: Array<Texture>, xCount: number, ...options: GUILayoutOption[]): number
        /** Make a Selection Grid.
         * @param selected The index of the selected button.
         * @param texts An array of strings to show on the buttons.
         * @param images An array of textures on the buttons.
         * @param contents An array of text, image and tooltips for the button.
         * @param xCount How many elements to fit in the horizontal direction. The elements will be scaled to fit unless the style defines a fixedWidth to use. The height of the control will be determined from the number of elements.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The index of the selected button. 
         */
        static SelectionGrid(selected: number, content: Array<GUIContent>, xCount: number, ...options: GUILayoutOption[]): number
        /** A horizontal slider the user can drag to change a value between a min and a max.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @param slider The GUIStyle to use for displaying the dragging area. If left out, the horizontalSlider style from the current GUISkin is used.
         * @param thumb The GUIStyle to use for displaying draggable thumb. If left out, the horizontalSliderThumb style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.
         * @returns The value that has been set by the user. 
         */
        static HorizontalSlider(value: number, leftValue: number, rightValue: number, slider: GUIStyle, thumb: GUIStyle, ...options: GUILayoutOption[]): number
        /** A horizontal slider the user can drag to change a value between a min and a max.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @param slider The GUIStyle to use for displaying the dragging area. If left out, the horizontalSlider style from the current GUISkin is used.
         * @param thumb The GUIStyle to use for displaying draggable thumb. If left out, the horizontalSliderThumb style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.
         * @returns The value that has been set by the user. 
         */
        static HorizontalSlider(value: number, leftValue: number, rightValue: number, ...options: GUILayoutOption[]): number
        /** A vertical slider the user can drag to change a value between a min and a max.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param topValue The value at the top end of the slider.
         * @param bottomValue The value at the bottom end of the slider.
         * @param slider The GUIStyle to use for displaying the dragging area. If left out, the horizontalSlider style from the current GUISkin is used.
         * @param thumb The GUIStyle to use for displaying draggable thumb. If left out, the horizontalSliderThumb style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.
         * @returns The value that has been set by the user. 
         */
        static VerticalSlider(value: number, leftValue: number, rightValue: number, slider: GUIStyle, thumb: GUIStyle, ...options: GUILayoutOption[]): number
        /** A vertical slider the user can drag to change a value between a min and a max.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param topValue The value at the top end of the slider.
         * @param bottomValue The value at the bottom end of the slider.
         * @param slider The GUIStyle to use for displaying the dragging area. If left out, the horizontalSlider style from the current GUISkin is used.
         * @param thumb The GUIStyle to use for displaying draggable thumb. If left out, the horizontalSliderThumb style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.
         * @returns The value that has been set by the user. 
         */
        static VerticalSlider(value: number, leftValue: number, rightValue: number, ...options: GUILayoutOption[]): number
        /** Make a horizontal scrollbar.
         * @param value The position between min and max.
         * @param size How much can we see?
         * @param leftValue The value at the left end of the scrollbar.
         * @param rightValue The value at the right end of the scrollbar.
         * @param style The style to use for the scrollbar background. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.
         * @returns The modified value. This can be changed by the user by dragging the scrollbar, or clicking the arrows at the end. 
         */
        static HorizontalScrollbar(value: number, size: number, leftValue: number, rightValue: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a horizontal scrollbar.
         * @param value The position between min and max.
         * @param size How much can we see?
         * @param leftValue The value at the left end of the scrollbar.
         * @param rightValue The value at the right end of the scrollbar.
         * @param style The style to use for the scrollbar background. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.
         * @returns The modified value. This can be changed by the user by dragging the scrollbar, or clicking the arrows at the end. 
         */
        static HorizontalScrollbar(value: number, size: number, leftValue: number, rightValue: number, ...options: GUILayoutOption[]): number
        /** Make a vertical scrollbar.
         * @param value The position between min and max.
         * @param size How much can we see?
         * @param topValue The value at the top end of the scrollbar.
         * @param bottomValue The value at the bottom end of the scrollbar.
         * @param style The style to use for the scrollbar background. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.
         * @returns The modified value. This can be changed by the user by dragging the scrollbar, or clicking the arrows at the end. 
         */
        static VerticalScrollbar(value: number, size: number, topValue: number, bottomValue: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a vertical scrollbar.
         * @param value The position between min and max.
         * @param size How much can we see?
         * @param topValue The value at the top end of the scrollbar.
         * @param bottomValue The value at the bottom end of the scrollbar.
         * @param style The style to use for the scrollbar background. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.
         * @returns The modified value. This can be changed by the user by dragging the scrollbar, or clicking the arrows at the end. 
         */
        static VerticalScrollbar(value: number, size: number, topValue: number, bottomValue: number, ...options: GUILayoutOption[]): number
        /** Insert a space in the current layout group.
         */
        static Space(pixels: number): void
        static FlexibleSpace(): void
        /** Begin a Horizontal control group.
         * @param text Text to display on group.
         * @param image Texture to display on group.
         * @param content Text, image, and tooltip for this group.
         * @param style The style to use for background image and padding values. If left out, the background is transparent.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static BeginHorizontal(text: string, style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Begin a Horizontal control group.
         * @param text Text to display on group.
         * @param image Texture to display on group.
         * @param content Text, image, and tooltip for this group.
         * @param style The style to use for background image and padding values. If left out, the background is transparent.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static BeginHorizontal(image: Texture, style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Begin a Horizontal control group.
         * @param text Text to display on group.
         * @param image Texture to display on group.
         * @param content Text, image, and tooltip for this group.
         * @param style The style to use for background image and padding values. If left out, the background is transparent.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static BeginHorizontal(content: GUIContent, style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Begin a Horizontal control group.
         * @param text Text to display on group.
         * @param image Texture to display on group.
         * @param content Text, image, and tooltip for this group.
         * @param style The style to use for background image and padding values. If left out, the background is transparent.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static BeginHorizontal(style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Begin a Horizontal control group.
         * @param text Text to display on group.
         * @param image Texture to display on group.
         * @param content Text, image, and tooltip for this group.
         * @param style The style to use for background image and padding values. If left out, the background is transparent.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static BeginHorizontal(...options: GUILayoutOption[]): void
        static EndHorizontal(): void
        /** Begin a vertical control group.
         * @param text Text to display on group.
         * @param image Texture to display on group.
         * @param content Text, image, and tooltip for this group.
         * @param style The style to use for background image and padding values. If left out, the background is transparent.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static BeginVertical(text: string, style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Begin a vertical control group.
         * @param text Text to display on group.
         * @param image Texture to display on group.
         * @param content Text, image, and tooltip for this group.
         * @param style The style to use for background image and padding values. If left out, the background is transparent.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static BeginVertical(image: Texture, style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Begin a vertical control group.
         * @param text Text to display on group.
         * @param image Texture to display on group.
         * @param content Text, image, and tooltip for this group.
         * @param style The style to use for background image and padding values. If left out, the background is transparent.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static BeginVertical(content: GUIContent, style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Begin a vertical control group.
         * @param text Text to display on group.
         * @param image Texture to display on group.
         * @param content Text, image, and tooltip for this group.
         * @param style The style to use for background image and padding values. If left out, the background is transparent.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static BeginVertical(style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Begin a vertical control group.
         * @param text Text to display on group.
         * @param image Texture to display on group.
         * @param content Text, image, and tooltip for this group.
         * @param style The style to use for background image and padding values. If left out, the background is transparent.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static BeginVertical(...options: GUILayoutOption[]): void
        static EndVertical(): void
        /** Begin a GUILayout block of GUI controls in a fixed screen area.
         * @param text Optional text to display in the area.
         * @param image Optional texture to display in the area.
         * @param content Optional text, image and tooltip top display for this area.
         * @param style The style to use. If left out, the empty GUIStyle (GUIStyle.none) is used, giving a transparent background.
         */
        static BeginArea(screenRect: Rect, text: string, style: GUIStyle): void
        /** Begin a GUILayout block of GUI controls in a fixed screen area.
         * @param text Optional text to display in the area.
         * @param image Optional texture to display in the area.
         * @param content Optional text, image and tooltip top display for this area.
         * @param style The style to use. If left out, the empty GUIStyle (GUIStyle.none) is used, giving a transparent background.
         */
        static BeginArea(screenRect: Rect, image: Texture, style: GUIStyle): void
        /** Begin a GUILayout block of GUI controls in a fixed screen area.
         * @param text Optional text to display in the area.
         * @param image Optional texture to display in the area.
         * @param content Optional text, image and tooltip top display for this area.
         * @param style The style to use. If left out, the empty GUIStyle (GUIStyle.none) is used, giving a transparent background.
         */
        static BeginArea(screenRect: Rect, content: GUIContent, style: GUIStyle): void
        /** Begin a GUILayout block of GUI controls in a fixed screen area.
         * @param text Optional text to display in the area.
         * @param image Optional texture to display in the area.
         * @param content Optional text, image and tooltip top display for this area.
         * @param style The style to use. If left out, the empty GUIStyle (GUIStyle.none) is used, giving a transparent background.
         */
        static BeginArea(screenRect: Rect, text: string): void
        /** Begin a GUILayout block of GUI controls in a fixed screen area.
         * @param text Optional text to display in the area.
         * @param image Optional texture to display in the area.
         * @param content Optional text, image and tooltip top display for this area.
         * @param style The style to use. If left out, the empty GUIStyle (GUIStyle.none) is used, giving a transparent background.
         */
        static BeginArea(screenRect: Rect, image: Texture): void
        /** Begin a GUILayout block of GUI controls in a fixed screen area.
         * @param text Optional text to display in the area.
         * @param image Optional texture to display in the area.
         * @param content Optional text, image and tooltip top display for this area.
         * @param style The style to use. If left out, the empty GUIStyle (GUIStyle.none) is used, giving a transparent background.
         */
        static BeginArea(screenRect: Rect, content: GUIContent): void
        /** Begin a GUILayout block of GUI controls in a fixed screen area.
         * @param text Optional text to display in the area.
         * @param image Optional texture to display in the area.
         * @param content Optional text, image and tooltip top display for this area.
         * @param style The style to use. If left out, the empty GUIStyle (GUIStyle.none) is used, giving a transparent background.
         */
        static BeginArea(screenRect: Rect, style: GUIStyle): void
        /** Begin a GUILayout block of GUI controls in a fixed screen area.
         * @param text Optional text to display in the area.
         * @param image Optional texture to display in the area.
         * @param content Optional text, image and tooltip top display for this area.
         * @param style The style to use. If left out, the empty GUIStyle (GUIStyle.none) is used, giving a transparent background.
         */
        static BeginArea(screenRect: Rect): void
        static EndArea(): void
        /** Begin an automatically laid out scrollview.
         * @param scrollPosition The position to use display.
         * @param alwayShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when the content inside the ScrollView is wider than the scrollview itself.
         * @param alwayShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when content inside the ScrollView is taller than the scrollview itself.
         * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
         * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
         */
        static BeginScrollView(scrollPosition: Vector2, alwaysShowHorizontal: boolean, alwaysShowVertical: boolean, horizontalScrollbar: GUIStyle, verticalScrollbar: GUIStyle, background: GUIStyle, ...options: GUILayoutOption[]): Vector2
        /** Begin an automatically laid out scrollview.
         * @param scrollPosition The position to use display.
         * @param alwayShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when the content inside the ScrollView is wider than the scrollview itself.
         * @param alwayShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when content inside the ScrollView is taller than the scrollview itself.
         * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
         * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
         */
        static BeginScrollView(scrollPosition: Vector2, alwaysShowHorizontal: boolean, alwaysShowVertical: boolean, horizontalScrollbar: GUIStyle, verticalScrollbar: GUIStyle, ...options: GUILayoutOption[]): Vector2
        /** Begin an automatically laid out scrollview.
         * @param scrollPosition The position to use display.
         * @param alwayShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when the content inside the ScrollView is wider than the scrollview itself.
         * @param alwayShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when content inside the ScrollView is taller than the scrollview itself.
         * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
         * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
         */
        static BeginScrollView(scrollPosition: Vector2, alwaysShowHorizontal: boolean, alwaysShowVertical: boolean, ...options: GUILayoutOption[]): Vector2
        /** Begin an automatically laid out scrollview.
         * @param scrollPosition The position to use display.
         * @param alwayShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when the content inside the ScrollView is wider than the scrollview itself.
         * @param alwayShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when content inside the ScrollView is taller than the scrollview itself.
         * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
         * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
         */
        static BeginScrollView(scrollPosition: Vector2, horizontalScrollbar: GUIStyle, verticalScrollbar: GUIStyle, ...options: GUILayoutOption[]): Vector2
        /** Begin an automatically laid out scrollview.
         * @param scrollPosition The position to use display.
         * @param alwayShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when the content inside the ScrollView is wider than the scrollview itself.
         * @param alwayShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when content inside the ScrollView is taller than the scrollview itself.
         * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
         * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
         */
        static BeginScrollView(scrollPosition: Vector2, style: GUIStyle): Vector2
        /** Begin an automatically laid out scrollview.
         * @param scrollPosition The position to use display.
         * @param alwayShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when the content inside the ScrollView is wider than the scrollview itself.
         * @param alwayShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when content inside the ScrollView is taller than the scrollview itself.
         * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
         * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
         */
        static BeginScrollView(scrollPosition: Vector2, style: GUIStyle, ...options: GUILayoutOption[]): Vector2
        /** Begin an automatically laid out scrollview.
         * @param scrollPosition The position to use display.
         * @param alwayShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when the content inside the ScrollView is wider than the scrollview itself.
         * @param alwayShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when content inside the ScrollView is taller than the scrollview itself.
         * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
         * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
         */
        static BeginScrollView(scrollPosition: Vector2, ...options: GUILayoutOption[]): Vector2
        static EndScrollView(): void
        static Window(id: number, screenRect: Rect, func: (id: number) => void, text: string, style: GUIStyle, ...options: GUILayoutOption[]): Rect
        static Window(id: number, screenRect: Rect, func: (id: number) => void, image: Texture, style: GUIStyle, ...options: GUILayoutOption[]): Rect
        static Window(id: number, screenRect: Rect, func: (id: number) => void, content: GUIContent, style: GUIStyle, ...options: GUILayoutOption[]): Rect
        static Window(id: number, screenRect: Rect, func: (id: number) => void, text: string, ...options: GUILayoutOption[]): Rect
        static Window(id: number, screenRect: Rect, func: (id: number) => void, image: Texture, ...options: GUILayoutOption[]): Rect
        static Window(id: number, screenRect: Rect, func: (id: number) => void, content: GUIContent, ...options: GUILayoutOption[]): Rect
        /** Option passed to a control to give it an absolute width.
         */
        static Width(width: number): GUILayoutOption
        /** Option passed to a control to specify a minimum width.

         */
        static MinWidth(minWidth: number): GUILayoutOption
        /** Option passed to a control to specify a maximum width.
         */
        static MaxWidth(maxWidth: number): GUILayoutOption
        /** Option passed to a control to give it an absolute height.
         */
        static Height(height: number): GUILayoutOption
        /** Option passed to a control to specify a minimum height.
         */
        static MinHeight(minHeight: number): GUILayoutOption
        /** Option passed to a control to specify a maximum height.
         */
        static MaxHeight(maxHeight: number): GUILayoutOption
        /** Option passed to a control to allow or disallow horizontal expansion.
         */
        static ExpandWidth(expand: boolean): GUILayoutOption
        /** Option passed to a control to allow or disallow vertical expansion.
         */
        static ExpandHeight(expand: boolean): GUILayoutOption
        protected constructor()
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1, Array } from "System";
    /** Utility functions for implementing and extending the GUILayout class.
     */
    class GUILayoutUtility extends Object1 {
        /** Reserve layout space for a flexible rect.
         * @param minWidth The minimum width of the area passed back.
         * @param maxWidth The maximum width of the area passed back.
         * @param minHeight The minimum width of the area passed back.
         * @param maxHeight The maximum width of the area passed back.
         * @param style An optional style. If specified, the style's padding value will be added to the sizes requested & the style's margin values will be used for spacing.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns A rectangle with size between minWidth & maxWidth on both axes. 
         */
        static GetRect(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number, style: GUIStyle): Rect
        /** Reserve layout space for a flexible rect.
         * @param minWidth The minimum width of the area passed back.
         * @param maxWidth The maximum width of the area passed back.
         * @param minHeight The minimum width of the area passed back.
         * @param maxHeight The maximum width of the area passed back.
         * @param style An optional style. If specified, the style's padding value will be added to the sizes requested & the style's margin values will be used for spacing.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns A rectangle with size between minWidth & maxWidth on both axes. 
         */
        static GetRect(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number, style: GUIStyle, ...options: GUILayoutOption[]): Rect
        /** Reserve layout space for a flexible rect.
         * @param minWidth The minimum width of the area passed back.
         * @param maxWidth The maximum width of the area passed back.
         * @param minHeight The minimum width of the area passed back.
         * @param maxHeight The maximum width of the area passed back.
         * @param style An optional style. If specified, the style's padding value will be added to the sizes requested & the style's margin values will be used for spacing.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns A rectangle with size between minWidth & maxWidth on both axes. 
         */
        static GetRect(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): Rect
        /** Reserve layout space for a flexible rect.
         * @param minWidth The minimum width of the area passed back.
         * @param maxWidth The maximum width of the area passed back.
         * @param minHeight The minimum width of the area passed back.
         * @param maxHeight The maximum width of the area passed back.
         * @param style An optional style. If specified, the style's padding value will be added to the sizes requested & the style's margin values will be used for spacing.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns A rectangle with size between minWidth & maxWidth on both axes. 
         */
        static GetRect(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number, ...options: GUILayoutOption[]): Rect
        /** Reserve layout space for a rectangle with a fixed content area.
         * @param width The width of the area you want.
         * @param height The height of the area you want.
         * @param style An optional GUIStyle to layout for. If specified, the style's padding value will be added to your sizes & its margin value will be used for spacing.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The rectanlge to put your control in. 
         */
        static GetRect(width: number, height: number, style: GUIStyle): Rect
        /** Reserve layout space for a rectangle with a fixed content area.
         * @param width The width of the area you want.
         * @param height The height of the area you want.
         * @param style An optional GUIStyle to layout for. If specified, the style's padding value will be added to your sizes & its margin value will be used for spacing.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The rectanlge to put your control in. 
         */
        static GetRect(width: number, height: number, style: GUIStyle, ...options: GUILayoutOption[]): Rect
        /** Reserve layout space for a rectangle for displaying some contents with a specific style.
         * @param content The content to make room for displaying.
         * @param style The GUIStyle to layout for.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns A rectangle that is large enough to contain content when rendered in style. 
         */
        static GetRect(content: GUIContent, style: GUIStyle): Rect
        /** Reserve layout space for a rectangle with a fixed content area.
         * @param width The width of the area you want.
         * @param height The height of the area you want.
         * @param style An optional GUIStyle to layout for. If specified, the style's padding value will be added to your sizes & its margin value will be used for spacing.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The rectanlge to put your control in. 
         */
        static GetRect(width: number, height: number): Rect
        /** Reserve layout space for a rectangle for displaying some contents with a specific style.
         * @param content The content to make room for displaying.
         * @param style The GUIStyle to layout for.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns A rectangle that is large enough to contain content when rendered in style. 
         */
        static GetRect(content: GUIContent, style: GUIStyle, ...options: GUILayoutOption[]): Rect
        /** Reserve layout space for a rectangle with a fixed content area.
         * @param width The width of the area you want.
         * @param height The height of the area you want.
         * @param style An optional GUIStyle to layout for. If specified, the style's padding value will be added to your sizes & its margin value will be used for spacing.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The rectanlge to put your control in. 
         */
        static GetRect(width: number, height: number, ...options: GUILayoutOption[]): Rect
        static GetLastRect(): Rect
        /** Reserve layout space for a rectangle with a specific aspect ratio.
         * @param aspect The aspect ratio of the element (width / height).
         * @param style An optional style. If specified, the style's padding value will be added to the sizes of the returned rectangle & the style's margin values will be used for spacing.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The rect for the control. 
         */
        static GetAspectRect(aspect: number, style: GUIStyle): Rect
        /** Reserve layout space for a rectangle with a specific aspect ratio.
         * @param aspect The aspect ratio of the element (width / height).
         * @param style An optional style. If specified, the style's padding value will be added to the sizes of the returned rectangle & the style's margin values will be used for spacing.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The rect for the control. 
         */
        static GetAspectRect(aspect: number, style: GUIStyle, ...options: GUILayoutOption[]): Rect
        /** Reserve layout space for a rectangle with a specific aspect ratio.
         * @param aspect The aspect ratio of the element (width / height).
         * @param style An optional style. If specified, the style's padding value will be added to the sizes of the returned rectangle & the style's margin values will be used for spacing.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The rect for the control. 
         */
        static GetAspectRect(aspect: number): Rect
        /** Reserve layout space for a rectangle with a specific aspect ratio.
         * @param aspect The aspect ratio of the element (width / height).
         * @param style An optional style. If specified, the style's padding value will be added to the sizes of the returned rectangle & the style's margin values will be used for spacing.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The rect for the control. 
         */
        static GetAspectRect(aspect: number, ...options: GUILayoutOption[]): Rect
        protected constructor()
    }
}
declare module "UnityEngine" {
    import { Object as Object1 } from "System";
    /** Class internally used to pass layout options into GUILayout functions. You don't use these directly, but construct them with the layouting functions in the GUILayout class.
     */
    class GUILayoutOption extends Object1 {
        protected constructor()
    }
}
declare module "UnityEngine" {
    import { Object as Object1 } from "System";
    /** The contents of a GUI element.
     */
    class GUIContent extends Object1 {
        constructor(text: string, image: Texture, tooltip: string)
        constructor(text: string, image: Texture)
        constructor(text: string, tooltip: string)
        constructor(image: Texture, tooltip: string)
        constructor(text: string)
        constructor(image: Texture)
        constructor(src: GUIContent)
        constructor()
        /** The text contained.
         */
        text: string
        /** The icon image contained.
         */
        image: Texture
        /** The tooltip of this element.
         */
        tooltip: string
        /** Shorthand for empty content.
         */
        static none: GUIContent
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Array, Object as Object1 } from "System";
    import { IEnumerator } from "System.Collections";
    /** Defines how GUI looks and behaves.
     */
    class GUISkin extends ScriptableObject {
        constructor()
        /** Get a named GUIStyle.
         */
        GetStyle(styleName: string): GUIStyle
        /** Try to search for a GUIStyle. This functions returns NULL and does not give an error.
         */
        FindStyle(styleName: string): GUIStyle
        GetEnumerator(): IEnumerator
        /** The default font to use for all styles.
         */
        font: any
        /** Style used by default for GUI.Box controls.
         */
        box: GUIStyle
        /** Style used by default for GUI.Label controls.
         */
        label: GUIStyle
        /** Style used by default for GUI.TextField controls.
         */
        textField: GUIStyle
        /** Style used by default for GUI.TextArea controls.
         */
        textArea: GUIStyle
        /** Style used by default for GUI.Button controls.
         */
        button: GUIStyle
        /** Style used by default for GUI.Toggle controls.
         */
        toggle: GUIStyle
        /** Style used by default for Window controls (See Also: GUI.Window).
         */
        window: GUIStyle
        /** Style used by default for the background part of GUI.HorizontalSlider controls.
         */
        horizontalSlider: GUIStyle
        /** Style used by default for the thumb that is dragged in GUI.HorizontalSlider controls.
         */
        horizontalSliderThumb: GUIStyle
        /** Style used by default for the background part of GUI.VerticalSlider controls.
         */
        verticalSlider: GUIStyle
        /** Style used by default for the thumb that is dragged in GUI.VerticalSlider controls.
         */
        verticalSliderThumb: GUIStyle
        /** Style used by default for the background part of GUI.HorizontalScrollbar controls.
         */
        horizontalScrollbar: GUIStyle
        /** Style used by default for the thumb that is dragged in GUI.HorizontalScrollbar controls.
         */
        horizontalScrollbarThumb: GUIStyle
        /** Style used by default for the left button on GUI.HorizontalScrollbar controls.
         */
        horizontalScrollbarLeftButton: GUIStyle
        /** Style used by default for the right button on GUI.HorizontalScrollbar controls.
         */
        horizontalScrollbarRightButton: GUIStyle
        /** Style used by default for the background part of GUI.VerticalScrollbar controls.
         */
        verticalScrollbar: GUIStyle
        /** Style used by default for the thumb that is dragged in GUI.VerticalScrollbar controls.
         */
        verticalScrollbarThumb: GUIStyle
        /** Style used by default for the up button on GUI.VerticalScrollbar controls.
         */
        verticalScrollbarUpButton: GUIStyle
        /** Style used by default for the down button on GUI.VerticalScrollbar controls.
         */
        verticalScrollbarDownButton: GUIStyle
        /** Style used by default for the background of ScrollView controls (see GUI.BeginScrollView).
         */
        scrollView: GUIStyle
        /** Array of GUI styles for specific needs.
         */
        customStyles: Array<GUIStyle>
        /** Generic settings for how controls should behave with this skin.
         */
        readonly settings: any
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1, Enum, Array } from "System";
    /** Styling information for GUI elements.
     */
    class GUIStyle extends Object1 {
        constructor(other: GUIStyle)
        constructor()
        /** Draw the GUIStyle with a text string inside.
         */
        Draw(position: Rect, text: string, isHover: boolean, isActive: boolean, on: boolean, hasKeyboardFocus: boolean): void
        /** Draw the GUIStyle with an image inside. If the image is too large to fit within the content area of the style it is scaled down.
         */
        Draw(position: Rect, image: Texture, isHover: boolean, isActive: boolean, on: boolean, hasKeyboardFocus: boolean): void
        /** Draw the GUIStyle with text and an image inside. If the image is too large to fit within the content area of the style it is scaled down.
         */
        Draw(position: Rect, content: GUIContent, isHover: boolean, isActive: boolean, on: boolean, hasKeyboardFocus: boolean): void
        /** Draw this GUIStyle on to the screen, internal version.
         */
        Draw(position: Rect, isHover: boolean, isActive: boolean, on: boolean, hasKeyboardFocus: boolean): void
        Draw(position: Rect, content: GUIContent, controlID: number, on: boolean, hover: boolean): void
        /** Draw the GUIStyle with text and an image inside. If the image is too large to fit within the content area of the style it is scaled down.
         */
        Draw(position: Rect, content: GUIContent, controlID: number, on: boolean): void
        /** Draw the GUIStyle with text and an image inside. If the image is too large to fit within the content area of the style it is scaled down.
         */
        Draw(position: Rect, content: GUIContent, controlID: number): void
        /** Draw this GUIStyle with selected content.
         */
        DrawCursor(position: Rect, content: GUIContent, controlID: number, character: number): void
        /** Draw this GUIStyle with selected content.
         */
        DrawWithTextSelection(position: Rect, content: GUIContent, controlID: number, firstSelectedCharacter: number, lastSelectedCharacter: number): void
        /** Get the pixel position of a given string index.
         */
        GetCursorPixelPosition(position: Rect, content: GUIContent, cursorStringIndex: number): Vector2
        /** Get the cursor position (indexing into contents.text) when the user clicked at cursorPixelPosition.
         */
        GetCursorStringIndex(position: Rect, content: GUIContent, cursorPixelPosition: Vector2): number
        /** Calculate the size of some content if it is rendered with this style.
         */
        CalcSize(content: GUIContent): Vector2
        /** Calculate the size of an element formatted with this style, and a given space to content.
         */
        CalcScreenSize(contentSize: Vector2): Vector2
        /** How tall this element will be when rendered with content and a specific width.
         */
        CalcHeight(content: GUIContent, width: number): number
        /** Calculate the minimum and maximum widths for this style rendered with content.
         */
        CalcMinMaxWidth(content: GUIContent, minWidth: jsb.Out<number>, maxWidth: jsb.Out<number>): void
        toString(): string
        static op_Implicit(str: string): GUIStyle
        /** The font to use for rendering. If null, the default font for the current GUISkin is used instead.
         */
        font: any
        /** How image and text of the GUIContent is combined.
         */
        imagePosition: any
        /** Text alignment.
         */
        alignment: TextAnchor
        /** Should the text be wordwrapped?
         */
        wordWrap: boolean
        /** What to do when the contents to be rendered is too large to fit within the area given.
         */
        clipping: any
        /** Pixel offset to apply to the content of this GUIstyle.
         */
        contentOffset: Vector2
        /** If non-0, any GUI elements rendered with this style will have the width specified here.
         */
        fixedWidth: number
        /** If non-0, any GUI elements rendered with this style will have the height specified here.
         */
        fixedHeight: number
        /** Can GUI elements of this style be stretched horizontally for better layouting?
         */
        stretchWidth: boolean
        /** Can GUI elements of this style be stretched vertically for better layout?
         */
        stretchHeight: boolean
        /** The font size to use (for dynamic fonts).
         */
        fontSize: number
        /** The font style to use (for dynamic fonts).
         */
        fontStyle: any
        /** Enable HTML-style tags for Text Formatting Markup.
         */
        richText: boolean
        /** The name of this GUIStyle. Used for getting them based on name.
         */
        name: string
        /** Rendering settings for when the component is displayed normally.
         */
        normal: any
        /** Rendering settings for when the mouse is hovering over the control.
         */
        hover: any
        /** Rendering settings for when the control is pressed down.
         */
        active: any
        /** Rendering settings for when the control is turned on.
         */
        onNormal: any
        /** Rendering settings for when the control is turned on and the mouse is hovering it.
         */
        onHover: any
        /** Rendering settings for when the element is turned on and pressed down.
         */
        onActive: any
        /** Rendering settings for when the element has keyboard focus.
         */
        focused: any
        /** Rendering settings for when the element has keyboard and is turned on.
         */
        onFocused: any
        /** The borders of all background images.
         */
        border: any
        /** The margins between elements rendered in this style and any other GUI elements.
         */
        margin: any
        /** Space from the edge of GUIStyle to the start of the contents.
         */
        padding: any
        /** Extra space to be added to the background image.
         */
        overflow: any
        /** The height of one line of text with this style, measured in pixels. (Read Only)
         */
        readonly lineHeight: number
        /** Shortcut for an empty GUIStyle.
         */
        static readonly none: GUIStyle
        readonly isHeightDependantOnWidth: boolean
    }
}
declare module "UnityEngine" {
    import { Enum } from "System";
    /** Where the anchor of the text is placed.
     */
    enum TextAnchor {
        /** Text is anchored in upper left corner.
         */
        UpperLeft = 0,
        /** Text is anchored in upper side, centered horizontally.
         */
        UpperCenter = 1,
        /** Text is anchored in upper right corner.
         */
        UpperRight = 2,
        /** Text is anchored in left side, centered vertically.
         */
        MiddleLeft = 3,
        /** Text is centered both horizontally and vertically.
         */
        MiddleCenter = 4,
        /** Text is anchored in right side, centered vertically.
         */
        MiddleRight = 5,
        /** Text is anchored in lower left corner.
         */
        LowerLeft = 6,
        /** Text is anchored in lower side, centered horizontally.
         */
        LowerCenter = 7,
        /** Text is anchored in lower right corner.
         */
        LowerRight = 8,
    }
}
declare module "UnityEngine" {
    import { Enum } from "System";
    /** Scaling mode to draw textures with.
     */
    enum ScaleMode {
        /** Stretches the texture to fill the complete rectangle passed in to GUI.DrawTexture.
         */
        StretchToFill = 0,
        /** Scales the texture, maintaining aspect ratio, so it completely covers the position rectangle passed to GUI.DrawTexture. If the texture is being draw to a rectangle with a different aspect ratio than the original, the image is cropped.
         */
        ScaleAndCrop = 1,
        /** Scales the texture, maintaining aspect ratio, so it completely fits withing the position rectangle passed to GUI.DrawTexture.
         */
        ScaleToFit = 2,
    }
}
declare module "UnityEngine" {
    import { Enum } from "System";
    /** Used by GUIUtility.GetControlID to inform the IMGUI system if a given control can get keyboard focus. This allows the IMGUI system to give focus appropriately when a user presses tab for cycling between controls.
     */
    enum FocusType {
        Native = 0,
        /** This control can receive keyboard focus.
         */
        Keyboard = 1,
        /** This control can not receive keyboard focus.
         */
        Passive = 2,
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Array } from "System";
    /** A container for audio data.
     */
    class AudioClip extends Object {
        LoadAudioData(): boolean
        UnloadAudioData(): boolean
        /** Fills an array with sample data from the clip.
         */
        GetData(data: Array<number>, offsetSamples: number): boolean
        /** Set sample data in a clip.
         */
        SetData(data: Array<number>, offsetSamples: number): boolean
        static Create(name: string, lengthSamples: number, channels: number, frequency: number, stream: boolean, pcmreadercallback: (data: Array<number>) => void, pcmsetpositioncallback: (id: number) => void): AudioClip
        static Create(name: string, lengthSamples: number, channels: number, frequency: number, stream: boolean, pcmreadercallback: (data: Array<number>) => void): AudioClip
        /** Creates a user AudioClip with a name and with the given length in samples, channels and frequency.
         * @param name Name of clip.
         * @param lengthSamples Number of sample frames.
         * @param channels Number of channels per frame.
         * @param frequency Sample frequency of clip.
         * @param _3D Audio clip is played back in 3D.
         * @param stream True if clip is streamed, that is if the pcmreadercallback generates data on the fly.
         * @param pcmreadercallback This callback is invoked to generate a block of sample data. Non-streamed clips call this only once at creation time while streamed clips call this continuously.
         * @param pcmsetpositioncallback This callback is invoked whenever the clip loops or changes playback position.
         * @returns A reference to the created AudioClip. 
         */
        static Create(name: string, lengthSamples: number, channels: number, frequency: number, stream: boolean): AudioClip
        protected constructor()
        /** The length of the audio clip in seconds. (Read Only)
         */
        readonly length: number
        /** The length of the audio clip in samples. (Read Only)
         */
        readonly samples: number
        /** The number of channels in the audio clip. (Read Only)
         */
        readonly channels: number
        /** The sample frequency of the clip in Hertz. (Read Only)
         */
        readonly frequency: number
        /** The load type of the clip (read-only).
         */
        readonly loadType: AudioClipLoadType
        /** Preloads audio data of the clip when the clip asset is loaded. When this flag is off, scripts have to call AudioClip.LoadAudioData() to load the data before the clip can be played. Properties like length, channels and format are available before the audio data has been loaded.
         */
        readonly preloadAudioData: boolean
        /** Returns true if this audio clip is ambisonic (read-only).
         */
        readonly ambisonic: boolean
        /** Corresponding to the "Load In Background" flag in the inspector, when this flag is set, the loading will happen delayed without blocking the main thread.
         */
        readonly loadInBackground: boolean
        /** Returns the current load state of the audio data associated with an AudioClip.
         */
        readonly loadState: AudioDataLoadState
    }
}
declare module "UnityEngine" {
    import { ValueType } from "System";
    /** A 2D Rectangle defined by x, y, width, height with integers.
     */
    class RectInt extends ValueType {
        constructor(xMin: number, yMin: number, width: number, height: number)
        constructor(position: Vector2Int, size: Vector2Int)
        /** Sets the bounds to the min and max value of the rect.
         */
        SetMinMax(minPosition: Vector2Int, maxPosition: Vector2Int): void
        /** Clamps the position and size of the RectInt to the given bounds.
         * @param bounds Bounds to clamp the RectInt.
         */
        ClampToBounds(bounds: RectInt): void
        /** Returns true if the given position is within the RectInt.
         * @param position Position to check.
         * @returns Whether the position is within the RectInt. 
         */
        Contains(position: Vector2Int): boolean
        /** RectInts overlap if each RectInt Contains a shared point.
         * @param other Other rectangle to test overlapping with.
         * @returns True if the other rectangle overlaps this one. 
         */
        Overlaps(other: RectInt): boolean
        toString(): string
        /** Returns true if the given RectInt is equal to this RectInt.
         */
        Equals(other: RectInt): boolean
        /** Left coordinate of the rectangle.
         */
        x: number
        /** Top coordinate of the rectangle.
         */
        y: number
        /** Center coordinate of the rectangle.
         */
        readonly center: Vector2
        /** Lower left corner of the rectangle.
         */
        min: Vector2Int
        /** Upper right corner of the rectangle.
         */
        max: Vector2Int
        /** Width of the rectangle.
         */
        width: number
        /** Height of the rectangle.
         */
        height: number
        /** Returns the minimum X value of the RectInt.
         */
        xMin: number
        /** Returns the minimum Y value of the RectInt.
         */
        yMin: number
        /** Returns the maximum X value of the RectInt.
         */
        xMax: number
        /** Returns the maximum Y value of the RectInt.
         */
        yMax: number
        /** Returns the position (x, y) of the RectInt.
         */
        position: Vector2Int
        /** Returns the width and height of the RectInt.
         */
        size: Vector2Int
        /** A RectInt.PositionCollection that contains all positions within the RectInt.
         */
        readonly allPositionsWithin: any
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { ValueType, Object as Object1, Array } from "System";
    /** Represents an axis aligned bounding box.
     */
    class Bounds extends ValueType {
        constructor(center: Vector3, size: Vector3)
        GetHashCode(): number
        Equals(other: Object1): boolean
        Equals(other: Bounds): boolean
        /** Sets the bounds to the min and max value of the box.
         */
        SetMinMax(min: Vector3, max: Vector3): void
        /** Grows the Bounds to include the point.
         */
        Encapsulate(point: Vector3): void
        /** Grow the bounds to encapsulate the bounds.
         */
        Encapsulate(bounds: Bounds): void
        /** Expand the bounds by increasing its size by amount along each side.
         */
        Expand(amount: number): void
        /** Expand the bounds by increasing its size by amount along each side.
         */
        Expand(amount: Vector3): void
        /** Does another bounding box intersect with this bounding box?
         */
        Intersects(bounds: Bounds): boolean
        /** Does ray intersect this bounding box?
         */
        IntersectRay(ray: Ray, distance: jsb.Out<number>): boolean
        /** Does ray intersect this bounding box?
         */
        IntersectRay(ray: Ray): boolean
        /** Returns a nicely formatted string for the bounds.
         */
        toString(format: string): string
        toString(): string
        /** Is point contained in the bounding box?
         */
        Contains(point: Vector3): boolean
        /** The smallest squared distance between the point and this bounding box.
         */
        SqrDistance(point: Vector3): number
        /** The closest point on the bounding box.
         * @param point Arbitrary point.
         * @returns The point on the bounding box or inside the bounding box. 
         */
        ClosestPoint(point: Vector3): Vector3
        static op_Inequality(lhs: Bounds, rhs: Bounds): boolean
        // js_op_overloading: static ==(lhs: Bounds, rhs: Bounds): boolean
        /** The center of the bounding box.
         */
        center: Vector3
        /** The total size of the box. This is always twice as large as the extents.
         */
        size: Vector3
        /** The extents of the Bounding Box. This is always half of the size of the Bounds.
         */
        extents: Vector3
        /** The minimal point of the box. This is always equal to center-extents.
         */
        min: Vector3
        /** The maximal point of the box. This is always equal to center+extents.
         */
        max: Vector3
    }
}
declare module "UnityEngine" {
    import { ValueType, Object as Object1 } from "System";
    /** Represents an axis aligned bounding box with all values as integers.
     */
    class BoundsInt extends ValueType {
        constructor(xMin: number, yMin: number, zMin: number, sizeX: number, sizeY: number, sizeZ: number)
        constructor(position: Vector3Int, size: Vector3Int)
        /** Sets the bounds to the min and max value of the box.
         */
        SetMinMax(minPosition: Vector3Int, maxPosition: Vector3Int): void
        /** Clamps the position and size of this bounding box to the given bounds.
         * @param bounds Bounds to clamp to.
         */
        ClampToBounds(bounds: BoundsInt): void
        /** Is point contained in the bounding box?
         * @param position Point to check.
         * @param inclusive Whether the max limits are included in the check.
         * @returns Is point contained in the bounding box? 
         */
        Contains(position: Vector3Int): boolean
        toString(): string
        Equals(other: Object1): boolean
        Equals(other: BoundsInt): boolean
        GetHashCode(): number
        static op_Inequality(lhs: BoundsInt, rhs: BoundsInt): boolean
        // js_op_overloading: static ==(lhs: BoundsInt, rhs: BoundsInt): boolean
        /** X value of the minimal point of the box.
         */
        x: number
        /** Y value of the minimal point of the box.
         */
        y: number
        /** Z value of the minimal point of the box.
         */
        z: number
        /** The center of the bounding box.
         */
        readonly center: Vector3
        /** The minimal point of the box.
         */
        min: Vector3Int
        /** The maximal point of the box.
         */
        max: Vector3Int
        /** The minimal x point of the box.
         */
        xMin: number
        /** The minimal y point of the box.
         */
        yMin: number
        /** The minimal z point of the box.
         */
        zMin: number
        /** The maximal x point of the box.
         */
        xMax: number
        /** The maximal y point of the box.
         */
        yMax: number
        /** The maximal z point of the box.
         */
        zMax: number
        /** The position of the bounding box.
         */
        position: Vector3Int
        /** The total size of the box.
         */
        size: Vector3Int
        /** A BoundsInt.PositionCollection that contains all positions within the BoundsInt.
         */
        readonly allPositionsWithin: any
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1, Array, ValueType, Enum } from "System";
    /** Gradient used for animating colors.
     */
    class Gradient extends Object1 {
        constructor()
        /** Calculate color at a given time.
         * @param time Time of the key (0 - 1).
         */
        Evaluate(time: number): Color
        /** Setup Gradient with an array of color keys and alpha keys.
         * @param colorKeys Color keys of the gradient (maximum 8 color keys).
         * @param alphaKeys Alpha keys of the gradient (maximum 8 alpha keys).
         */
        SetKeys(colorKeys: Array<any>, alphaKeys: Array<any>): void
        Equals(o: Object1): boolean
        Equals(other: Gradient): boolean
        GetHashCode(): number
        /** All color keys defined in the gradient.
         */
        colorKeys: Array<any>
        /** All alpha keys defined in the gradient.
         */
        alphaKeys: Array<any>
        /** Control how the gradient is evaluated.
         */
        mode: any
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1, Array, ValueType } from "System";
    /** Store a collection of Keyframes that can be evaluated over time.
     */
    class AnimationCurve extends Object1 {
        constructor()
        constructor(...keys: any[])
        $GetValue(index: number): any
        /** Evaluate the curve at time.
         * @param time The time within the curve you want to evaluate (the horizontal axis in the curve graph).
         * @returns The value of the curve, at the point in time specified. 
         */
        Evaluate(time: number): number
        /** Add a new key to the curve.
         * @param time The time at which to add the key (horizontal axis in the curve graph).
         * @param value The value for the key (vertical axis in the curve graph).
         * @returns The index of the added key, or -1 if the key could not be added. 
         */
        AddKey(time: number, value: number): number
        /** Add a new key to the curve.
         * @param key The key to add to the curve.
         * @returns The index of the added key, or -1 if the key could not be added. 
         */
        AddKey(key: any): number
        /** Removes the keyframe at index and inserts key.
         * @param index The index of the key to move.
         * @param key The key (with its new time) to insert.
         * @returns The index of the keyframe after moving it. 
         */
        MoveKey(index: number, key: any): number
        /** Removes a key.
         * @param index The index of the key to remove.
         */
        RemoveKey(index: number): void
        /** Smooth the in and out tangents of the keyframe at index.
         * @param index The index of the keyframe to be smoothed.
         * @param weight The smoothing weight to apply to the keyframe's tangents.
         */
        SmoothTangents(index: number, weight: number): void
        Equals(o: Object1): boolean
        Equals(other: AnimationCurve): boolean
        GetHashCode(): number
        /** Creates a constant "curve" starting at timeStart, ending at timeEnd and with the value value.
         * @param timeStart The start time for the constant curve.
         * @param timeEnd The start time for the constant curve.
         * @param value The value for the constant curve.
         * @returns The constant curve created from the specified values. 
         */
        static Constant(timeStart: number, timeEnd: number, value: number): AnimationCurve
        /** A straight Line starting at timeStart, valueStart and ending at timeEnd, valueEnd.
         * @param timeStart The start time for the linear curve.
         * @param valueStart The start value for the linear curve.
         * @param timeEnd The end time for the linear curve.
         * @param valueEnd The end value for the linear curve.
         * @returns The linear curve created from the specified values. 
         */
        static Linear(timeStart: number, valueStart: number, timeEnd: number, valueEnd: number): AnimationCurve
        /** Creates an ease-in and out curve starting at timeStart, valueStart and ending at timeEnd, valueEnd.
         * @param timeStart The start time for the ease curve.
         * @param valueStart The start value for the ease curve.
         * @param timeEnd The end time for the ease curve.
         * @param valueEnd The end value for the ease curve.
         * @returns The ease-in and out curve generated from the specified values. 
         */
        static EaseInOut(timeStart: number, valueStart: number, timeEnd: number, valueEnd: number): AnimationCurve
        /** All keys defined in the animation curve.
         */
        keys: Array<any>
        /** The number of keys in the curve. (Read Only)
         */
        readonly length: number
        /** The behaviour of the animation before the first keyframe.
         */
        preWrapMode: WrapMode
        /** The behaviour of the animation after the last keyframe.
         */
        postWrapMode: WrapMode
    }
}
declare module "UnityEngine" {
    import { Object as Object1, Enum } from "System";
    /** A UnityGUI event.
     */
    class Event extends Object1 {
        constructor(displayIndex: number)
        constructor(other: Event)
        constructor()
        /** Get a filtered event type for a given control ID.
         * @param controlID The ID of the control you are querying from.
         */
        GetTypeForControl(controlID: number): EventType
        GetHashCode(): number
        Equals(obj: Object1): boolean
        toString(): string
        Use(): void
        /** Get the next queued [Event] from the event system.
         * @param outEvent Next Event.
         */
        static PopEvent(outEvent: Event): boolean
        static GetEventCount(): number
        /** Create a keyboard event.
         */
        static KeyboardEvent(key: string): Event
        readonly rawType: EventType
        /** The mouse position.
         */
        mousePosition: Vector2
        /** The relative movement of the mouse compared to last event.
         */
        delta: Vector2
        /** The type of pointer that created this event (for example, mouse, touch screen, pen).
         */
        pointerType: any
        /** Which mouse button was pressed.
         */
        button: number
        /** Which modifier keys are held down.
         */
        modifiers: EventModifiers
        /** How hard stylus pressure is applied.
         */
        pressure: number
        /** How many consecutive mouse clicks have we received.
         */
        clickCount: number
        /** The character typed.
         */
        character: string
        /** The raw key code for keyboard events.
         */
        keyCode: KeyCode
        /** Index of display that the event belongs to.
         */
        displayIndex: number
        /** The type of event.
         */
        type: EventType
        /** The name of an ExecuteCommand or ValidateCommand Event.
         */
        commandName: string
        /** Is Shift held down? (Read Only)
         */
        shift: boolean
        /** Is Control key held down? (Read Only)
         */
        control: boolean
        /** Is Alt/Option key held down? (Read Only)
         */
        alt: boolean
        /** Is Command/Windows key held down? (Read Only)
         */
        command: boolean
        /** Is Caps Lock on? (Read Only)
         */
        capsLock: boolean
        /** Is the current keypress on the numeric keyboard? (Read Only)
         */
        numeric: boolean
        /** Is the current keypress a function key? (Read Only)
         */
        readonly functionKey: boolean
        /** The current event that's being processed right now.
         */
        static current: Event
        /** Is this event a keyboard event? (Read Only)
         */
        readonly isKey: boolean
        /** Is this event a mouse event? (Read Only)
         */
        readonly isMouse: boolean
        readonly isScrollWheel: boolean
    }
}
declare module "UnityEngine" {
    import { Enum } from "System";
    /** Types of UnityGUI input and processing events.
     */
    enum EventType {
        /** An event that is called when the mouse is clicked.
         */
        MouseDown = 0,
        /** An event that is called when the mouse is no longer being clicked.
         */
        MouseUp = 1,
        MouseMove = 2,
        /** An event that is called when the mouse is clicked and dragged.
         */
        MouseDrag = 3,
        /** A keyboard key was pressed.
         */
        KeyDown = 4,
        /** A keyboard key was released.
         */
        KeyUp = 5,
        /** The scroll wheel was moved.
         */
        ScrollWheel = 6,
        Repaint = 7,
        /** A layout event.
         */
        Layout = 8,
        DragUpdated = 9,
        DragPerform = 10,
        Ignore = 11,
        /** Already processed event.
         */
        Used = 12,
        /** Validates a special command (e.g. copy & paste).
         */
        ValidateCommand = 13,
        /** Execute a special command (eg. copy & paste).
         */
        ExecuteCommand = 14,
        /** Editor only: drag & drop operation exited.
         */
        DragExited = 15,
        /** User has right-clicked (or control-clicked on the mac).
         */
        ContextClick = 16,
        /** Mouse entered a window (Editor views only).
         */
        MouseEnterWindow = 20,
        /** Mouse left a window (Editor views only).
         */
        MouseLeaveWindow = 21,
    }
}
declare module "UnityEngine" {
    /** MonoBehaviour.StartCoroutine returns a Coroutine. Instances of this class are only used to reference these coroutines, and do not hold any exposed properties or functions.
     */
    class Coroutine extends YieldInstruction {
        protected constructor()
    }
}
declare module "System.Collections" {
    import { Object } from "System";
    interface IEnumerator {
        MoveNext(): boolean
        Reset(): void
        readonly Current: Object
    }
}
declare module "System.Collections.Generic" {
    interface IEnumerable_String extends IEnumerable<string> {
        GetEnumerator(): any
    }
}
declare module "System.Collections.Generic" {
    import { Object } from "System";
    interface IEnumerable<T> {
        GetEnumerator(): any
    }
}
declare module "UnityEditor.IMGUI.Controls" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Rect, GUIStyle, GUILayoutOption } from "UnityEngine";
    /** The SearchField control creates a text field for a user to input text that can be used for searching.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class SearchField extends Object {
        constructor()
        SetFocus(): void
        HasFocus(): boolean
        /** This function displays a search text field with the given Rect and UI style parameters.
         * @param rect Rectangle to use for the search field.
         * @param text Text string to display in the search field.
         * @param style The text field style.
         * @param cancelButtonStyle The cancel button style used when there is text in the search field.
         * @param emptyCancelButtonStyle The cancel button style used when there is no text in the search field.
         * @returns The text entered in the SearchField. The original input string is returned instead if the search field text was not changed. 
         */
        OnGUI(rect: Rect, text: string, style: GUIStyle, cancelButtonStyle: GUIStyle, emptyCancelButtonStyle: GUIStyle): string
        /** This function displays the search field with the default UI style in the given Rect.
         * @param rect Rectangle to use for the search field.
         * @param text Text string to display in the search field.
         * @returns The text entered in the search field. The original input string is returned instead if the search field text was not changed. 
         */
        OnGUI(rect: Rect, text: string): string
        /** This function displays the search field with the default UI style and uses the GUILayout class to automatically calculate the position and size of the Rect it is rendered to. Pass an optional list to specify extra layout properties.
         * @param text Text string to display in the search field.
         * @param options An optional list of layout options that specify extra layout properties. <br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The text entered in the search field. The original input string is returned instead if the search field text was not changed. 
         */
        OnGUI(text: string, ...options: GUILayoutOption[]): string
        /** This function displays the search field with a toolbar style in the given Rect.
         * @param rect Rectangle to use for the search field.
         * @param text Text string to display in the search field.
         * @returns The text entered in the search field. The original input string is returned instead if the search field text was not changed. 
         */
        OnToolbarGUI(rect: Rect, text: string): string
        /** This function displays the search field with the toolbar UI style and uses the GUILayout class to automatically calculate the position and size of the Rect it is rendered to. Pass an optional list to specify extra layout properties.
         * @param text Text string to display in the search field.
         * @param options An optional list of layout options that specify extra layout properties. <br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The text entered in the search field. The original input string is returned instead if the search field text was not changed. 
         */
        OnToolbarGUI(text: string, ...options: GUILayoutOption[]): string
        /** This is the controlID used for the text field to obtain keyboard focus.
         */
        searchFieldControlID: number
        /** Changes the keyboard focus to the search field when the user presses Ctrl/Cmd + F when set to true. It is true by default.
         */
        autoSetFocusOnFindCommand: boolean
        downOrUpArrowKeyPressed(op: "add" | "remove", fn: () => void): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { GUIStyle, Object as Object1 } from "UnityEngine";
    /** Common GUIStyles used for EditorGUI controls.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class EditorStyles extends Object {
        constructor()
        /** Style used for the labelled on all EditorGUI overloads that take a prefix label.
         */
        static readonly label: GUIStyle
        /** Style for label with small font.
         */
        static readonly miniLabel: GUIStyle
        /** Style for label with large font.
         */
        static readonly largeLabel: GUIStyle
        /** Style for bold label.
         */
        static readonly boldLabel: GUIStyle
        /** Style for mini bold label.
         */
        static readonly miniBoldLabel: GUIStyle
        /** Style for label with small font which is centered and grey.
         */
        static readonly centeredGreyMiniLabel: GUIStyle
        /** Style for word wrapped mini label.
         */
        static readonly wordWrappedMiniLabel: GUIStyle
        /** Style for word wrapped label.
         */
        static readonly wordWrappedLabel: GUIStyle
        /** Style used for links.
         */
        static readonly linkLabel: GUIStyle
        /** Style for white label.
         */
        static readonly whiteLabel: GUIStyle
        /** Style for white mini label.
         */
        static readonly whiteMiniLabel: GUIStyle
        /** Style for white large label.
         */
        static readonly whiteLargeLabel: GUIStyle
        /** Style for white bold label.
         */
        static readonly whiteBoldLabel: GUIStyle
        /** Style used for a radio button.
         */
        static readonly radioButton: GUIStyle
        /** Style used for a standalone small button.
         */
        static readonly miniButton: GUIStyle
        /** Style used for the leftmost button in a horizontal button group.
         */
        static readonly miniButtonLeft: GUIStyle
        /** Style used for the middle buttons in a horizontal group.
         */
        static readonly miniButtonMid: GUIStyle
        /** Style used for the rightmost button in a horizontal group.
         */
        static readonly miniButtonRight: GUIStyle
        /** Style used for the drop-down controls.
         */
        static readonly miniPullDown: GUIStyle
        /** Style used for EditorGUI.TextField.
         */
        static readonly textField: GUIStyle
        /** Style used for EditorGUI.TextArea.
         */
        static readonly textArea: GUIStyle
        /** Smaller text field.
         */
        static readonly miniTextField: GUIStyle
        /** Style used for field editors for numbers.
         */
        static readonly numberField: GUIStyle
        /** Style used for EditorGUI.Popup, EditorGUI.EnumPopup,.
         */
        static readonly popup: GUIStyle
        /** Style used for headings for object fields.
         */
        static readonly objectField: GUIStyle
        /** Style used for headings for the Select button in object fields.
         */
        static readonly objectFieldThumb: GUIStyle
        /** Style used for object fields that have a thumbnail (e.g Textures). 
         */
        static readonly objectFieldMiniThumb: GUIStyle
        /** Style used for headings for Color fields.
         */
        static readonly colorField: GUIStyle
        /** Style used for headings for Layer masks.
         */
        static readonly layerMaskField: GUIStyle
        /** Style used for headings for EditorGUI.Toggle.
         */
        static readonly toggle: GUIStyle
        /** Style used for headings for EditorGUI.Foldout.
         */
        static readonly foldout: GUIStyle
        /** Style used for headings for EditorGUI.Foldout.
         */
        static readonly foldoutPreDrop: GUIStyle
        /** Style used for headings for EditorGUILayout.BeginFoldoutHeaderGroup.
         */
        static readonly foldoutHeader: GUIStyle
        /** Style used for icon for EditorGUILayout.BeginFoldoutHeaderGroup.
         */
        static readonly foldoutHeaderIcon: GUIStyle
        /** Style used for headings for EditorGUILayout.BeginToggleGroup.
         */
        static readonly toggleGroup: GUIStyle
        /** Standard font.
         */
        static readonly standardFont: any
        /** Bold font.
         */
        static readonly boldFont: any
        /** Mini font.
         */
        static readonly miniFont: any
        /** Mini Bold font.
         */
        static readonly miniBoldFont: any
        /** Toolbar background from top of windows.
         */
        static readonly toolbar: GUIStyle
        /** Style for Button and Toggles in toolbars.
         */
        static readonly toolbarButton: GUIStyle
        /** Toolbar Popup.
         */
        static readonly toolbarPopup: GUIStyle
        /** Toolbar Dropdown.
         */
        static readonly toolbarDropDown: GUIStyle
        /** Toolbar text field.
         */
        static readonly toolbarTextField: GUIStyle
        /** Wrap content in a vertical group with this style to get the default margins used in the Inspector.
         */
        static readonly inspectorDefaultMargins: GUIStyle
        /** Wrap content in a vertical group with this style to get full width margins in the Inspector.
         */
        static readonly inspectorFullWidthMargins: GUIStyle
        /** Style used for background box for EditorGUI.HelpBox.
         */
        static readonly helpBox: GUIStyle
        /** Toolbar search field.
         */
        static readonly toolbarSearchField: GUIStyle
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { GUIContent, Rect } from "UnityEngine";
    /** GenericMenu lets you create custom context menus and dropdown menus.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class GenericMenu extends Object {
        constructor()
        AddItem(content: GUIContent, on: boolean, func: (userData: Object) => void, userData: Object): void
        AddItem(content: GUIContent, on: boolean, func: () => void): void
        /** Add a disabled item to the menu.
         * @param content The GUIContent to display as a disabled menu item.
         * @param on Specifies whether to show that the item is currently activated (i.e. a tick next to the item in the menu).
         */
        AddDisabledItem(content: GUIContent, on: boolean): void
        /** Add a disabled item to the menu.
         * @param content The GUIContent to display as a disabled menu item.
         */
        AddDisabledItem(content: GUIContent): void
        /** Add a seperator item to the menu.
         * @param path The path to the submenu, if adding a separator to a submenu. When adding a separator to the top level of a menu, use an empty string as the path.
         */
        AddSeparator(path: string): void
        GetItemCount(): number
        ShowAsContext(): void
        /** Show the menu at the given screen rect.
         * @param position The position at which to show the menu.
         */
        DropDown(position: Rect): void
        /** Allow the menu to have multiple items with the same name.
         */
        allowDuplicateNames: boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Enum } from "System";
    /** Enum indicating the type of Prefab Asset, such as Regular, Model and Variant.
     */
    enum PrefabAssetType {
        /** The object being queried is not part of a Prefab at all.
         */
        NotAPrefab = 0,
        /** The object being queried is part of a regular Prefab.
         */
        Regular = 1,
        /** The object being queried is part of a Model Prefab.
         */
        Model = 2,
        /** The object being queried is part of a Prefab Variant.
         */
        Variant = 3,
        /** The object being queried is part of a Prefab instance, but because the asset is missing the actual type of Prefab cant be determined.
         */
        MissingAsset = 4,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Enum } from "System";
    /** Enum with status about whether a Prefab instance is properly connected to its asset.
     */
    enum PrefabInstanceStatus {
        /** The object is not part of a Prefab instance.
         */
        NotAPrefab = 0,
        /** The Prefab instance is connected to its Prefab Asset.
         */
        Connected = 1,
        /** The Prefab instance is not connected to its Prefab Asset.
         */
        Disconnected = 2,
        /** The Prefab instance is missing its Prefab Asset.
         */
        MissingAsset = 3,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Enum } from "System";
    /** Default mobile device orientation.
     */
    enum UIOrientation {
        /** Portrait.
         */
        Portrait = 0,
        /** Portrait upside down.
         */
        PortraitUpsideDown = 1,
        /** Landscape: clockwise from Portrait.
         */
        LandscapeRight = 2,
        /** Landscape : counter-clockwise from Portrait.
         */
        LandscapeLeft = 3,
        /** Auto Rotation Enabled.
         */
        AutoRotation = 4,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Enum } from "System";
    /** User message types.
     */
    enum MessageType {
        /** Neutral message.
         */
        None = 0,
        /** Info message.
         */
        Info = 1,
        /** Warning message.
         */
        Warning = 2,
        /** Error message.
         */
        Error = 3,
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { ValueType, Object as Object1 } from "System";
    /** Represent the hash value.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class Hash128 extends ValueType {
        constructor(u32_0: number, u32_1: number, u32_2: number, u32_3: number)
        constructor(u64_0: number, u64_1: number)
        CompareTo(rhs: Hash128): number
        CompareTo(obj: Object1): number
        toString(): string
        Equals(obj: Object1): boolean
        Equals(obj: Hash128): boolean
        GetHashCode(): number
        /** Convert the input string to Hash128.
         */
        static Parse(hashString: string): Hash128
        /** Compute a hash of the input string.
         */
        static Compute(hashString: string): Hash128
        static op_Inequality(hash1: Hash128, hash2: Hash128): boolean
        static op_GreaterThan(x: Hash128, y: Hash128): boolean
        // js_op_overloading: static ==(hash1: Hash128, hash2: Hash128): boolean
        // js_op_overloading: static <(x: Hash128, y: Hash128): boolean
        /** Get if the hash value is valid or not. (Read Only)
         */
        readonly isValid: boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Enum } from "System";
    /** Asset importing options.
     */
    enum ImportAssetOptions {
        /** Default import options.
         */
        Default = 0,
        /** User initiated asset import.
         */
        ForceUpdate = 1,
        /** Import all assets synchronously.
         */
        ForceSynchronousImport = 8,
        /** When a folder is imported, import all its contents as well.
         */
        ImportRecursive = 256,
        /** Force a full reimport but don't download the assets from the cache server.
         */
        DontDownloadFromCacheServer = 8192,
        /** Forces asset import as uncompressed for edition facilities.
         */
        ForceUncompressedImport = 16384,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Object as Object1 } from "UnityEngine";
    /** AssetPostprocessor lets you hook into the import pipeline and run scripts prior or after importing assets.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class AssetPostprocessor extends Object {
        /** Logs an import warning to the console.
         */
        LogWarning(warning: string, context: Object1): void
        /** Logs an import warning to the console.
         */
        LogWarning(warning: string): void
        /** Logs an import error message to the console.
         */
        LogError(warning: string, context: Object1): void
        /** Logs an import error message to the console.
         */
        LogError(warning: string): void
        GetVersion(): number
        GetPostprocessOrder(): number
        protected constructor()
        /** The path name of the asset being imported.
         */
        assetPath: string
        /** The import context.
         */
        readonly context: any
        /** Reference to the asset importer.
         */
        readonly assetImporter: AssetImporter
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "UnityEngine";
    import { ValueType, Object as Object1 } from "System";
    /** Base class from which asset importers for specific asset types derive.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class AssetImporter extends Object {
        constructor()
        /** Set the AssetBundle name and variant.
         * @param assetBundleName AssetBundle name.
         * @param assetBundleVariant AssetBundle variant.
         */
        SetAssetBundleNameAndVariant(assetBundleName: string, assetBundleVariant: string): void
        SaveAndReimport(): void
        AddRemap(identifier: any, externalObject: Object): void
        RemoveRemap(identifier: any): boolean
        GetExternalObjectMap(): any
        /** Checks if the AssetImporter supports remapping the given asset type.
         * @param type The type of asset to check.
         * @returns Returns true if the importer supports remapping the given type. Otherwise, returns false. 
         */
        SupportsRemappedAssetType(type: any): boolean
        /** Retrieves the asset importer for the asset at path.
         */
        static GetAtPath(path: string): AssetImporter
        /** The path name of the asset for this importer. (Read Only)
         */
        readonly assetPath: string
        /** The value is true when no meta file is provided with the imported asset.
         */
        readonly importSettingsMissing: boolean
        readonly assetTimeStamp: number
        /** Get or set any user data.
         */
        userData: string
        /** Get or set the AssetBundle name.
         */
        assetBundleName: string
        /** Get or set the AssetBundle variant.
         */
        assetBundleVariant: string
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Enum, Array, ValueType, Object as Object1 } from "System";
    import { WrapMode, Object } from "UnityEngine";
    /** Model importer lets you modify import settings from editor scripts.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ModelImporter extends AssetImporter {
        constructor()
        /** Creates a mask that matches the model hierarchy, and applies it to the provided ModelImporterClipAnimation.
         * @param clip Clip to which the mask will be applied.
         */
        CreateDefaultMaskForClip(clip: any): void
        /** Extracts the embedded textures from a model file (such as FBX or SketchUp).
         * @param folderPath The directory where the textures will be extracted.
         * @returns Returns true if the textures are extracted successfully, otherwise false. 
         */
        ExtractTextures(folderPath: string): boolean
        /** Search the project for matching materials and use them instead of the internal materials.
         * @param nameOption The name matching option.
         * @param searchOption The search type option.
         * @returns Returns true if the materials have been successfly remapped, otherwise false. 
         */
        SearchAndRemapMaterials(nameOption: any, searchOption: any): boolean
        /** Material naming setting.
         */
        materialName: any
        /** Existing material search setting.
         */
        materialSearch: any
        /** Material import location options.
         */
        materialLocation: any
        /** Global scale factor for importing.
         */
        globalScale: number
        /** Is useFileUnits supported for this asset.
         */
        readonly isUseFileUnitsSupported: boolean
        /** Use visibility properties to enable or disable MeshRenderer components.
         */
        importVisibility: boolean
        /** Detect file units and import as 1FileUnit=1UnityUnit, otherwise it will import as 1cm=1UnityUnit.
         */
        useFileUnits: boolean
        /** Scaling factor used when useFileScale is set to true (Read-only).
         */
        readonly fileScale: number
        /** Use FileScale when importing.
         */
        useFileScale: boolean
        /** Controls import of BlendShapes.
         */
        importBlendShapes: boolean
        /** Controls import of cameras. Basic properties like field of view, near plane distance and far plane distance can be animated.
         */
        importCameras: boolean
        /** Controls import of lights. Note that because light are defined differently in DCC tools, some light types or properties may not be exported. Basic properties like color and intensity can be animated.
         */
        importLights: boolean
        /** Add to imported meshes.
         */
        addCollider: boolean
        /** Smoothing angle (in degrees) for calculating normals.
         */
        normalSmoothingAngle: number
        /** Swap primary and secondary UV channels when importing.
         */
        swapUVChannels: boolean
        /** Combine vertices that share the same position in space.
         */
        weldVertices: boolean
        /** If this is true, any quad faces that exist in the mesh data before it is imported are kept as quads instead of being split into two triangles, for the purposes of tessellation. Set this to false to disable this behavior.
         */
        keepQuads: boolean
        /** Format of the imported mesh index buffer data.
         */
        indexFormat: any
        /** If true, always create an explicit Prefab root. Otherwise, if the model has a single root, it is reused as the Prefab root.
         */
        preserveHierarchy: boolean
        /** Generate secondary UV set for lightmapping.
         */
        generateSecondaryUV: boolean
        /** Threshold for angle distortion (in degrees) when generating secondary UV.
         */
        secondaryUVAngleDistortion: number
        /** Threshold for area distortion when generating secondary UV.
         */
        secondaryUVAreaDistortion: number
        /** Hard angle (in degrees) for generating secondary UV.
         */
        secondaryUVHardAngle: number
        /** Margin to be left between charts when packing secondary UV.
         */
        secondaryUVPackMargin: number
        /** Animation generation options.
         */
        generateAnimations: any
        /** Generates the list of all imported take.
         */
        readonly importedTakeInfos: Array<any>
        /** Generates the list of all imported Transforms.
         */
        readonly transformPaths: Array<string>
        /** Generates the list of all imported Animations.
         */
        readonly referencedClips: Array<string>
        /** Are mesh vertices and indices accessible from script?
         */
        isReadable: boolean
        /** Options to control the optimization of mesh data during asset import.
         */
        meshOptimizationFlags: any
        /** Optimize the order of polygons in the mesh to make better use of the GPUs internal caches to improve rendering performance.
         */
        optimizeMeshPolygons: boolean
        /** Optimize the order of vertices in the mesh to make better use of the GPUs internal caches to improve rendering performance.
         */
        optimizeMeshVertices: boolean
        /** Skin weights import options.
         */
        skinWeights: any
        /** Maximum bones per vertex.
         */
        maxBonesPerVertex: number
        /** Minimum bone weight to keep.
         */
        minBoneWeight: number
        /** Vertex normal import options.
         */
        importNormals: any
        /** Source of smoothing information for calculation of normals.
         */
        normalSmoothingSource: any
        /** Blend shape normal import options.
         */
        importBlendShapeNormals: any
        /** Normal generation options for ModelImporter.
         */
        normalCalculationMode: any
        /** Vertex tangent import options.
         */
        importTangents: any
        /** Bake Inverse Kinematics (IK) when importing.
         */
        bakeIK: boolean
        /** Is Bake Inverse Kinematics (IK) supported by this importer.
         */
        readonly isBakeIKSupported: boolean
        /** If set to false, the importer will not resample curves when possible.
Read more about.

Notes:

- Some unsupported FBX features (such as PreRotation or PostRotation on transforms) will override this setting. In these situations, animation curves will still be resampled even if the setting is disabled. For best results, avoid using PreRotation, PostRotation and GetRotationPivot.

- This option was introduced in Version 5.3. Prior to this version, Unity's import behaviour was as if this option was always enabled. Therefore enabling the option gives the same behaviour as pre-5.3 animation import.

         */
        resampleCurves: boolean
        /** Is import of tangents supported by this importer.
         */
        readonly isTangentImportSupported: boolean
        /** Mesh compression setting.
         */
        meshCompression: any
        /** Import animation from file.
         */
        importAnimation: boolean
        /** Animation optimization setting.
         */
        optimizeGameObjects: boolean
        /** Animation optimization setting.
         */
        extraExposedTransformPaths: Array<string>
        /** Additional properties to treat as user properties.
         */
        extraUserProperties: Array<string>
        /** Animation compression setting.
         */
        animationCompression: any
        /** Import animated custom properties from file.
         */
        importAnimatedCustomProperties: boolean
        /** Import animation constraints.
         */
        importConstraints: boolean
        /** Allowed error of animation rotation compression.
         */
        animationRotationError: number
        /** Allowed error of animation position compression.
         */
        animationPositionError: number
        /** Allowed error of animation scale compression.
         */
        animationScaleError: number
        /** The default wrap mode for the generated animation clips.
         */
        animationWrapMode: WrapMode
        /** Animator generation mode.
         */
        animationType: any
        /** Controls how much oversampling is used when importing humanoid animations for retargeting.
         */
        humanoidOversampling: any
        /** The path of the transform used to generation the motion of the animation.
         */
        motionNodeName: string
        /** The Avatar generation of the imported model.
         */
        avatarSetup: any
        /** Imports the HumanDescription from the given Avatar.
         */
        sourceAvatar: any
        /** The human description that is used to generate an Avatar during the import process.
         */
        humanDescription: any
        /** Animation clips to split animation into. See Also: ModelImporterClipAnimation.
         */
        clipAnimations: Array<any>
        /** Generate a list of all default animation clip based on TakeInfo.
         */
        readonly defaultClipAnimations: Array<any>
        /** When disabled, imported material albedo colors are converted to gamma space. This property should be disabled when using linear color space in Player rendering settings.
The default value is true.
         */
        useSRGBMaterialColor: boolean
        /** Sorts the gameObject hierarchy by name.
         */
        sortHierarchyByName: boolean
        /** Material creation options.
         */
        materialImportMode: any
        /** Generate auto mapping if no avatarSetup is provided when importing humanoid animation.
         */
        autoGenerateAvatarMappingIfUnspecified: boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    /** Audio importer lets you modify AudioClip import settings from editor scripts.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class AudioImporter extends AssetImporter {
        constructor()
        /** Returns whether a given build target has its sample settings currently overridden.
         * @param platform The platform to query if this AudioImporter has an override for.
         * @returns Returns true if the platform is currently overriden in this AudioImporter. 
         */
        ContainsSampleSettingsOverride(platform: string): boolean
        /** Return the current override settings for the given platform.
         * @param platform The platform to get the override settings for.
         * @returns The override sample settings for the given platform. 
         */
        GetOverrideSampleSettings(platform: string): any
        /** Sets the override sample settings for the given platform.
         * @param platform The platform which will have the sample settings overridden.
         * @param settings The override settings for the given platform.
         * @returns Returns true if the settings were successfully overriden. Some setting overrides are not possible for the given platform, in which case false is returned and the settings are not registered. 
         */
        SetOverrideSampleSettings(platform: string, settings: any): boolean
        /** Clears the sample settings override for the given platform.
         * @param platform The platform to clear the overrides for.
         * @returns Returns true if any overrides were actually cleared. 
         */
        ClearSampleSettingOverride(platform: string): boolean
        /** The default sample settings for the AudioClip importer.
         */
        defaultSampleSettings: any
        /** Force audioclips to mono?
         */
        forceToMono: boolean
        /** When this flag is set, the audio clip will be treated as being ambisonic.
         */
        ambisonic: boolean
        /** Corresponding to the "Load In Background" flag in the AudioClip inspector, when this flag is set, the loading of the clip will happen delayed without blocking the main thread.
         */
        loadInBackground: boolean
        /** Preloads audio data of the clip when the clip asset is loaded. When this flag is off, scripts have to call AudioClip.LoadAudioData() to load the data before the clip can be played. Properties like length, channels and format are available before the audio data has been loaded.
         */
        preloadAudioData: boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Enum, Object } from "System";
    import { Texture } from "UnityEngine";
    /** VideoClipImporter lets you modify Video.VideoClip import settings from Editor scripts.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class VideoClipImporter extends AssetImporter {
        constructor()
        /** Returns the platform-specific import settings for the specified platform.
         * @param platform Platform name.
         * @returns The platform-specific import settings. Throws an exception if the platform is unknown. 
         */
        GetTargetSettings(platform: string): any
        /** Sets the platform-specific import settings for the specified platform.
         * @param platform Platform name.
         * @param settings The new platform-specific import settings. Throws an exception if the platform is unknown.
         */
        SetTargetSettings(platform: string, settings: any): void
        /** Clear the platform-specific import settings for the specified platform, causing them to go back to the default settings.
         * @param platform Platform name.
         */
        ClearTargetSettings(platform: string): void
        PlayPreview(): void
        StopPreview(): void
        GetPreviewTexture(): Texture
        /** Get the full name of the resize operation for the specified resize mode.
         * @param mode Mode for which the width is queried.
         * @returns Name for the specified resize mode. 
         */
        GetResizeModeName(mode: any): string
        /** Get the resulting width of the resize operation for the specified resize mode.
         * @param mode Mode for which the width is queried.
         * @returns Width for the specified resize mode. 
         */
        GetResizeWidth(mode: any): number
        /** Get the resulting height of the resize operation for the specified resize mode.
         * @param mode Mode for which the height is queried.
         * @returns Height for the specified resize mode. 
         */
        GetResizeHeight(mode: any): number
        /** Number of audio channels in the specified source track.
         * @param audioTrackIdx Index of the audio track to query.
         * @returns Number of channels. 
         */
        GetSourceAudioChannelCount(audioTrackIdx: number): number
        /** Sample rate of the specified audio track.
         * @param audioTrackIdx Index of the audio track to query.
         * @returns Sample rate in Hertz. 
         */
        GetSourceAudioSampleRate(audioTrackIdx: number): number
        /** Performs a value comparison with another VideoClipImporter.
         * @param rhs The importer to compare with.
         * @returns Returns true if the settings for both VideoClipImporters match. Returns false otherwise. 
         */
        Equals(rhs: VideoClipImporter): boolean
        /** Size in bytes of the file before importing.
         */
        readonly sourceFileSize: number
        /** Size in bytes of the file once imported.
         */
        readonly outputFileSize: number
        /** Number of frames in the clip.
         */
        readonly frameCount: number
        /** Frame rate of the clip.
         */
        readonly frameRate: number
        /** Whether to keep the alpha from the source into the transcoded clip.
         */
        keepAlpha: boolean
        /** True if the source file has a channel for per-pixel transparency.
         */
        readonly sourceHasAlpha: boolean
        /** Images are deinterlaced during transcode.  This tells the importer how to interpret fields in the source, if any.
         */
        deinterlaceMode: any
        /** Apply a vertical flip during import.
         */
        flipVertical: boolean
        /** Apply a horizontal flip during import.
         */
        flipHorizontal: boolean
        /** Import audio tracks from source file.
         */
        importAudio: boolean
        /** Whether the imported clip contains sRGB color data.
         */
        sRGBClip: boolean
        /** Default values for the platform-specific import settings.
         */
        defaultTargetSettings: any
        /** Whether the preview is currently playing.
         */
        readonly isPlayingPreview: boolean
        /** Number of audio tracks in the source file.
         */
        readonly sourceAudioTrackCount: number
        /** Numerator of the pixel aspect ratio (num:den).
         */
        readonly pixelAspectRatioNumerator: number
        /** Denominator of the pixel aspect ratio (num:den).
         */
        readonly pixelAspectRatioDenominator: number
        /** Returns true if transcoding was skipped during import, false otherwise. (Read Only)

When VideoImporterTargetSettings.enableTranscoding is set to true, the resulting transcoding operation done at import time may be quite long, up to many hours depending on source resolution and content duration. An option to skip this process is offered in the asset import progress bar. When skipped, the transcoding instead provides a non-transcoded verision of the asset. However, the importer settings stay intact so this property can be inspected to detect the incoherence with the generated artifact.

Re-importing without stopping the transcode process, or with transcode turned off, causes this property to become false.
         */
        readonly transcodeSkipped: boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Enum, Array, ValueType, Object } from "System";
    import { Vector2, Vector4 } from "UnityEngine";
    /** Texture importer lets you modify Texture2D import settings from editor scripts.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class TextureImporter extends AssetImporter {
        constructor()
        /** Get platform specific texture settings.
         * @param platform The platform for which settings are required (see options below).
         * @param maxTextureSize Maximum texture width/height in pixels.
         * @param textureFormat Format of the texture for the given platform.
         * @param compressionQuality Value from 0..100, equivalent to the standard JPEG quality setting.
         * @param etc1AlphaSplitEnabled Status of the ETC1 and alpha split flag.
         * @returns True if the platform override was found, false if no override was found. 
         */
        GetPlatformTextureSettings(platform: string, maxTextureSize: jsb.Out<number>, textureFormat: jsb.Out<any>, compressionQuality: jsb.Out<number>, etc1AlphaSplitEnabled: jsb.Out<boolean>): boolean
        /** Get platform specific texture settings.
         * @param platform The platform whose settings are required (see below).
         * @param maxTextureSize Maximum texture width/height in pixels.
         * @param textureFormat Format of the texture.
         * @param compressionQuality Value from 0..100, equivalent to the standard JPEG quality setting.
         * @returns True if the platform override was found, false if no override was found. 
         */
        GetPlatformTextureSettings(platform: string, maxTextureSize: jsb.Out<number>, textureFormat: jsb.Out<any>, compressionQuality: jsb.Out<number>): boolean
        /** Get platform specific texture settings.
         * @param platform The platform whose settings are required (see below).
         * @param maxTextureSize Maximum texture width/height in pixels.
         * @param textureFormat Format of the texture.
         * @returns True if the platform override was found, false if no override was found. 
         */
        GetPlatformTextureSettings(platform: string, maxTextureSize: jsb.Out<number>, textureFormat: jsb.Out<any>): boolean
        /** Get platform specific texture settings.
         * @param platform The platform whose settings are required (see below).
         * @returns A TextureImporterPlatformSettings structure containing the platform parameters. 
         */
        GetPlatformTextureSettings(platform: string): any
        GetDefaultPlatformTextureSettings(): any
        /** Returns the TextureImporterFormat that would be automatically chosen for this platform.
         * @returns Format chosen by the system for the provided platform, TextureImporterFormat.Automatic if the platform does not exist. 
         */
        GetAutomaticFormat(platform: string): any
        /** Set specific target platform settings.
         * @param platformSettings Structure containing the platform settings.
         */
        SetPlatformTextureSettings(platformSettings: any): void
        /** Clear specific target platform settings.
         * @param platform The platform whose settings are to be cleared (see below).
         */
        ClearPlatformTextureSettings(platform: string): void
        DoesSourceTextureHaveAlpha(): boolean
        /** Read texture settings into TextureImporterSettings class.
         */
        ReadTextureSettings(dest: any): void
        /** Set texture importers settings from TextureImporterSettings class.
         */
        SetTextureSettings(src: any): void
        ReadTextureImportInstructions(target: BuildTarget, desiredFormat: jsb.Out<any>, colorSpace: jsb.Out<any>, compressionQuality: jsb.Out<number>): void
        /** Validates TextureImporterFormat based on a specified import type (TextureImporterType) and a specified build target (BuildTarget.).
         * @param textureType The TextureImporterType that the importer uses.
         * @param target The platform that the setting targets, referred to as the BuilTarget.
         * @param currentFormat The TextureImporterFormat to validate.
         * @returns Returns true if TextureImporterFormat is valid and can be set. Returns false otherwise. 
         */
        static IsPlatformTextureFormatValid(textureType: any, target: BuildTarget, currentFormat: any): boolean
        /** Validates TextureImporterFormat based on the type of the current format (TextureImporterType) and the default platform.
         * @param currentFormat The TextureImporterType that the importer uses.
         * @param textureType The TextureImporterFormat to validate.
         * @returns Returns true if TextureImporterFormat is valid and can be set. Returns false otherwise. 
         */
        static IsDefaultPlatformTextureFormatValid(textureType: any, currentFormat: any): boolean
        /** Maximum texture size.
         */
        maxTextureSize: number
        /** Quality of Texture Compression in the range [0..100].
         */
        compressionQuality: number
        /** Use crunched compression when available.
         */
        crunchedCompression: boolean
        /** Allows alpha splitting on relevant platforms for this texture.
         */
        allowAlphaSplitting: boolean
        /** ETC2 texture decompression fallback override on Android devices that don't support ETC2.
         */
        androidETC2FallbackOverride: any
        /** Compression of imported texture.
         */
        textureCompression: any
        /** Select how the alpha of the imported texture is generated.
         */
        alphaSource: any
        /** Cubemap generation mode.
         */
        generateCubemap: any
        /** Scaling mode for non power of two textures.
         */
        npotScale: any
        /** Set this to true if you want texture data to be readable from scripts. Set it to false to prevent scripts from reading texture data.
         */
        isReadable: boolean
        /** Enable mipmap streaming for this texture.
         */
        streamingMipmaps: boolean
        /** Relative priority for this texture when reducing memory size in order to hit the memory budget.
         */
        streamingMipmapsPriority: number
        /** Generate Mip Maps.
         */
        mipmapEnabled: boolean
        /** Keeps texture borders the same when generating mipmaps.
         */
        borderMipmap: boolean
        /** Determines whether this texture stores color data.
         */
        sRGBTexture: boolean
        /** Enables or disables coverage-preserving alpha MIP mapping.
         */
        mipMapsPreserveCoverage: boolean
        /** Returns or assigns the alpha test reference value.
         */
        alphaTestReferenceValue: number
        /** Mipmap filtering mode.
         */
        mipmapFilter: any
        /** Fades out mip levels to a gray color.
         */
        fadeout: boolean
        /** Mip level where texture begins to fade out.
         */
        mipmapFadeDistanceStart: number
        /** Mip level where texture is faded out completely.
         */
        mipmapFadeDistanceEnd: number
        /** Converts heightmaps to normal maps.
         */
        convertToNormalmap: boolean
        /** Normal map filtering mode.
         */
        normalmapFilter: any
        /** Amount of bumpyness in the heightmap.
         */
        heightmapScale: number
        /** Anisotropic filtering level of the texture.
         */
        anisoLevel: number
        /** Filtering mode of the texture.
         */
        filterMode: any
        /** Texture coordinate wrapping mode.
         */
        wrapMode: any
        /** Texture U coordinate wrapping mode.
         */
        wrapModeU: any
        /** Texture V coordinate wrapping mode.
         */
        wrapModeV: any
        /** Texture W coordinate wrapping mode for Texture3D.
         */
        wrapModeW: any
        /** Mip map bias of the texture.
         */
        mipMapBias: number
        /** If the provided alpha channel is transparency, enable this to prefilter the color to avoid filtering artifacts.
         */
        alphaIsTransparency: boolean
        /** Returns true if this TextureImporter is setup for Sprite packing.
         */
        readonly qualifiesForSpritePacking: boolean
        /** Selects Single or Manual import mode for Sprite textures.
         */
        spriteImportMode: any
        /** Array representing the sections of the atlas corresponding to individual sprite graphics.
         */
        spritesheet: Array<any>
        /** Secondary textures for the imported Sprites.
         */
        secondarySpriteTextures: Array<any>
        /** Selects the Sprite packing tag.
         */
        spritePackingTag: string
        /** The number of pixels in the sprite that correspond to one unit in world space.
         */
        spritePixelsPerUnit: number
        /** The point in the Sprite object's coordinate space where the graphic is located.
         */
        spritePivot: Vector2
        /** Border sizes of the generated sprites.
         */
        spriteBorder: Vector4
        /** Which type of texture are we dealing with here.
         */
        textureType: any
        /** Shape of imported texture.
         */
        textureShape: any
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Enum } from "System";
    /** Custom mouse cursor shapes used with EditorGUIUtility.AddCursorRect.
     */
    enum MouseCursor {
        /** Normal pointer arrow.
         */
        Arrow = 0,
        /** Text cursor.
         */
        Text = 1,
        /** Vertical resize arrows.
         */
        ResizeVertical = 2,
        /** Horizontal resize arrows.
         */
        ResizeHorizontal = 3,
        /** Arrow with a Link badge (for assigning pointers).
         */
        Link = 4,
        /** Arrow with small arrows for indicating sliding at number fields.
         */
        SlideArrow = 5,
        /** Resize up-right for window edges.
         */
        ResizeUpRight = 6,
        /** Resize up-Left for window edges.
         */
        ResizeUpLeft = 7,
        /** Arrow with the move symbol next to it for the sceneview.
         */
        MoveArrow = 8,
        /** Arrow with the rotate symbol next to it for the sceneview.
         */
        RotateArrow = 9,
        /** Arrow with the scale symbol next to it for the sceneview.
         */
        ScaleArrow = 10,
        /** Arrow with the plus symbol next to it.
         */
        ArrowPlus = 11,
        /** Arrow with the minus symbol next to it.
         */
        ArrowMinus = 12,
        /** Cursor with a dragging hand for pan.
         */
        Pan = 13,
        /** Cursor with an eye for orbit.
         */
        Orbit = 14,
        /** Cursor with a magnifying glass for zoom.
         */
        Zoom = 15,
        /** Cursor with an eye and stylized arrow keys for FPS navigation.
         */
        FPS = 16,
        /** The current user defined cursor.
         */
        CustomCursor = 17,
        /** Up-Down resize arrows for window splitters.
         */
        SplitResizeUpDown = 18,
        /** Left-Right resize arrows for window splitters.
         */
        SplitResizeLeftRight = 19,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Enum } from "System";
    /** Enumeration specifying the current pause state of the Editor.

See Also: PlayModeStateChange, EditorApplication.pauseStateChanged, EditorApplication.isPaused.
     */
    enum PauseState {
        /** Occurs as soon as the Editor is paused, which may occur during either edit mode or play mode.
         */
        Paused = 0,
        /** Occurs as soon as the Editor is unpaused, which may occur during either edit mode or play mode.
         */
        Unpaused = 1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Enum } from "System";
    /** Enumeration specifying a change in the Editor's play mode state.

See Also: PauseState, EditorApplication.playModeStateChanged, EditorApplication.isPlaying.
     */
    enum PlayModeStateChange {
        /** Occurs during the next update of the Editor application if it is in edit mode and was previously in play mode.
         */
        EnteredEditMode = 0,
        /** Occurs when exiting edit mode, before the Editor is in play mode.
         */
        ExitingEditMode = 1,
        /** Occurs during the next update of the Editor application if it is in play mode and was previously in edit mode.
         */
        EnteredPlayMode = 2,
        /** Occurs when exiting play mode, before the Editor is in edit mode.
         */
        ExitingPlayMode = 3,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Enum } from "System";
    /** Export package option. Multiple options can be combined together using the | operator.
     */
    enum ExportPackageOptions {
        /** Default mode. Will not include dependencies or subdirectories nor include Library assets unless specifically included in the asset list.
         */
        Default = 0,
        /** The export operation will be run asynchronously and reveal the exported package file in a file browser window after the export is finished.
         */
        Interactive = 1,
        /** Will recurse through any subdirectories listed and include all assets inside them.
         */
        Recurse = 2,
        /** In addition to the assets paths listed, all dependent assets will be included as well.
         */
        IncludeDependencies = 4,
        /** The exported package will include all library assets, ie. the project settings located in the Library folder of the project.
         */
        IncludeLibraryAssets = 8,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Enum } from "System";
    /** Options for AssetDatabase.ForceReserializeAssets.
     */
    enum ForceReserializeAssetsOptions {
        /** Specifies that AssetDatabase.ForceReserializeAssets should load, upgrade, and save the assets at the paths passed to the function, but not their accompanying .meta files.
         */
        ReserializeAssets = 1,
        /** Specifies that AssetDatabase.ForceReserializeAssets should load, upgrade, and save the .meta files for the assets at the paths passed to the function, but not the assets themselves.
         */
        ReserializeMetadata = 2,
        /** Specifies that AssetDatabase.ForceReserializeAssets should load, upgrade, and save both the assets at the paths passed to the function, and also their accompanying .meta files.
         */
        ReserializeAssetsAndMetadata = 3,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Enum } from "System";
    /** Options for querying the version control system status of a file.
     */
    enum StatusQueryOptions {
        /** Force a refresh of the version control system status of the file. This is slow but accurate.
         */
        ForceUpdate = 0,
        /** This option sets the status query to first use the latest valid version control system status of the file and query for a valid status synchronously if otherwise.
         */
        UseCachedIfPossible = 1,
        /** This option sets the status query to first use the latest valid version control system status of the file and query for a valid status asynchronously if otherwise.
         */
        UseCachedAsync = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Object as Object1 } from "UnityEngine";
    /** SerializedObject and SerializedProperty are classes for editing serialized fields on Object|Unity objects in a completely generic way. These classes automatically handle dirtying individual serialized fields so they will be processed by the Undo system and styled correctly for Prefab overrides when drawn in the Inspector.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class SerializedObject extends Object {
        constructor(obj: Object1, context: Object1)
        constructor(objs: Array<Object1>, context: Object1)
        constructor(obj: Object1)
        constructor(objs: Array<Object1>)
        Dispose(): void
        GetIterator(): SerializedProperty
        /** Find serialized property by name.
         */
        FindProperty(propertyPath: string): SerializedProperty
        ApplyModifiedProperties(): boolean
        SetIsDifferentCacheDirty(): void
        Update(): void
        UpdateIfRequiredOrScript(): boolean
        ApplyModifiedPropertiesWithoutUndo(): boolean
        /** Copies a value from a SerializedProperty to the corresponding serialized property on the serialized object.
         */
        CopyFromSerializedProperty(prop: SerializedProperty): void
        /** Copies a changed value from a SerializedProperty to the corresponding serialized property on the serialized object.
         */
        CopyFromSerializedPropertyIfDifferent(prop: SerializedProperty): boolean
        /** The inspected object (Read Only).
         */
        readonly targetObject: Object1
        /** The inspected objects (Read Only).
         */
        readonly targetObjects: Array<Object1>
        /** The context used to store and resolve ExposedReference types. This is set by the SerializedObject constructor.
         */
        readonly context: Object1
        /** Is true when the SerializedObject has a modified property that has not been applied.
         */
        readonly hasModifiedProperties: boolean
        /** Does the serialized object represents multiple objects due to multi-object editing? (Read Only)
         */
        readonly isEditingMultipleObjects: boolean
        /** Defines the maximum size beyond which arrays cannot be edited when multiple objects are selected.
         */
        maxArraySizeForMultiEditing: number
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Object as Object1, Color, AnimationCurve, Vector2, Vector3, Vector4, Vector2Int, Vector3Int, Quaternion, Rect, RectInt, Bounds, BoundsInt } from "UnityEngine";
    import { IEnumerator } from "System.Collections";
    /** SerializedProperty and SerializedObject are classes for editing properties on objects in a completely generic way that automatically handles undo and styling UI for Prefabs.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class SerializedProperty extends Object {
        Copy(): SerializedProperty
        /** Retrieves the SerializedProperty at a relative path to the current property.
         */
        FindPropertyRelative(relativePropertyPath: string): SerializedProperty
        GetEnumerator(): IEnumerator
        /** Returns the element at the specified index in the array.
         */
        GetArrayElementAtIndex(index: number): SerializedProperty
        /** Move to next visible property.
         */
        NextVisible(enterChildren: boolean): boolean
        ClearArray(): void
        Dispose(): void
        /** Move to next property.
         */
        Next(enterChildren: boolean): boolean
        Reset(): void
        CountRemaining(): number
        CountInProperty(): number
        DuplicateCommand(): boolean
        DeleteCommand(): boolean
        /** Retrieves the SerializedProperty that defines the end range of this property.
         */
        GetEndProperty(includeInvisible: boolean): SerializedProperty
        GetEndProperty(): SerializedProperty
        /** Insert an empty element at the specified index in the array.
         */
        InsertArrayElementAtIndex(index: number): void
        /** Delete the element at the specified index in the array.
         */
        DeleteArrayElementAtIndex(index: number): void
        /** Move an array element from srcIndex to dstIndex.
         */
        MoveArrayElement(srcIndex: number, dstIndex: number): boolean
        /** Returns the element at the specified index in the fixed buffer.
         */
        GetFixedBufferElementAtIndex(index: number): SerializedProperty
        /** See if contained serialized properties are equal.
         */
        static EqualContents(x: SerializedProperty, y: SerializedProperty): boolean
        /** Compares the data for two SerializedProperties. This method ignores paths and SerializedObjects.
         */
        static DataEquals(x: SerializedProperty, y: SerializedProperty): boolean
        protected constructor()
        /** SerializedObject this property belongs to (Read Only).
         */
        readonly serializedObject: SerializedObject
        /** A reference to another Object in the Scene. This reference is resolved in the context of the SerializedObject containing the SerializedProperty.
         */
        exposedReferenceValue: Object1
        /** Does this property represent multiple different values due to multi-object editing? (Read Only)
         */
        readonly hasMultipleDifferentValues: boolean
        /** Nice display name of the property. (Read Only)
         */
        readonly displayName: string
        /** Name of the property. (Read Only)
         */
        readonly name: string
        /** Type name of the property. (Read Only)
         */
        readonly type: string
        /** Type name of the element in an array property. (Read Only)
         */
        readonly arrayElementType: string
        /** Tooltip of the property. (Read Only)
         */
        readonly tooltip: string
        /** Nesting depth of the property. (Read Only)
         */
        readonly depth: number
        /** Full path of the property. (Read Only)
         */
        readonly propertyPath: string
        /** Is this property editable? (Read Only)
         */
        readonly editable: boolean
        readonly isAnimated: boolean
        /** Is this property expanded in the inspector?
         */
        isExpanded: boolean
        /** Does it have child properties? (Read Only)
         */
        readonly hasChildren: boolean
        /** Does it have visible child properties? (Read Only)
         */
        readonly hasVisibleChildren: boolean
        /** Is property part of a Prefab instance? (Read Only)
         */
        readonly isInstantiatedPrefab: boolean
        /** Allows you to check whether a property's value is overriden (i.e. different to the Prefab it belongs to).
         */
        prefabOverride: boolean
        /** Allows you to check whether his property is a PrefabUtility.IsDefaultOverride|default override.

Certain properties on Prefab instances are default overrides.

See PrefabUtility.IsDefaultOverride for more information.
         */
        readonly isDefaultOverride: boolean
        /** Type of this property (Read Only).
         */
        readonly propertyType: SerializedPropertyType
        /** Value of an integer property.
         */
        intValue: number
        /** Value of a integer property as a long.
         */
        longValue: number
        /** Value of a boolean property.
         */
        boolValue: boolean
        /** Value of a float property.
         */
        floatValue: number
        /** Value of a float property as a double.
         */
        doubleValue: number
        /** Value of a string property.
         */
        stringValue: string
        /** Value of a color property.
         */
        colorValue: Color
        /** Value of a animation curve property.
         */
        animationCurveValue: AnimationCurve
        /** Value of an object reference property.
         */
        objectReferenceValue: Object1
        managedReferenceValue: Object
        /** String corresponding to the value of the managed reference object (dynamic) full type string.
         */
        readonly managedReferenceFullTypename: string
        /** String corresponding to the value of the managed reference field full type string.
         */
        readonly managedReferenceFieldTypename: string
        objectReferenceInstanceIDValue: number
        /** Enum index of an enum property.
         */
        enumValueIndex: number
        /** Names of enumeration of an enum property.
         */
        readonly enumNames: Array<string>
        /** Display-friendly names of enumeration of an enum property.
         */
        readonly enumDisplayNames: Array<string>
        /** Value of a 2D vector property.
         */
        vector2Value: Vector2
        /** Value of a 3D vector property.
         */
        vector3Value: Vector3
        /** Value of a 4D vector property.
         */
        vector4Value: Vector4
        /** Value of a 2D integer vector property.
         */
        vector2IntValue: Vector2Int
        /** Value of a 3D integer vector property.
         */
        vector3IntValue: Vector3Int
        /** Value of a quaternion property.
         */
        quaternionValue: Quaternion
        /** Value of a rectangle property.
         */
        rectValue: Rect
        /** Value of a rectangle with integer values property.
         */
        rectIntValue: RectInt
        /** Value of bounds property.
         */
        boundsValue: Bounds
        /** Value of bounds with integer values property.
         */
        boundsIntValue: BoundsInt
        /** Is this property an array? (Read Only)
         */
        readonly isArray: boolean
        /** The number of elements in the array. If the SerializedObject contains multiple objects it will return the smallest number of elements. So it is always possible to iterate through the SerializedObject and only get properties found in all objects.
         */
        arraySize: number
        /** Is this property a fixed buffer? (Read Only)
         */
        readonly isFixedBuffer: boolean
        /** The number of elements in the fixed buffer. (Read Only)
         */
        readonly fixedBufferSize: number
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Enum } from "System";
    /** Type of a SerializedProperty.
     */
    enum SerializedPropertyType {
        /** Integer property.
         */
        Integer = 0,
        /** Boolean property.
         */
        Boolean = 1,
        /** Float property.
         */
        Float = 2,
        /** String property.
         */
        String = 3,
        /** Color property.
         */
        Color = 4,
        /** Reference to another object.
         */
        ObjectReference = 5,
        /** LayerMask property.
         */
        LayerMask = 6,
        /** Enumeration property.
         */
        Enum = 7,
        /** 2D vector property.
         */
        Vector2 = 8,
        /** 3D vector property.
         */
        Vector3 = 9,
        /** 4D vector property.
         */
        Vector4 = 10,
        /** Rectangle property.
         */
        Rect = 11,
        /** Array size property.
         */
        ArraySize = 12,
        /** Character property.
         */
        Character = 13,
        /** AnimationCurve property.
         */
        AnimationCurve = 14,
        /** Bounds property.
         */
        Bounds = 15,
        /** Gradient property.
         */
        Gradient = 16,
        /** Quaternion property.
         */
        Quaternion = 17,
        /** A reference to another Object in the Scene. This is done via an ExposedReference type and resolves to a reference to an Object that exists in the context of the SerializedObject containing the SerializedProperty.
         */
        ExposedReference = 18,
        /** Fixed buffer size property.
         */
        FixedBufferSize = 19,
        /** 2D integer vector property.
         */
        Vector2Int = 20,
        /** 3D integer vector property.
         */
        Vector3Int = 21,
        /** Rectangle with Integer values property.
         */
        RectInt = 22,
        /** Bounds with Integer values property.
         */
        BoundsInt = 23,
        /** Managed reference property.
         */
        ManagedReference = 24,
        Generic = -1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType, Array, Enum } from "System";
    /** Provide various options to control the behavior of BuildPipeline.BuildPlayer.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class BuildPlayerOptions extends ValueType {
        constructor()
        /** The Scenes to be included in the build. If empty, the currently open Scene will be built. Paths are relative to the project folder (AssetsMyLevelsMyScene.unity).
         */
        scenes: Array<string>
        /** The path where the application will be built.
         */
        locationPathName: string
        /** The path to an manifest file describing all of the asset bundles used in the build (optional).
         */
        assetBundleManifestPath: string
        /** The BuildTargetGroup to build.
         */
        targetGroup: any
        /** The BuildTarget to build.
         */
        target: BuildTarget
        /** Additional BuildOptions, like whether to run the built player.
         */
        options: any
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Enum } from "System";
    /** Asset Bundle building options.
     */
    enum BuildAssetBundleOptions {
        /** Build assetBundle without any special option.
         */
        None = 0,
        /** Don't compress the data when creating the asset bundle.
         */
        UncompressedAssetBundle = 1,
        /** Includes all dependencies.
         */
        CollectDependencies = 2,
        /** Forces inclusion of the entire asset.
         */
        CompleteAssets = 4,
        /** Do not include type information within the AssetBundle.
         */
        DisableWriteTypeTree = 8,
        /** Builds an asset bundle using a hash for the id of the object stored in the asset bundle.
         */
        DeterministicAssetBundle = 16,
        /** Force rebuild the assetBundles.
         */
        ForceRebuildAssetBundle = 32,
        /** Ignore the type tree changes when doing the incremental build check.
         */
        IgnoreTypeTreeChanges = 64,
        /** Append the hash to the assetBundle name.
         */
        AppendHashToAssetBundleName = 128,
        /** Use chunk-based LZ4 compression when creating the AssetBundle.
         */
        ChunkBasedCompression = 256,
        /** Do not allow the build to succeed if any errors are reporting during it.
         */
        StrictMode = 512,
        /** Do a dry run build.
         */
        DryRunBuild = 1024,
        /** Disables Asset Bundle LoadAsset by file name.
         */
        DisableLoadAssetByFileName = 4096,
        /** Disables Asset Bundle LoadAsset by file name with extension.
         */
        DisableLoadAssetByFileNameWithExtension = 8192,
        /** Removes the Unity Version number in the Archive File & Serialized File headers during the build.
         */
        AssetBundleStripUnityVersion = 32768,
        EnableProtection = 65536,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Enum } from "System";
    /** Target build platform.
     */
    enum BuildTarget {
        /** Build a macOS standalone (Intel 64-bit).
         */
        StandaloneOSX = 2,
        StandaloneOSXUniversal = 3,
        /** Build a macOS Intel 32-bit standalone. (This build target is deprecated)
         */
        StandaloneOSXIntel = 4,
        /** Build a Windows standalone.
         */
        StandaloneWindows = 5,
        /** Build a web player. (This build target is deprecated. Building for web player will no longer be supported in future versions of Unity.)
         */
        WebPlayer = 6,
        /** Build a streamed web player.
         */
        WebPlayerStreamed = 7,
        /** Build an iOS player.
         */
        iOS = 9,
        PS3 = 10,
        XBOX360 = 11,
        /** Build an Android .apk standalone app.
         */
        Android = 13,
        /** Build a Linux standalone.
         */
        StandaloneLinux = 17,
        /** Build a Windows 64-bit standalone.
         */
        StandaloneWindows64 = 19,
        /** WebGL.
         */
        WebGL = 20,
        /** Build an Windows Store Apps player.
         */
        WSAPlayer = 21,
        /** Build a Linux 64-bit standalone.
         */
        StandaloneLinux64 = 24,
        /** Build a Linux universal standalone.
         */
        StandaloneLinuxUniversal = 25,
        WP8Player = 26,
        /** Build a macOS Intel 64-bit standalone. (This build target is deprecated)
         */
        StandaloneOSXIntel64 = 27,
        BlackBerry = 28,
        Tizen = 29,
        PSP2 = 30,
        /** Build a PS4 Standalone.
         */
        PS4 = 31,
        PSM = 32,
        /** Build a Xbox One Standalone.
         */
        XboxOne = 33,
        SamsungTV = 34,
        /** Build to Nintendo 3DS platform.
         */
        N3DS = 35,
        WiiU = 36,
        /** Build to Apple's tvOS platform.
         */
        tvOS = 37,
        /** Build a Nintendo Switch player.
         */
        Switch = 38,
        Lumin = 39,
        /** Build a Stadia standalone.
         */
        Stadia = 40,
        /** Build a CloudRendering standalone.
         */
        CloudRendering = 41,
        NoTarget = -2,
        /** OBSOLETE: Use iOS. Build an iOS player.
         */
        iPhone = -1,
        /** OBSOLETE: Use iOS. Build an iOS player.
         */
        BB10 = -1,
        /** OBSOLETE: Use iOS. Build an iOS player.
         */
        MetroPlayer = -1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, ValueType, Enum, Array } from "System";
    import { Component, Object as Object1, GameObject, PrimitiveType } from "UnityEngine";
    /** Use the DefaultObject to create a new UnityEngine.Object in the editor.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class ObjectFactory extends Object {
        /** Create a new instance of the given type.
         * @param type The type of instance to create.
         */
        static CreateInstance(type: any): Object1
        /** Creates a new component and adds it to the specified GameObject.
         * @param gameObject The GameObject to add the new component to.
         * @param type The type of component to create and add to the GameObject.
         * @returns Returns the component that was created and added to the GameObject. 
         */
        static AddComponent(gameObject: GameObject, type: any): Component
        /** Creates a new GameObject.
         * @param name Name of the GameObject.
         * @param types The optional types to add to the GameObject when created.
         * @param scene Scene where the GameObject should be created.
         * @param hideFlags HideFlags to assign to the GameObject.
         * @returns Returns the GameObject that was created. 
         */
        static CreateGameObject(scene: any, hideFlags: any, name: string, ...types: any[]): GameObject
        /** Creates a new GameObject.
         * @param name Name of the GameObject.
         * @param types The optional types to add to the GameObject when created.
         * @param scene Scene where the GameObject should be created.
         * @param hideFlags HideFlags to assign to the GameObject.
         * @returns Returns the GameObject that was created. 
         */
        static CreateGameObject(name: string, ...types: any[]): GameObject
        /** Creates a GameObject primitive.
         * @param type The type of primitive to create.
         */
        static CreatePrimitive(type: PrimitiveType): GameObject
        static componentWasAdded(op: "add" | "remove", fn: (obj: Component) => void): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "UnityEngine";
    /** Unity Camera Editor.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class CameraEditor extends Editor {
        constructor()
        OnEnable(): void
        OnDestroy(): void
        OnInspectorGUI(): void
        OnOverlayGUI(target: Object, sceneView: SceneView): void
        OnSceneGUI(): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Camera, Vector3, Rect, Matrix4x4 } from "UnityEngine";
    /** Utilities for cameras.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class CameraEditorUtils extends Object {
        static HandleFrustum(c: Camera, cameraEditorTargetIndex: number): void
        /** Draw the frustrum gizmo of a camera.
         * @param camera The camera to use.
         */
        static DrawFrustumGizmo(camera: Camera): void
        /** Calculate the frustrum corners from the sensor physical properties, without taking gate fitting into account.
To get the actual frustum with gate fit adjustment, use CameraEditorUtils.TryGetFrustum.
This method is equivalent to CameraEditorUtils.TryGetFrustum for non-physical cameras.

Corners are calculated in this order: left bottom, left top, right top, right bottom.
         * @param camera Camera to use.
         * @param near The corners of the near plane. (A minimum size of 4 elements is required.)
         * @param far The corners of the far plane. (A minimum size of 4 elements is required.)
         * @param frustumAspect The aspect ratio of the frustrum.
         * @returns Whether the frustrum was calculated. 
         */
        static TryGetSensorGateFrustum(camera: Camera, near: Array<Vector3>, far: Array<Vector3>, frustumAspect: jsb.Out<number>): boolean
        /** Calculate the frustrum corners.

Corners are calculated in this order: left bottom, left top, right top, right bottom.
         * @param camera Camera to use.
         * @param near The corners of the near plane. (A minimum size of 4 elements is required.)
         * @param far The corners of the far plane. (A minimum size of 4 elements is required.)
         * @param frustumAspect The aspect ratio of the frustrum.
         * @returns Whether the frustrum was calculated. 
         */
        static TryGetFrustum(camera: Camera, near: Array<Vector3>, far: Array<Vector3>, frustumAspect: jsb.Out<number>): boolean
        /** Check whether a viewport is valid.
         * @param normalizedViewPortRect Viewport to check.
         * @returns Whether the viewport is valid. 
         */
        static IsViewportRectValidToRender(normalizedViewPortRect: Rect): boolean
        /** Calculate the frustrum aspect ratio of a camera.
         * @param camera Camera to use.
         * @returns The frustrum aspect ratio of the provided camera. 
         */
        static GetFrustumAspectRatio(camera: Camera): number
        /** Calculate the world space position of a point in clip space.

The z component will be used to get the point at the distance z from the viewer.
         * @param clipToWorld Clip to world matrix to use.
         * @param viewPositionWS The viewer's position in world space.
         * @param positionCS The position in clip space.
         * @returns The corresponding world space position. 
         */
        static PerspectiveClipToWorld(clipToWorld: Matrix4x4, viewPositionWS: Vector3, positionCS: Vector3): Vector3
        /** Calculate the points of the frustrum plane facing the viewer at a specific distance.

The points array will be filled with the calculated points in the following order: left bottom, left top, right top and right bottom.
         * @param clipToWorld Clip space to world space matrix.
         * @param viewPosition View position in world space.
         * @param distance Distance from the view position of the plane.
         * @param points Calculated points.  (A minimum size of 4 elements is required).
         */
        static GetFrustumPlaneAt(clipToWorld: Matrix4x4, viewPosition: Vector3, distance: number, points: Array<Vector3>): void
        /** The aspect ratio of the game view.
         */
        static readonly GameViewAspectRatio: number
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Vector3, Transform } from "UnityEngine";
    /** Editor Transform Utility Class.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class TransformUtils extends Object {
        /** Returns the rotation of a transform as it is shown in the Transform Inspector window.
         * @param t Transform to get the rotation from.
         * @returns Rotation as it is shown in the Transform Inspector window. 
         */
        static GetInspectorRotation(t: Transform): Vector3
        /** Sets the rotation of a transform as it would be set by the Transform Inspector window.
         * @param t Transform to set the rotation on.
         * @param r Rotation as it would be set by the Transform Inspector window.
         */
        static SetInspectorRotation(t: Transform, r: Vector3): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Utility functions for working with JSON data and engine objects.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class EditorJsonUtility extends Object {
        /** Generate a JSON representation of an object.
         * @param obj The object to convert to JSON form.
         * @param prettyPrint If true, format the output for readability. If false, format the output for minimum size. Default is false.
         * @returns The object's data in JSON format. 
         */
        static ToJson(obj: Object, prettyPrint: boolean): string
        /** Generate a JSON representation of an object.
         * @param obj The object to convert to JSON form.
         * @param prettyPrint If true, format the output for readability. If false, format the output for minimum size. Default is false.
         * @returns The object's data in JSON format. 
         */
        static ToJson(obj: Object): string
        /** Overwrite data in an object by reading from its JSON representation.
         * @param json The JSON representation of the object.
         * @param objectToOverwrite The object to overwrite.
         */
        static FromJsonOverwrite(json: string, objectToOverwrite: Object): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Enum, Array } from "System";
    import { GameObject, Transform } from "UnityEngine";
    /** GameObject utility functions.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class GameObjectUtility extends Object {
        constructor()
        /** Gets the StaticEditorFlags of the GameObject specified.
         * @param go The GameObject whose flags you are interested in.
         * @returns The static editor flags of the GameObject specified. 
         */
        static GetStaticEditorFlags(go: GameObject): any
        /** Sets the StaticEditorFlags of the specified GameObject.
         * @param go The GameObject whose Static Editor Flags you want to set.
         * @param flags The StaticEditorFlags to set on the GameObject.
         */
        static SetStaticEditorFlags(go: GameObject, flags: any): void
        /** Returns true if the passed in StaticEditorFlags are set on the GameObject specified.
         * @param go The GameObject to check.
         * @param flags The flags you want to check.
         * @returns Whether the GameObject's static flags match the flags specified. 
         */
        static AreStaticEditorFlagsSet(go: GameObject, flags: any): boolean
        /** Get the navmesh area index for the GameObject.
         * @param go The GameObject to query.
         * @returns NavMesh area index. 
         */
        static GetNavMeshArea(go: GameObject): number
        /** Set the navmesh area for the gameobject.
         * @param go GameObject to modify.
         * @param areaIndex NavMesh area index to set.
         */
        static SetNavMeshArea(go: GameObject, areaIndex: number): void
        /** Get the navmesh area index from the area name.
         * @param name NavMesh area name to query.
         * @returns The NavMesh area index. If there is no NavMesh area with the requested name, the return value is -1. 
         */
        static GetNavMeshAreaFromName(name: string): number
        static GetNavMeshAreaNames(): Array<string>
        /** You can use this method before instantiating a new sibling, or before parenting one GameObject to another, to ensure the new child GameObject has a unique name compared to its siblings in the hierarchy.
         * @param parent Target parent for a new GameObject. Null means root level.
         * @param name Requested name for a new GameObject.
         * @returns Unique name for a new GameObject. 
         */
        static GetUniqueNameForSibling(parent: Transform, name: string): string
        /** You can use this method after parenting one GameObject to another to ensure the child GameObject has a unique name compared to its siblings in the hierarchy.
         * @param self The GameObject whose name you want to ensure is unique.
         */
        static EnsureUniqueNameForSibling(self: GameObject): void
        /** Sets the parent and gives the child the same layer and position.
         * @param child The GameObject that should have a new parent set.
         * @param parent The GameObject that the child should get as a parent and have position and layer copied from. If null, this function does nothing.
         */
        static SetParentAndAlign(child: GameObject, parent: GameObject): void
        /** Gets the number of MonoBehaviours with a missing script for the given GameObject.
         * @param go GameObject to query.
         * @returns The number of MonoBehaviours with a missing script. 
         */
        static GetMonoBehavioursWithMissingScriptCount(go: GameObject): number
        /** Removes the MonoBehaviours with a missing script from the given GameObject.
         * @param go The GameObject to remove MonoBehaviours with a missing script from.
         * @returns The number of MonoBehaviours with a missing script that were removed. 
         */
        static RemoveMonoBehavioursWithMissingScript(go: GameObject): number
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Stores and accesses Unity editor preferences.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class EditorPrefs extends Object {
        /** Sets the value of the preference identified by key as an integer.
         * @param key Name of key to write integer to.
         * @param value Value of the integer to write into the storage.
         */
        static SetInt(key: string, value: number): void
        /** Returns the value corresponding to key in the preference file if it exists.
         * @param key Name of key to read integer from.
         * @param defaultValue Integer value to return if the key is not in the storage.
         * @returns The value stored in the preference file. 
         */
        static GetInt(key: string, defaultValue: number): number
        /** Returns the value corresponding to key in the preference file if it exists.
         * @param key Name of key to read integer from.
         * @param defaultValue Integer value to return if the key is not in the storage.
         * @returns The value stored in the preference file. 
         */
        static GetInt(key: string): number
        /** Sets the float value of the preference identified by key.
         * @param key Name of key to write float into.
         * @param value Float value to write into the storage.
         */
        static SetFloat(key: string, value: number): void
        /** Returns the float value corresponding to key if it exists in the preference file.
         * @param key Name of key to read float from.
         * @param defaultValue Float value to return if the key is not in the storage.
         * @returns The float value stored in the preference file or the defaultValue id the
        requested float does not exist. 
         */
        static GetFloat(key: string, defaultValue: number): number
        /** Returns the float value corresponding to key if it exists in the preference file.
         * @param key Name of key to read float from.
         * @param defaultValue Float value to return if the key is not in the storage.
         * @returns The float value stored in the preference file or the defaultValue id the
        requested float does not exist. 
         */
        static GetFloat(key: string): number
        /** Sets the value of the preference identified by key. Note that EditorPrefs does not support null strings and will store an empty string instead.
         */
        static SetString(key: string, value: string): void
        /** Returns the value corresponding to key in the preference file if it exists.
         */
        static GetString(key: string, defaultValue: string): string
        /** Returns the value corresponding to key in the preference file if it exists.
         */
        static GetString(key: string): string
        /** Sets the value of the preference identified by key.
         */
        static SetBool(key: string, value: boolean): void
        /** Returns the value corresponding to key in the preference file if it exists.
         */
        static GetBool(key: string, defaultValue: boolean): boolean
        /** Returns the value corresponding to key in the preference file if it exists.
         */
        static GetBool(key: string): boolean
        /** Returns true if key exists in the preferences file.
         * @param key Name of key to check for.
         * @returns The existence or not of the key. 
         */
        static HasKey(key: string): boolean
        /** Removes key and its corresponding value from the preferences.
         */
        static DeleteKey(key: string): void
        static DeleteAll(): void
        protected constructor()
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Enum, Array } from "System";
    import { Color, Matrix4x4, Camera, Vector3, Quaternion, EventType, Vector2, Transform, Texture2D, Rect, GUIStyle, GUIContent, Texture } from "UnityEngine";
    /** Custom 3D GUI controls and drawing in the Scene view.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class Handles extends Object {
        /** Draw a line going through the list of points.
         */
        static DrawPolyLine(...points: Vector3[]): void
        /** Draw a line from p1 to p2.
         */
        static DrawLine(p1: Vector3, p2: Vector3): void
        /** Draw a list of indexed line segments.
         * @param points A list of points.
         * @param segmentIndices A list of pairs of indices to the start and end points of the line segments.
         */
        static DrawLines(points: Array<Vector3>, segmentIndices: Array<number>): void
        /** Draw a list of line segments.
         * @param lineSegments A list of pairs of points that represent the start and end of line segments.
         */
        static DrawLines(lineSegments: Array<Vector3>): void
        /** Draw a dotted line from p1 to p2.
         * @param p1 The start point.
         * @param p2 The end point.
         * @param screenSpaceSize The size in pixels for the lengths of the line segments and the gaps between them.
         */
        static DrawDottedLine(p1: Vector3, p2: Vector3, screenSpaceSize: number): void
        /** Draw a list of indexed dotted line segments.
         * @param points A list of points.
         * @param segmentIndices A list of pairs of indices to the start and end points of the line segments.
         * @param screenSpaceSize The size in pixels for the lengths of the line segments and the gaps between them.
         */
        static DrawDottedLines(points: Array<Vector3>, segmentIndices: Array<number>, screenSpaceSize: number): void
        /** Draw a list of dotted line segments.
         * @param lineSegments A list of pairs of points that represent the start and end of line segments.
         * @param screenSpaceSize The size in pixels for the lengths of the line segments and the gaps between them.
         */
        static DrawDottedLines(lineSegments: Array<Vector3>, screenSpaceSize: number): void
        /** Draw a wireframe box with center and size.
         */
        static DrawWireCube(center: Vector3, size: Vector3): void
        static ShouldRenderGizmos(): boolean
        static DrawGizmos(camera: Camera): void
        /** Make a 3D disc that can be dragged with the mouse.
         * @param id Control id of the handle.
         * @param rotation The rotation of the disc.
         * @param position The center of the disc.
         * @param axis The axis to rotate around.
         * @param size The size of the disc in world space.
         * @param cutoffPlane If true, only the front-facing half of the circle is draw / draggable. This is useful when you have many overlapping rotation axes (like in the default rotate tool) to avoid clutter.
         * @param snap The grid size to snap to.
         * @returns The new rotation value modified by the user's interaction with the handle. If the user has not moved the handle, it will return the same value as you passed into the function. 
         */
        static Disc(id: number, rotation: Quaternion, position: Vector3, axis: Vector3, size: number, cutoffPlane: boolean, snap: number): Quaternion
        /** Make a 3D disc that can be dragged with the mouse.
         * @param id Control id of the handle.
         * @param rotation The rotation of the disc.
         * @param position The center of the disc.
         * @param axis The axis to rotate around.
         * @param size The size of the disc in world space.
         * @param cutoffPlane If true, only the front-facing half of the circle is draw / draggable. This is useful when you have many overlapping rotation axes (like in the default rotate tool) to avoid clutter.
         * @param snap The grid size to snap to.
         * @returns The new rotation value modified by the user's interaction with the handle. If the user has not moved the handle, it will return the same value as you passed into the function. 
         */
        static Disc(rotation: Quaternion, position: Vector3, axis: Vector3, size: number, cutoffPlane: boolean, snap: number): Quaternion
        /** Make an unconstrained rotation handle.
         * @param id Control id of the handle.
         * @param rotation Orientation of the handle.
         * @param position Center of the handle in 3D space.
         * @param size The size of the handle.

Note: Use HandleUtility.GetHandleSize where you might want to have constant screen-sized handles.
         * @returns The new rotation value modified by the user's interaction with the handle. If the user has not moved the handle, it will return the same value as you passed into the function. 
         */
        static FreeRotateHandle(id: number, rotation: Quaternion, position: Vector3, size: number): Quaternion
        /** Make an unconstrained rotation handle.
         * @param id Control id of the handle.
         * @param rotation Orientation of the handle.
         * @param position Center of the handle in 3D space.
         * @param size The size of the handle.

Note: Use HandleUtility.GetHandleSize where you might want to have constant screen-sized handles.
         * @returns The new rotation value modified by the user's interaction with the handle. If the user has not moved the handle, it will return the same value as you passed into the function. 
         */
        static FreeRotateHandle(rotation: Quaternion, position: Vector3, size: number): Quaternion
        static Slider(controlID: number, position: Vector3, offset: Vector3, direction: Vector3, size: number, capFunction: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void, snap: number): Vector3
        static Slider(controlID: number, position: Vector3, direction: Vector3, size: number, capFunction: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void, snap: number): Vector3
        static Slider(position: Vector3, direction: Vector3, size: number, capFunction: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void, snap: number): Vector3
        /** Make a 3D slider that moves along one axis.
         * @param position The position of the current point in the space of Handles.matrix.
         * @param direction The direction axis of the slider in the space of Handles.matrix.
         * @param size The size of the handle in the space of Handles.matrix. Use HandleUtility.GetHandleSize if you want a constant screen-space size.
         * @param snap The snap increment. See Handles.SnapValue.
         * @param capFunction The function to call for doing the actual drawing. By default it is Handles.ArrowHandleCap, but any function that has the same signature can be used.
         * @returns The new value modified by the user's interaction with the handle. If the user has not moved the handle, it will return the position value passed into the function. 
         */
        static Slider(position: Vector3, direction: Vector3): Vector3
        static FreeMoveHandle(controlID: number, position: Vector3, rotation: Quaternion, size: number, snap: Vector3, capFunction: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void): Vector3
        static FreeMoveHandle(position: Vector3, rotation: Quaternion, size: number, snap: Vector3, capFunction: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void): Vector3
        static ScaleValueHandle(controlID: number, value: number, position: Vector3, rotation: Quaternion, size: number, capFunction: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void, snap: number): number
        static ScaleValueHandle(value: number, position: Vector3, rotation: Quaternion, size: number, capFunction: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void, snap: number): number
        static Button(position: Vector3, direction: Quaternion, size: number, pickSize: number, capFunction: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void): boolean
        /** Draw a cube handle. Pass this into handle functions.
         * @param controlID The control ID for the handle.
         * @param position The position of the handle in the space of Handles.matrix.
         * @param rotation The rotation of the handle in the space of Handles.matrix.
         * @param size The size of the handle in the space of Handles.matrix. Use HandleUtility.GetHandleSize if you want a constant screen-space size.
         * @param eventType Event type for the handle to act upon. By design it handles EventType.Layout and EventType.Repaint events.
         */
        static CubeHandleCap(controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType): void
        /** Draw a sphere handle. Pass this into handle functions.
         * @param controlID The control ID for the handle.
         * @param position The position of the handle in the space of Handles.matrix.
         * @param rotation The rotation of the handle in the space of Handles.matrix.
         * @param eventType Event type for the handle to act upon. By design it handles EventType.Layout and EventType.Repaint events.
         * @param size The size of the handle in the space of Handles.matrix. Use HandleUtility.GetHandleSize if you want a constant screen-space size.
         */
        static SphereHandleCap(controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType): void
        /** Draw a cone handle. Pass this into handle functions.
         * @param controlID The control ID for the handle.
         * @param position The position of the handle in the space of Handles.matrix.
         * @param rotation The rotation of the handle in the space of Handles.matrix.
         * @param size The size of the handle in the space of Handles.matrix. Use HandleUtility.GetHandleSize if you want a constant screen-space size.
         * @param eventType Event type for the handle to act upon. By design it handles EventType.Layout and EventType.Repaint events.
         */
        static ConeHandleCap(controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType): void
        /** Draw a cylinder handle. Pass this into handle functions.
         * @param controlID The control ID for the handle.
         * @param position The position of the handle in the space of Handles.matrix.
         * @param rotation The rotation of the handle in the space of Handles.matrix.
         * @param size The size of the handle in the space of Handles.matrix. Use HandleUtility.GetHandleSize if you want a constant screen-space size.
         * @param eventType Event type for the handle to act upon. By design it handles EventType.Layout and EventType.Repaint events.
         */
        static CylinderHandleCap(controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType): void
        /** Draw a rectangle handle. Pass this into handle functions.
         * @param controlID The control ID for the handle.
         * @param position The position of the handle in the space of Handles.matrix.
         * @param rotation The rotation of the handle in the space of Handles.matrix.
         * @param size The size of the handle in the space of Handles.matrix. Use HandleUtility.GetHandleSize if you want a constant screen-space size.
         * @param eventType Event type for the handle to act upon. By design it handles EventType.Layout and EventType.Repaint events.
         */
        static RectangleHandleCap(controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType): void
        /** Draw a dot handle. Pass this into handle functions.
         * @param controlID The control ID for the handle.
         * @param position The position of the handle in the space of Handles.matrix.
         * @param rotation The rotation of the handle in the space of Handles.matrix.
         * @param size The size of the handle in the space of Handles.matrix. Use HandleUtility.GetHandleSize if you want a constant screen-space size.
         * @param eventType Event type for the handle to act upon. By design it handles EventType.Layout and EventType.Repaint events.
         */
        static DotHandleCap(controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType): void
        /** Draw a circle handle. Pass this into handle functions.
         * @param controlID The control ID for the handle.
         * @param position The position of the handle in the space of Handles.matrix.
         * @param rotation The rotation of the handle in the space of Handles.matrix.
         * @param size The size of the handle in the space of Handles.matrix. Use HandleUtility.GetHandleSize if you want a constant screen-space size.
         * @param eventType Event type for the handle to act upon. By design it handles EventType.Layout and EventType.Repaint events.
         */
        static CircleHandleCap(controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType): void
        /** Draw an arrow like those used by the move tool.
         * @param controlID The control ID for the handle.
         * @param position The position of the handle in the space of Handles.matrix.
         * @param rotation The rotation of the handle in the space of Handles.matrix.
         * @param size The size of the handle in the space of Handles.matrix. Use HandleUtility.GetHandleSize if you want a constant screen-space size.
         * @param eventType Event type for the handle to act upon. By design it handles EventType.Layout and EventType.Repaint events.
         */
        static ArrowHandleCap(controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType): void
        /** Draw a camera facing selection frame.
         */
        static DrawSelectionFrame(controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType): void
        /** Make a position handle.
         * @param position Center of the handle in 3D space.
         * @param rotation Orientation of the handle in 3D space.
         * @returns The new value modified by the user's interaction with the handle. If the user has not moved the handle, it will return the same value as you passed into the function. 
         */
        static PositionHandle(position: Vector3, rotation: Quaternion): Vector3
        /** Make a Scene view rotation handle.
         * @param rotation Orientation of the handle.
         * @param position Center of the handle in 3D space.
         * @returns The new rotation value modified by the user's interaction with the handle. If the user has not moved the handle, it will return the same value as you passed into the function. 
         */
        static RotationHandle(rotation: Quaternion, position: Vector3): Quaternion
        /** Make a Scene view scale handle.
         * @param scale Scale to modify.
         * @param position The position of the handle.
         * @param rotation The rotation of the handle.
         * @param size Allows you to scale the size of the handle on-scren.
         * @returns The new value modified by the user's interaction with the handle. If the user has not moved the handle, it will return the same value as you passed into the function. 
         */
        static ScaleHandle(scale: Vector3, position: Vector3, rotation: Quaternion, size: number): Vector3
        /** Make a Scene view radius handle.
         * @param rotation Orientation of the handle.
         * @param position Center of the handle in 3D space.
         * @param radius Radius to modify.
         * @param handlesOnly Whether to omit the circular outline of the radius and only draw the point handles.
         * @returns The new value modified by the user's interaction with the handle. If the user has not moved the handle, it will return the same value as you passed into the function.

Note: Use HandleUtility.GetHandleSize where you might want to have constant screen-sized handles. 
         */
        static RadiusHandle(rotation: Quaternion, position: Vector3, radius: number, handlesOnly: boolean): number
        /** Make a Scene view radius handle.
         * @param rotation Orientation of the handle.
         * @param position Center of the handle in 3D space.
         * @param radius Radius to modify.
         * @param handlesOnly Whether to omit the circular outline of the radius and only draw the point handles.
         * @returns The new value modified by the user's interaction with the handle. If the user has not moved the handle, it will return the same value as you passed into the function.

Note: Use HandleUtility.GetHandleSize where you might want to have constant screen-sized handles. 
         */
        static RadiusHandle(rotation: Quaternion, position: Vector3, radius: number): number
        static Slider2D(id: number, handlePos: Vector3, offset: Vector3, handleDir: Vector3, slideDir1: Vector3, slideDir2: Vector3, handleSize: number, capFunction: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void, snap: Vector2, drawHelper: boolean): Vector3
        static Slider2D(id: number, handlePos: Vector3, offset: Vector3, handleDir: Vector3, slideDir1: Vector3, slideDir2: Vector3, handleSize: number, capFunction: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void, snap: Vector2): Vector3
        static Slider2D(id: number, handlePos: Vector3, handleDir: Vector3, slideDir1: Vector3, slideDir2: Vector3, handleSize: number, capFunction: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void, snap: Vector2, drawHelper: boolean): Vector3
        static Slider2D(handlePos: Vector3, handleDir: Vector3, slideDir1: Vector3, slideDir2: Vector3, handleSize: number, capFunction: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void, snap: Vector2, drawHelper: boolean): Vector3
        static Slider2D(id: number, handlePos: Vector3, handleDir: Vector3, slideDir1: Vector3, slideDir2: Vector3, handleSize: number, capFunction: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void, snap: Vector2): Vector3
        static Slider2D(handlePos: Vector3, handleDir: Vector3, slideDir1: Vector3, slideDir2: Vector3, handleSize: number, capFunction: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void, snap: number, drawHelper: boolean): Vector3
        static Slider2D(handlePos: Vector3, handleDir: Vector3, slideDir1: Vector3, slideDir2: Vector3, handleSize: number, capFunction: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void, snap: Vector2): Vector3
        static Slider2D(handlePos: Vector3, handleDir: Vector3, slideDir1: Vector3, slideDir2: Vector3, handleSize: number, capFunction: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void, snap: number): Vector3
        /** Make a directional scale slider.
         * @param scale The value the user can modify.
         * @param position The position of the handle in the space of Handles.matrix.
         * @param direction The direction of the handle in the space of Handles.matrix.
         * @param rotation The rotation of the handle in the space of Handles.matrix.
         * @param size The size of the handle in the space of Handles.matrix. Use HandleUtility.GetHandleSize if you want a constant screen-space size.
         * @param snap The snap increment. See Handles.SnapValue.
         * @returns The new value modified by the user's interaction with the handle. If the user has not moved the handle, it will return the same value as you passed into the function. 
         */
        static ScaleSlider(scale: number, position: Vector3, direction: Vector3, rotation: Quaternion, size: number, snap: number): number
        /** Rounds value to the closest multiple of snap if snapping is active. Note that snap can only be positive.
         * @param value The value to snap.
         * @param snap The increment to snap to.
         * @returns If snapping is active, rounds value to the closest multiple of snap (snap can only be positive). 
         */
        static SnapValue(value: number, snap: number): number
        /** Rounds value to the closest multiple of snap if snapping is active. Note that snap can only be positive.
         * @param value The value to snap.
         * @param snap The increment to snap to.
         * @returns If snapping is active, rounds value to the closest multiple of snap (snap can only be positive). 
         */
        static SnapValue(value: Vector2, snap: Vector2): Vector2
        /** Rounds value to the closest multiple of snap if snapping is active. Note that snap can only be positive.
         * @param value The value to snap.
         * @param snap The increment to snap to.
         * @returns If snapping is active, rounds value to the closest multiple of snap (snap can only be positive). 
         */
        static SnapValue(value: Vector3, snap: Vector3): Vector3
        /** Rounds each Transform.position to the closest multiple of EditorSnap.move.
         * @param transforms The transforms to snap.
         * @param axis The axes on which to apply snapping.
         */
        static SnapToGrid(transforms: Array<Transform>, axis: any): void
        static SelectionFrame(controlID: number, position: Vector3, rotation: Quaternion, size: number): void
        /** Draw anti-aliased line specified with point array and width.
         * @param lineTex The AA texture used for rendering.
         * @param width The width of the line.
         * @param points List of points to build the line from.
         */
        static DrawAAPolyLine(width: number, actualNumberOfPoints: number, ...points: Vector3[]): void
        /** Draw anti-aliased line specified with point array and width.
         * @param lineTex The AA texture used for rendering.
         * @param width The width of the line.
         * @param points List of points to build the line from.
         */
        static DrawAAPolyLine(lineTex: Texture2D, width: number, ...points: Vector3[]): void
        /** Draw anti-aliased line specified with point array and width.
         * @param lineTex The AA texture used for rendering.
         * @param width The width of the line.
         * @param points List of points to build the line from.
         */
        static DrawAAPolyLine(width: number, ...points: Vector3[]): void
        /** Draw anti-aliased line specified with point array and width.
         * @param lineTex The AA texture used for rendering.
         * @param width The width of the line.
         * @param points List of points to build the line from.
         */
        static DrawAAPolyLine(lineTex: Texture2D, ...points: Vector3[]): void
        /** Draw anti-aliased line specified with point array and width.
         * @param lineTex The AA texture used for rendering.
         * @param width The width of the line.
         * @param points List of points to build the line from.
         */
        static DrawAAPolyLine(...points: Vector3[]): void
        /** Draw anti-aliased convex polygon specified with point array.
         * @param points List of points describing the convex polygon.
         */
        static DrawAAConvexPolygon(...points: Vector3[]): void
        /** Draw textured bezier line through start and end points with the given tangents.
         * @param startPosition The start point of the bezier line.
         * @param endPosition The end point of the bezier line.
         * @param startTangent The start tangent of the bezier line.
         * @param endTangent The end tangent of the bezier line.
         * @param color The color to use for the bezier line.
         * @param texture The texture to use for drawing the bezier line.
         * @param width The width of the bezier line.
         */
        static DrawBezier(startPosition: Vector3, endPosition: Vector3, startTangent: Vector3, endTangent: Vector3, color: Color, texture: Texture2D, width: number): void
        /** Draw the outline of a flat disc in 3D space.
         * @param center The center of the disc.
         * @param normal The normal of the disc.
         * @param radius The radius of the disc.
         */
        static DrawWireDisc(center: Vector3, normal: Vector3, radius: number): void
        /** Draw a circular arc in 3D space.
         * @param center The center of the circle.
         * @param normal The normal of the circle.
         * @param from The direction of the point on the circle circumference, relative to the center, where the arc begins.
         * @param angle The angle of the arc, in degrees.
         * @param radius The radius of the circle

Note: Use HandleUtility.GetHandleSize where you might want to have constant screen-sized handles.
         */
        static DrawWireArc(center: Vector3, normal: Vector3, from: Vector3, angle: number, radius: number): void
        static DrawSolidRectangleWithOutline(rectangle: Rect, faceColor: Color, outlineColor: Color): void
        /** Draw a solid outlined rectangle in 3D space.
         * @param verts The 4 vertices of the rectangle in world coordinates.
         * @param faceColor The color of the rectangle's face.
         * @param outlineColor The outline color of the rectangle.
         */
        static DrawSolidRectangleWithOutline(verts: Array<Vector3>, faceColor: Color, outlineColor: Color): void
        /** Draw a solid flat disc in 3D space.
         * @param center The center of the dics.
         * @param normal The normal of the disc.
         * @param radius The radius of the dics

Note: Use HandleUtility.GetHandleSize where you might want to have constant screen-sized handles.
         */
        static DrawSolidDisc(center: Vector3, normal: Vector3, radius: number): void
        /** Draw a circular sector (pie piece) in 3D space.
         * @param center The center of the circle.
         * @param normal The normal of the circle.
         * @param from The direction of the point on the circumference, relative to the center, where the sector begins.
         * @param angle The angle of the sector, in degrees.
         * @param radius The radius of the circle

Note: Use HandleUtility.GetHandleSize where you might want to have constant screen-sized handles.
         */
        static DrawSolidArc(center: Vector3, normal: Vector3, from: Vector3, angle: number, radius: number): void
        /** Make a text label positioned in 3D space.
         * @param position Position in 3D space as seen from the current handle camera.
         * @param text Text to display on the label.
         * @param image Texture to display on the label.
         * @param content Text, image and tooltip for this label.
         * @param style The style to use. If left out, the label style from the current GUISkin is used.

Note: Use HandleUtility.GetHandleSize where you might want to have constant screen-sized handles.
         */
        static Label(position: Vector3, text: string, style: GUIStyle): void
        /** Make a text label positioned in 3D space.
         * @param position Position in 3D space as seen from the current handle camera.
         * @param text Text to display on the label.
         * @param image Texture to display on the label.
         * @param content Text, image and tooltip for this label.
         * @param style The style to use. If left out, the label style from the current GUISkin is used.

Note: Use HandleUtility.GetHandleSize where you might want to have constant screen-sized handles.
         */
        static Label(position: Vector3, content: GUIContent, style: GUIStyle): void
        /** Make a text label positioned in 3D space.
         * @param position Position in 3D space as seen from the current handle camera.
         * @param text Text to display on the label.
         * @param image Texture to display on the label.
         * @param content Text, image and tooltip for this label.
         * @param style The style to use. If left out, the label style from the current GUISkin is used.

Note: Use HandleUtility.GetHandleSize where you might want to have constant screen-sized handles.
         */
        static Label(position: Vector3, text: string): void
        /** Make a text label positioned in 3D space.
         * @param position Position in 3D space as seen from the current handle camera.
         * @param text Text to display on the label.
         * @param image Texture to display on the label.
         * @param content Text, image and tooltip for this label.
         * @param style The style to use. If left out, the label style from the current GUISkin is used.

Note: Use HandleUtility.GetHandleSize where you might want to have constant screen-sized handles.
         */
        static Label(position: Vector3, image: Texture): void
        /** Make a text label positioned in 3D space.
         * @param position Position in 3D space as seen from the current handle camera.
         * @param text Text to display on the label.
         * @param image Texture to display on the label.
         * @param content Text, image and tooltip for this label.
         * @param style The style to use. If left out, the label style from the current GUISkin is used.

Note: Use HandleUtility.GetHandleSize where you might want to have constant screen-sized handles.
         */
        static Label(position: Vector3, content: GUIContent): void
        static GetMainGameViewSize(): Vector2
        /** Clears the camera.
         * @param position Where in the Scene to clear.
         * @param camera The camera to clear.
         */
        static ClearCamera(position: Rect, camera: Camera): void
        /** Draws a camera inside a rectangle.
         * @param position The area to draw the camera within in GUI coordinates.
         * @param camera The camera to draw.
         * @param drawMode How the camera is drawn (textured, wireframe, etc.).
         */
        static DrawCamera(position: Rect, camera: Camera, drawMode: any): void
        /** Draws a camera inside a rectangle.
         * @param position The area to draw the camera within in GUI coordinates.
         * @param camera The camera to draw.
         * @param drawMode How the camera is drawn (textured, wireframe, etc.).
         */
        static DrawCamera(position: Rect, camera: Camera): void
        /** Set the current camera so all Handles and Gizmos are draw with its settings.
         */
        static SetCamera(position: Rect, camera: Camera): void
        /** Set the current camera so all Handles and Gizmos are draw with its settings.
         */
        static SetCamera(camera: Camera): void
        static BeginGUI(): void
        static EndGUI(): void
        /** Retuns an array of points to representing the bezier curve.
         */
        static MakeBezierPoints(startPosition: Vector3, endPosition: Vector3, startTangent: Vector3, endTangent: Vector3, division: number): Array<Vector3>
        static DoPositionHandle(position: Vector3, rotation: Quaternion): Vector3
        static DoRotationHandle(rotation: Quaternion, position: Vector3): Quaternion
        static DoScaleHandle(scale: Vector3, position: Vector3, rotation: Quaternion, size: number): Vector3
        /** Creates a transform handle.
         * @param position Position of the handle.
         * @param rotation Orientation of the handle.
         * @param scale Scale value to modify.
         * @param uniformScale Uniform scale value to modify.
         */
        static TransformHandle(position: jsb.Ref<Vector3>, rotation: jsb.Ref<Quaternion>, scale: jsb.Ref<Vector3>): void
        static TransformHandle(position: jsb.Ref<Vector3>, rotation: Quaternion, scale: jsb.Ref<Vector3>): void
        static TransformHandle(position: Vector3, rotation: jsb.Ref<Quaternion>, scale: jsb.Ref<Vector3>): void
        /** Creates a transform handle.
         * @param position Position of the handle.
         * @param rotation Orientation of the handle.
         * @param scale Scale value to modify.
         * @param uniformScale Uniform scale value to modify.
         */
        static TransformHandle(position: jsb.Ref<Vector3>, rotation: jsb.Ref<Quaternion>, uniformScale: jsb.Ref<number>): void
        static TransformHandle(position: jsb.Ref<Vector3>, rotation: Quaternion, uniformScale: jsb.Ref<number>): void
        static TransformHandle(position: Vector3, rotation: jsb.Ref<Quaternion>, uniformScale: jsb.Ref<number>): void
        /** Creates a transform handle.
         * @param position Position of the handle.
         * @param rotation Orientation of the handle.
         * @param scale Scale value to modify.
         * @param uniformScale Uniform scale value to modify.
         */
        static TransformHandle(position: jsb.Ref<Vector3>, rotation: jsb.Ref<Quaternion>): void
        protected constructor()
        /** Are handles lit?
         */
        static lighting: boolean
        /** Colors of the handles.
         */
        static color: Color
        /** zTest of the handles.
         */
        static zTest: any
        /** Matrix for all handle operations.
         */
        static matrix: Matrix4x4
        /** The inverse of the matrix for all handle operations.
         */
        static readonly inverseMatrix: Matrix4x4
        /** Color to use for handles that manipulates the X coordinate of something.
         */
        static readonly xAxisColor: Color
        /** Color to use for handles that manipulates the Y coordinate of something.
         */
        static readonly yAxisColor: Color
        /** Color to use for handles that manipulates the Z coordinate of something.
         */
        static readonly zAxisColor: Color
        /** Color to use for handles that represent the center of something.
         */
        static readonly centerColor: Color
        /** Color to use for the currently active handle.
         */
        static readonly selectedColor: Color
        /** Color to use to highlight an unselected handle currently under the mouse pointer.
         */
        static readonly preselectionColor: Color
        /** Soft color to use for for general things.
         */
        static readonly secondaryColor: Color
        /** Setup viewport and stuff for a current camera.
         */
        currentCamera: Camera
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Material, Vector3, Vector2, Quaternion, Ray, Rect, GUIContent, GUIStyle, GameObject, Camera } from "UnityEngine";
    /** Helper functions for Scene View style 3D GUI.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class HandleUtility extends Object {
        /** Calculate distance between a point and a Bezier curve.
         */
        static DistancePointBezier(point: Vector3, startPosition: Vector3, endPosition: Vector3, startTangent: Vector3, endTangent: Vector3): number
        /** Map a mouse drag onto a movement along a line in 3D space.
         * @param src The source point of the drag.
         * @param dest The destination point of the drag.
         * @param srcPosition The 3D position the dragged object had at src ray.
         * @param constraintDir 3D direction of constrained movement.
         * @returns The distance travelled along constraintDir. 
         */
        static CalcLineTranslation(src: Vector2, dest: Vector2, srcPosition: Vector3, constraintDir: Vector3): number
        /** Returns the parameter for the projection of the point on the given line.
         */
        static PointOnLineParameter(point: Vector3, linePoint: Vector3, lineDirection: Vector3): number
        /** Project point onto a line.
         */
        static ProjectPointLine(point: Vector3, lineStart: Vector3, lineEnd: Vector3): Vector3
        /** Calculate distance between a point and a line.
         */
        static DistancePointLine(point: Vector3, lineStart: Vector3, lineEnd: Vector3): number
        /** Pixel distance from mouse pointer to line.
         */
        static DistanceToLine(p1: Vector3, p2: Vector3): number
        /** Pixel distance from mouse pointer to camera facing circle.
         */
        static DistanceToCircle(position: Vector3, radius: number): number
        /** Pixel distance from mouse pointer to a rectangle on screen.
         */
        static DistanceToRectangle(position: Vector3, rotation: Quaternion, size: number): number
        /** Distance from a point p in 2d to a line defined by two points a and b.
         */
        static DistancePointToLine(p: Vector2, a: Vector2, b: Vector2): number
        /** Distance from a point p in 2d to a line segment defined by two points a and b.
         */
        static DistancePointToLineSegment(p: Vector2, a: Vector2, b: Vector2): number
        /** Pixel distance from mouse pointer to a 3D disc.
         */
        static DistanceToDisc(center: Vector3, normal: Vector3, radius: number): number
        /** Get the point on an disc (in 3D space) which is closest to the current mouse position.
         */
        static ClosestPointToDisc(center: Vector3, normal: Vector3, radius: number): Vector3
        /** Pixel distance from mouse pointer to a 3D section of a disc.
         */
        static DistanceToArc(center: Vector3, normal: Vector3, from: Vector3, angle: number, radius: number): number
        /** Get the point on an arc (in 3D space) which is closest to the current mouse position.
         */
        static ClosestPointToArc(center: Vector3, normal: Vector3, from: Vector3, angle: number, radius: number): Vector3
        /** Pixel distance from mouse pointer to a polyline.
         */
        static DistanceToPolyLine(...points: Vector3[]): number
        /** Get the point on a polyline (in 3D space) which is closest to the current mouse position.
         */
        static ClosestPointToPolyLine(...vertices: Vector3[]): Vector3
        /** Record a distance measurement from a handle.
         */
        static AddControl(controlId: number, distance: number): void
        /** Add the ID for a default control. This will be picked if nothing else is.
         */
        static AddDefaultControl(controlId: number): void
        /** Get world space size of a manipulator handle at given position.
         * @param position The position of the handle in 3d space.
         * @returns A constant screen-size for the handle, based on the distance between from the supplied handle's position to the camera. 
         */
        static GetHandleSize(position: Vector3): number
        /** Convert a world space point to a 2D GUI position.
         * @param world Point in world space.
         */
        static WorldToGUIPoint(world: Vector3): Vector2
        /** Convert a world space point to a 2D GUI position.
         * @param world Point in world space.
         * @returns A Vector3 where the x and y values relate to the 2D GUI position. The z value is the distance in world units from the camera. 
         */
        static WorldToGUIPointWithDepth(world: Vector3): Vector3
        /** Converts a 2D GUI position to screen pixel coordinates.
         */
        static GUIPointToScreenPixelCoordinate(guiPoint: Vector2): Vector2
        /** Convert 2D GUI position to a world space ray.
         */
        static GUIPointToWorldRay(position: Vector2): Ray
        /** Calculate a rectangle to display a 2D GUI element near a projected point in 3D space.
         * @param position The world-space position to use.
         * @param content The content to make room for.
         * @param style The style to use. The style's alignment.
         */
        static WorldPointToSizedRect(position: Vector3, content: GUIContent, style: GUIStyle): Rect
        static PickRectObjects(rect: Rect, selectPrefabRootsOnly: boolean): Array<GameObject>
        /** Pick GameObjects that lie within a specified screen rectangle.
         * @param rect An screen rectangle specified with pixel coordinates.
         */
        static PickRectObjects(rect: Rect): Array<GameObject>
        static PickGameObject(position: Vector2, ignore: Array<GameObject>, materialIndex: jsb.Out<number>): GameObject
        static PickGameObject(position: Vector2, selectPrefabRoot: boolean, ignore: Array<GameObject>): GameObject
        /** Pick game object closest to specified position.
         * @param selectPrefabRoot Select Prefab.
         * @param materialIndex Returns index into material array of the Renderer component that is closest to specified position.
         */
        static PickGameObject(position: Vector2, materialIndex: jsb.Out<number>): GameObject
        /** Pick game object closest to specified position.
         * @param selectPrefabRoot Select Prefab.
         * @param materialIndex Returns index into material array of the Renderer component that is closest to specified position.
         */
        static PickGameObject(position: Vector2, selectPrefabRoot: boolean): GameObject
        /** Store all camera settings.
         */
        static PushCamera(camera: Camera): void
        /** Retrieve all camera settings.
         */
        static PopCamera(camera: Camera): void
        /** Casts ray against the Scene and report if an object lies in its path.
         * @returns A boxed RaycastHit, null if nothing hit it. 
         */
        static RaySnap(ray: Ray): Object
        static Repaint(): void
        protected constructor()
        /** Get standard acceleration for dragging values (Read Only).
         */
        static readonly acceleration: number
        /** Get nice mouse delta to use for dragging a float value (Read Only).
         */
        static readonly niceMouseDelta: number
        /** Get nice mouse delta to use for zooming (Read Only).
         */
        static readonly niceMouseDeltaZoom: number
        static nearestControl: number
        static readonly handleMaterial: Material
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Color, Quaternion, Camera, Vector3, Object as Object1, Transform, Bounds } from "UnityEngine";
    import { ValueType, Object, Array, Enum } from "System";
    /** Use this class to manage SceneView settings, change the SceneView camera properties, subscribe to events, call SceneView methods, and render open scenes.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class SceneView extends EditorWindow {
        ResetCameraSettings(): void
        /** Sets a replacement shader for rendering this Scene view.
         * @param shader The replacement shader.
         * @param replaceString The replacement shader tag.
         */
        SetSceneViewShaderReplace(shader: any, replaceString: string): void
        OnEnable(): void
        OnDisable(): void
        OnDestroy(): void
        AddItemsToMenu(menu: GenericMenu): void
        IsCameraDrawModeEnabled(mode: any): boolean
        FixNegativeSize(): void
        /** Moves the Scene view to focus on a target.
         * @param point The position in world space to frame.
         * @param direction The direction that the Scene view should view the target point from.
         * @param newSize The amount of camera zoom. Sets size.
         * @param ortho Whether the camera focus is in orthographic mode (true) or perspective mode (false).
         * @param instant Apply the movement immediately (true) or animate the transition (false).
         */
        LookAt(point: Vector3, direction: Quaternion, newSize: number, ortho: boolean, instant: boolean): void
        /** Moves the Scene view to focus on a target.
         * @param point The position in world space to frame.
         * @param direction The direction that the Scene view should view the target point from.
         * @param newSize The amount of camera zoom. Sets size.
         * @param ortho Whether the camera focus is in orthographic mode (true) or perspective mode (false).
         * @param instant Apply the movement immediately (true) or animate the transition (false).
         */
        LookAt(point: Vector3, direction: Quaternion, newSize: number, ortho: boolean): void
        /** Moves the Scene view to focus on a target.
         * @param point The position in world space to frame.
         * @param direction The direction that the Scene view should view the target point from.
         * @param newSize The amount of camera zoom. Sets size.
         * @param ortho Whether the camera focus is in orthographic mode (true) or perspective mode (false).
         * @param instant Apply the movement immediately (true) or animate the transition (false).
         */
        LookAt(point: Vector3, direction: Quaternion, newSize: number): void
        /** Moves the Scene view to focus on a target.
         * @param point The position in world space to frame.
         * @param direction The direction that the Scene view should view the target point from.
         * @param newSize The amount of camera zoom. Sets size.
         * @param ortho Whether the camera focus is in orthographic mode (true) or perspective mode (false).
         * @param instant Apply the movement immediately (true) or animate the transition (false).
         */
        LookAt(point: Vector3, direction: Quaternion): void
        /** Moves the Scene view to focus on a target.
         * @param point The position in world space to frame.
         * @param direction The direction that the Scene view should view the target point from.
         * @param newSize The amount of camera zoom. Sets size.
         * @param ortho Whether the camera focus is in orthographic mode (true) or perspective mode (false).
         * @param instant Apply the movement immediately (true) or animate the transition (false).
         */
        LookAt(point: Vector3): void
        /** .LookAt without animating the scene movement.
         * @param point The position in world space to frame.
         * @param direction The direction from which the Scene view should view the point.
         * @param newSize The amount of camera zoom. Sets size.
         */
        LookAtDirect(point: Vector3, direction: Quaternion, newSize: number): void
        /** .LookAt without animating the scene movement.
         * @param point The position in world space to frame.
         * @param direction The direction from which the Scene view should view the point.
         * @param newSize The amount of camera zoom. Sets size.
         */
        LookAtDirect(point: Vector3, direction: Quaternion): void
        /** Moves the Scene view to frame a transform.
         * @param t The transform to frame in the Scene view.
         */
        AlignViewToObject(t: Transform): void
        AlignWithView(): void
        /** Transforms all selected object to the scene pivot.
         * @param target A transform to place at the scene pivot.
         */
        MoveToView(target: Transform): void
        MoveToView(): void
        FrameSelected(lockView: boolean, instant: boolean): boolean
        /** Frame the object selection in the Scene view.
         * @param lockView Whether the view should be locked to the selection.
         * @returns Returns true if the current selection fits in the Scene view. Returns false otherwise. 
         */
        FrameSelected(lockView: boolean): boolean
        FrameSelected(): boolean
        Frame(bounds: Bounds, instant: boolean): boolean
        static FrameLastActiveSceneView(): boolean
        static FrameLastActiveSceneViewWithLock(): boolean
        static GetAllSceneCameras(): Array<Camera>
        static RepaintAll(): void
        /** Add a custom camera mode to the Scene view camera mode list.
         * @param name The name for the new mode.
         * @param section The section in which the new mode will be added. This can be an existing or new section.
         * @returns A CameraMode with the provided name and section. 
         */
        static AddCameraMode(name: string, section: string): any
        static ClearUserDefinedCameraModes(): void
        /** Gets the built-in CameraMode that matches the specified DrawCameraMode.
         * @param mode The DrawCameraMode to match.
         * @returns Returns a built-in CameraMode. 
         */
        static GetBuiltinCameraMode(mode: any): any
        protected constructor()
        /** The SceneView that was most recently in focus.
         */
        static readonly lastActiveSceneView: SceneView
        /** The SceneView that is being drawn.
         */
        static readonly currentDrawingSceneView: SceneView
        /** Gets the Color of selected outline.
         */
        static readonly selectedOutlineColor: Color
        /** Sets the visibility of all Gizmos in the Scene view.
         */
        drawGizmos: boolean
        /** Whether lighting is enabled or disabled in the Scene view.
         */
        sceneLighting: boolean
        /** Whether the SceneView is in 2D mode.
         */
        in2DMode: boolean
        /** Whether the Scene view camera can be rotated.
         */
        isRotationLocked: boolean
        /** Enables or disables Scene view audio effects.
         */
        audioPlay: boolean
        /** The current DrawCameraMode for the Scene view camera.
         */
        cameraMode: any
        /** Whether the albedo is black for materials with an average specular color above 0.45.
         */
        validateTrueMetals: boolean
        /** Use SceneViewState to set the debug options for the Scene view.
         */
        sceneViewState: any
        /** Gets or sets whether to enable the grid for an instance of the SceneView.
         */
        showGrid: boolean
        /** Use CameraSettings to set the properties for the SceneView Camera.
         */
        cameraSettings: any
        /** When the Scene view is in 2D mode, this property contains the last camera rotation.
         */
        lastSceneViewRotation: Quaternion
        /** The distance from camera to pivot.
         */
        readonly cameraDistance: number
        /** The list of all open Scene view windows.
         */
        static readonly sceneViews: any
        /** The Camera that is rendering this SceneView.
         */
        readonly camera: Camera
        /** The center point, or pivot, of the Scene view.
         */
        pivot: Vector3
        /** The direction of the camera to the pivot of the SceneView.
         */
        rotation: Quaternion
        /** The size of the Scene view measured diagonally.
         */
        size: number
        /** Whether the Scene view camera is set to orthographic mode.
         */
        orthographic: boolean
        onValidateCameraMode(op: "add" | "remove", fn: (arg: any) => boolean): void
        onCameraModeChanged(op: "add" | "remove", fn: (obj: any) => void): void
        gridVisibilityChanged(op: "add" | "remove", fn: (obj: boolean) => void): void
        static beforeSceneGui(op: "add" | "remove", fn: (obj: SceneView) => void): void
        static duringSceneGui(op: "add" | "remove", fn: (obj: SceneView) => void): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Enum, Array } from "System";
    import { Object as Object1, Vector2 } from "UnityEngine";
    /** Various utilities for mesh manipulation.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class MeshUtility extends Object {
        /** Optimizes the Mesh data to improve rendering performance.
         */
        static Optimize(mesh: any): void
        /** Change the mesh compression setting for a mesh.
         * @param mesh The mesh to set the compression mode for.
         * @param compression The compression mode to set.
         */
        static SetMeshCompression(mesh: any, compression: any): void
        /** Returns the mesh compression setting for a Mesh.
         * @param mesh The mesh to get information on.
         */
        static GetMeshCompression(mesh: any): any
        /** Will insert per-triangle uv2 in mesh and handle vertex splitting etc.
         */
        static SetPerTriangleUV2(src: any, triUV: Array<Vector2>): void
        protected constructor()
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array, Enum, ValueType } from "System";
    import { GameObject, Object as Object1, Component, Texture2D, Transform } from "UnityEngine";
    import { List } from "System.Collections.Generic";
    /** Utility class for any Prefab related operations.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class PrefabUtility extends Object {
        /** This function will give you the PrefabInstance object for the outermost Prefab instance the provided object is part of.
         * @param instanceComponentOrGameObject An object from the Prefab instance.
         * @returns The Prefab instance handle. 
         */
        static GetPrefabInstanceHandle(instanceComponentOrGameObject: Object1): Object1
        /** Extract all modifications that are applied to the Prefab instance compared to the parent Prefab.
         */
        static GetPropertyModifications(targetPrefab: Object1): Array<any>
        /** Assigns all modifications that are applied to the Prefab instance compared to the parent Prefab.
         */
        static SetPropertyModifications(targetPrefab: Object1, modifications: Array<any>): void
        /** Returns true if the given Prefab instance has any overrides.
         * @param instanceRoot The root GameObject of the Prefab instance to check.
         * @param includeDefaultOverrides Set to true to consider default overrides as overrides too.
         * @returns Returns true if there are any overrides. 
         */
        static HasPrefabInstanceAnyOverrides(instanceRoot: GameObject, includeDefaultOverrides: boolean): boolean
        /** Instantiate an asset that is referenced by a Prefab and use it on the Prefab instance.
         */
        static InstantiateAttachedAsset(targetObject: Object1): Object1
        /** Causes modifications made to the Prefab instance to be recorded.
         * @param targetObject Object to process.
         */
        static RecordPrefabInstancePropertyModifications(targetObject: Object1): void
        /** This function will unpack the given Prefab instance using the behaviour specified by unpackMode.
         * @param instanceRoot Root GameObject of the Prefab instance.
         * @param unpackMode The unpack mode to use.
         * @returns Array of GameObjects representing roots of unpacked Prefab instances. 
         */
        static UnpackPrefabInstanceAndReturnNewOutermostRoots(instanceRoot: GameObject, unpackMode: any): Array<GameObject>
        /** Loads a Prefab Asset at a given path into a given preview Scene and returns the root GameObject of the Prefab.
         * @param scene The Scene to load the contents into.
         * @param prefabPath The path of the Prefab Asset to load the contents of.
         */
        static LoadPrefabContentsIntoPreviewScene(prefabPath: string, scene: any): void
        /** Is this component added to a Prefab instance as an override?
         * @param component The component to check.
         * @returns True if the component is an added component. 
         */
        static IsAddedComponentOverride(component: Object1): boolean
        /** Returns true if the given object is part of any kind of Prefab.
         * @param componentOrGameObject The object to check. Must be a component or GameObject.
         * @returns True if the object s part of a Prefab. 
         */
        static IsPartOfAnyPrefab(componentOrGameObject: Object1): boolean
        /** Returns true if the given object is part of a Prefab Asset.
         * @param componentOrGameObject The object to check. Must be a component or GameObject.
         * @returns True is the object is part of a Prefab Asset. 
         */
        static IsPartOfPrefabAsset(componentOrGameObject: Object1): boolean
        /** Returns true if the given object is part of a Prefab instance.
         * @param componentOrGameObject The object to check. Must be a component or GameObject.
         * @returns True if the object is part of a Prefab instance. 
         */
        static IsPartOfPrefabInstance(componentOrGameObject: Object1): boolean
        /** Returns true if the given object is part of a Prefab instance and not part of an asset.
         * @param componentOrGameObject The object to check. Must be a component or GameObject.
         * @returns True if the object is part of a Prefab instance that's not inside a Prefab Asset. 
         */
        static IsPartOfNonAssetPrefabInstance(componentOrGameObject: Object1): boolean
        /** Returns true if the given object is part of a regular Prefab instance or Prefab Asset.
         * @param componentOrGameObject The object to check. Must be a component or GameObject.
         * @returns True if the given object is part of a regular Prefab instance or Prefab Asset. 
         */
        static IsPartOfRegularPrefab(componentOrGameObject: Object1): boolean
        /** Returns true if the given object is part of a Model Prefab Asset or Model Prefab instance.
         * @param componentOrGameObject The object to check. Must be a component or GameObject.
         * @returns True if the given object is part of a Model Prefab. 
         */
        static IsPartOfModelPrefab(componentOrGameObject: Object1): boolean
        /** Returns true if the given object is part of a Prefab Variant Asset or Prefab Variant instance.
         * @param componentOrGameObject The object to check. Must be a component or GameObject.
         * @returns True if the given object is part of a Prefab Variant. 
         */
        static IsPartOfVariantPrefab(componentOrGameObject: Object1): boolean
        /** Is this object part of a Prefab that cannot be edited?
         * @param gameObjectOrComponent The object to check. Must be a component or GameObject.
         * @returns True if the object is part of a Prefab that cannot be edited. 
         */
        static IsPartOfImmutablePrefab(componentOrGameObject: Object1): boolean
        /** Returns true if the given object is part of an instance where the PrefabInstance object is missing but the given object has a valid corresponding object.
         * @param componentOrGameObject The object to check. Must be a GameObject or component.
         * @returns True if the instance is disconnected. 
         */
        static IsDisconnectedFromPrefabAsset(componentOrGameObject: Object1): boolean
        /** Returns true if the given object is part of a Prefab instance but the source asset is missing.
         * @param instanceComponentOrGameObject The object to check. Must be a component or GameObject.
         * @returns True if the given object is part of a Prefab instance but the source asset is missing. 
         */
        static IsPrefabAssetMissing(instanceComponentOrGameObject: Object1): boolean
        /** Returns the GameObject that is the root of the outermost Prefab instance the object is part of.
         * @param componentOrGameObject The object to check. Must be a component or GameObject.
         * @returns The outermost Prefab instance root. 
         */
        static GetOutermostPrefabInstanceRoot(componentOrGameObject: Object1): GameObject
        /** Return the GameObject that is the root of the nearest Prefab instance the object is part of.
         * @param componentOrGameObject The object to check. Must be a component or GameObject.
         * @returns The nearest Prefab instance root. 
         */
        static GetNearestPrefabInstanceRoot(componentOrGameObject: Object1): GameObject
        /** Returns true if the given modification is considered a PrefabUtility.IsDefaultOverride|default override.
         * @param modification The modification for the property in question.
         * @returns True if the property is a default override. 
         */
        static IsDefaultOverride(modification: any): boolean
        /** Reverts all overrides on a Prefab instance.
         * @param instanceRoot The root of the Prefab instance.
         * @param action The interaction mode for this action.
         */
        static RevertPrefabInstance(instanceRoot: GameObject, action: any): void
        /** Applies all overrides on a Prefab instance to its Prefab Asset.
         * @param instanceRoot The root of the given Prefab instance.
         * @param action The interaction mode for this action.
         */
        static ApplyPrefabInstance(instanceRoot: GameObject, action: any): void
        /** Applies a single overridden property on a Prefab instance to the Prefab Asset at the given asset path.
         * @param instanceProperty The SerializedProperty representing the property to apply.
         * @param assetPath The path of the Prefab Asset to apply to.
         * @param action The interaction mode for this action.
         */
        static ApplyPropertyOverride(instanceProperty: SerializedProperty, assetPath: string, action: any): void
        /** Revert a single property override on a Prefab instance.
         * @param action The interaction mode for this action.
         * @param instanceProperty The SerializedProperty representing the property to revert.
         */
        static RevertPropertyOverride(instanceProperty: SerializedProperty, action: any): void
        /** Applies all overridden properties on a Prefab instance component or GameObject to the Prefab Asset at the given asset path.
         * @param instanceComponentOrGameObject The object on the Prefab instance to apply.
         * @param assetPath The path of the Prefab Asset to apply to.
         * @param action The interaction mode for this action.
         */
        static ApplyObjectOverride(instanceComponentOrGameObject: Object1, assetPath: string, action: any): void
        /** Reverts all overridden properties on a Prefab instance component or GameObject.
         * @param action The interaction mode for this action.
         * @param instanceComponentOrGameObject The object on the Prefab instance to revert.
         */
        static RevertObjectOverride(instanceComponentOrGameObject: Object1, action: any): void
        /** Applies the added component to the Prefab Asset at the given asset path.
         * @param action The interaction mode for this action.
         * @param assetPath The path of the Prefab Asset to apply to.
         * @param component The added component on the Prefab instance to apply.
         */
        static ApplyAddedComponent(component: Component, assetPath: string, action: any): void
        /** Removes this added component on a Prefab instance.
         * @param component The added component on the Prefab instance to revert.
         * @param action The interaction mode for this action.
         */
        static RevertAddedComponent(component: Component, action: any): void
        /** Removes the component from the Prefab Asset which has the component on it.
         * @param instanceGameObject The GameObject on the Prefab instance which the component has been removed from.
         * @param assetComponent The component on the Prefab Asset corresponding to the removed component on the instance.
         * @param action The interaction mode for this action.
         */
        static ApplyRemovedComponent(instanceGameObject: GameObject, assetComponent: Component, action: any): void
        /** Adds this removed component back on the Prefab instance.
         * @param assetComponent The removed component on the Prefab instance to revert.
         * @param action The interaction mode for this action.
         * @param instanceGameObject The GameObject on the Prefab instance which the component has been removed from.
         */
        static RevertRemovedComponent(instanceGameObject: GameObject, assetComponent: Component, action: any): void
        /** Applies the added GameObject to the Prefab Asset at the given asset path.
         * @param gameObject The added GameObject on the Prefab instance to apply.
         * @param assetPath The path of the Prefab Asset to apply to.
         * @param action The interaction mode for this action.
         */
        static ApplyAddedGameObject(gameObject: GameObject, assetPath: string, action: any): void
        /** Removes this added GameObject from a Prefab instance.
         * @param action The interaction mode for this action.
         * @param gameObject The added GameObject on the Prefab instance to revert.
         */
        static RevertAddedGameObject(gameObject: GameObject, action: any): void
        /** Returns a list of objects with information about object overrides on the Prefab instance.
         * @param prefabInstance The Prefab instance to get information about.
         * @param includeDefaultOverrides If true, components will also be included even if they only contain overrides that are PrefabUtility.IsDefaultOverride|default overrides. False by default.
         * @returns List of objects with information about object overrides. 
         */
        static GetObjectOverrides(prefabInstance: GameObject, includeDefaultOverrides: boolean): any
        /** Returns a list of PrefabUtility.AddedComponent objects which contain information about added component overrides on the Prefab instance.
         * @param prefabInstance The Prefab instance to get information about.
         * @returns List of objects with information about added components. 
         */
        static GetAddedComponents(prefabInstance: GameObject): any
        /** Returns a list of objects with information about removed component overrides on the Prefab instance.
         * @param prefabInstance The Prefab instance to get information about.
         * @returns List of objects with information about removed components. 
         */
        static GetRemovedComponents(prefabInstance: GameObject): any
        /** Returns a list of PrefabUtility.AddedGameObject objects which contain information about added GameObjects on the Prefab instance.
         * @param prefabInstance The Prefab instance to get information about.
         * @returns List of objects with information about added GameObjects. 
         */
        static GetAddedGameObjects(prefabInstance: GameObject): any
        /** Is the GameObject the root of any Prefab instance?
         * @param gameObject The GameObject to check.
         * @returns True if the GameObject is the root GameObject of any Prefab instance. 
         */
        static IsAnyPrefabInstanceRoot(gameObject: GameObject): boolean
        /** Is the GameObject the root of a Prefab instance, excluding nested Prefabs?
         * @param gameObject The GameObject to check.
         * @returns True if the GameObject is an outermost Prefab instance root. 
         */
        static IsOutermostPrefabInstanceRoot(gameObject: GameObject): boolean
        /** Returns the asset path of the nearest Prefab instance root the specified object is part of.
         * @param instanceComponentOrGameObject An object in the Prefab instance to get the asset path of.
         * @returns The asset path. 
         */
        static GetPrefabAssetPathOfNearestInstanceRoot(instanceComponentOrGameObject: Object1): string
        /** Returns the icon for the given GameObject.
         * @param gameObject The GameObject to get an icon for.
         * @returns The icon for the GameObject. 
         */
        static GetIconForGameObject(gameObject: GameObject): Texture2D
        /** Use this function to save the version of an existing Prefab Asset that exists in memory back to disk.
         * @param asset Any GameObject that is part of the Prefab Asset to save.
         * @param savedSuccessfully The result of the save action, either successful or unsuccessful. Use this together with the console log to get more insight into the save process.
         * @returns The root GameObject of the saved Prefab Asset. 
         */
        static SavePrefabAsset(asset: GameObject, savedSuccessfully: jsb.Out<boolean>): GameObject
        /** Use this function to save the version of an existing Prefab Asset that exists in memory back to disk.
         * @param asset Any GameObject that is part of the Prefab Asset to save.
         * @param savedSuccessfully The result of the save action, either successful or unsuccessful. Use this together with the console log to get more insight into the save process.
         * @returns The root GameObject of the saved Prefab Asset. 
         */
        static SavePrefabAsset(asset: GameObject): GameObject
        /** Use this function to create a Prefab Asset at the given path from the given GameObject, including any childen in the Scene without modifying the input objects.
         * @param instanceRoot The GameObject to save as a Prefab Asset.
         * @param assetPath The path to save the Prefab at.
         * @param success The result of the save action, either successful or unsuccessful. Use this together with the console log to get more insight into the save process.
         * @returns The root GameObject of the saved Prefab Asset, if available. 
         */
        static SaveAsPrefabAsset(instanceRoot: GameObject, assetPath: string, success: jsb.Out<boolean>): GameObject
        /** Use this function to create a Prefab Asset at the given path from the given GameObject, including any childen in the Scene without modifying the input objects.
         * @param instanceRoot The GameObject to save as a Prefab Asset.
         * @param assetPath The path to save the Prefab at.
         * @param success The result of the save action, either successful or unsuccessful. Use this together with the console log to get more insight into the save process.
         * @returns The root GameObject of the saved Prefab Asset, if available. 
         */
        static SaveAsPrefabAsset(instanceRoot: GameObject, assetPath: string): GameObject
        /** Use this function to create a Prefab Asset at the given path from the given GameObject including any children in the Scene and at the same time make the given GameObject into an instance of the new Prefab.
         * @param instanceRoot The GameObject to save as a Prefab and make into a Prefab instance.
         * @param assetPath The path to save the Prefab at.
         * @param action The interaction mode to use for this action.
         * @param success The result of the save action, either successful or unsuccessful. Use this together with the console log to get more insight into the save process.
         * @returns The root GameObject of the saved Prefab Asset, if available. 
         */
        static SaveAsPrefabAssetAndConnect(instanceRoot: GameObject, assetPath: string, action: any, success: jsb.Out<boolean>): GameObject
        /** Use this function to create a Prefab Asset at the given path from the given GameObject including any children in the Scene and at the same time make the given GameObject into an instance of the new Prefab.
         * @param instanceRoot The GameObject to save as a Prefab and make into a Prefab instance.
         * @param assetPath The path to save the Prefab at.
         * @param action The interaction mode to use for this action.
         * @param success The result of the save action, either successful or unsuccessful. Use this together with the console log to get more insight into the save process.
         * @returns The root GameObject of the saved Prefab Asset, if available. 
         */
        static SaveAsPrefabAssetAndConnect(instanceRoot: GameObject, assetPath: string, action: any): GameObject
        /** Instantiates the given Prefab in a given Scene.
         * @param target Prefab Asset to instantiate.
         * @param destinationScene Scene to instantiate the Prefab in.
         * @returns The GameObject at the root of the Prefab. 
         */
        static InstantiatePrefab(assetComponentOrGameObject: Object1, destinationScene: any): Object1
        static InstantiatePrefab(assetComponentOrGameObject: Object1, parent: Transform): Object1
        /** Instantiates the given Prefab in a given Scene.
         * @param target Prefab Asset to instantiate.
         * @param destinationScene Scene to instantiate the Prefab in.
         * @returns The GameObject at the root of the Prefab. 
         */
        static InstantiatePrefab(assetComponentOrGameObject: Object1): Object1
        /** Is this GameObject added as a child to a Prefab instance as an override?
         * @param gameObject The GameObject to check.
         * @returns True if the GameObject is an added GameObject. 
         */
        static IsAddedGameObjectOverride(gameObject: GameObject): boolean
        /** Unpacks a given Prefab instance so that it is replaced with the contents of the Prefab Asset while retaining all override values.
         * @param instanceRoot The root of the Prefab instance to unpack.
         * @param unpackMode Whether to unpack the outermost root or unpack completely.
         * @param action The interaction mode to use for this action.
         */
        static UnpackPrefabInstance(instanceRoot: GameObject, unpackMode: any, action: any): void
        /** Is this object part of a Prefab that cannot be applied to?
         * @param gameObjectOrComponent The object to check. Must be a component or GameObject.
         * @returns True if the object is part of a Prefab that cannot be applied to. 
         */
        static IsPartOfPrefabThatCanBeAppliedTo(gameObjectOrComponent: Object1): boolean
        /** Enum value with status about whether a Prefab instance is properly connected to its asset.
         * @param componentOrGameObject An object that is part of a Prefab instance.
         * @returns The status of the Prefab instance. 
         */
        static GetPrefabInstanceStatus(componentOrGameObject: Object1): PrefabInstanceStatus
        /** Enum value indicating the type of Prefab Asset, such as Regular Prefab, Model Prefab and Prefab Variant.
         * @param componentOrGameObject An object that is part of a Prefab Asset or Prefab instance.
         * @returns The type of Prefab. 
         */
        static GetPrefabAssetType(componentOrGameObject: Object1): PrefabAssetType
        /** Loads a Prefab Asset at a given path into an isolated Scene and returns the root GameObject of the Prefab.
         * @param assetPath The path of the Prefab Asset to load the contents of.
         * @returns The root of the loaded contents. 
         */
        static LoadPrefabContents(assetPath: string): GameObject
        /** Releases the content from a Prefab previously loaded with LoadPrefabContents from memory.
         * @param contentsRoot The root of the loaded Prefab contents.
         */
        static UnloadPrefabContents(contentsRoot: GameObject): void
        protected constructor()
        static prefabInstanceUpdated(op: "get"): (instance: GameObject) => void
        static prefabInstanceUpdated(op: "add" | "remove" | "set", fn?: (instance: GameObject) => void): void
        static prefabInstanceUpdated(op: "add" | "remove" | "set" | "get", fn?: (instance: GameObject) => void): (instance: GameObject) => void | void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Lets you do move, copy, delete operations over files or directories.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class FileUtil extends Object {
        /** Deletes a file or a directory given a path.
         */
        static DeleteFileOrDirectory(path: string): boolean
        /** Copies a file or a directory.
         */
        static CopyFileOrDirectory(source: string, dest: string): void
        /** Copies the file or directory.
         */
        static CopyFileOrDirectoryFollowSymlinks(source: string, dest: string): void
        /** Moves a file or a directory from a given path to another path.
         */
        static MoveFileOrDirectory(source: string, dest: string): void
        static GetUniqueTempPathInProject(): string
        static GetProjectRelativePath(path: string): string
        /** Replaces a file.
         */
        static ReplaceFile(src: string, dst: string): void
        /** Replaces a directory.
         */
        static ReplaceDirectory(src: string, dst: string): void
        protected constructor()
    }
}
declare module "UnityEditor.Build.Reporting" {
    import * as jsb from "jsb";
    import { Object, ScriptableObject } from "UnityEngine";
    import { Array, ValueType } from "System";
    /** The BuildReport API gives you information about the Unity build process.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class BuildReport extends Object {
        protected constructor()
        /** An array of all the files output by the build process.
         */
        readonly files: Array<any>
        /** An array of all the BuildSteps that took place during the build process.
         */
        readonly steps: Array<any>
        /** A BuildSummary containing overall statistics and data about the build process.
         */
        readonly summary: any
        /** The StrippingInfo object for the build.
         */
        readonly strippingInfo: any
        /** An array of all the PackedAssets generated by the build process.
         */
        readonly packedAssets: Array<any>
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Array } from "System";
    /** Manifest for all the AssetBundles in the build.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class AssetBundleManifest extends Object {
        GetAllAssetBundles(): Array<string>
        GetAllAssetBundlesWithVariant(): Array<string>
        /** Get the hash for the given AssetBundle.
         * @param assetBundleName Name of the asset bundle.
         * @returns The 128-bit hash for the asset bundle. 
         */
        GetAssetBundleHash(assetBundleName: string): Hash128
        /** Get the direct dependent AssetBundles for the given AssetBundle.
         * @param assetBundleName Name of the asset bundle.
         * @returns Array of asset bundle names this asset bundle depends on. 
         */
        GetDirectDependencies(assetBundleName: string): Array<string>
        /** Get all the dependent AssetBundles for the given AssetBundle.
         * @param assetBundleName Name of the asset bundle.
         */
        GetAllDependencies(assetBundleName: string): Array<string>
        protected constructor()
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Enum, Array, ValueType } from "System";
    import { BuildReport } from "UnityEditor.Build.Reporting";
    import { AssetBundleManifest, Hash128 } from "UnityEngine";
    /** Lets you programmatically build players or AssetBundles which can be loaded from the web.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class BuildPipeline extends Object {
        static GetBuildTargetGroup(platform: BuildTarget): any
        /** Given a BuildTarget will return the well known string representation for the build target platform.
         * @param targetPlatform An instance of the BuildTarget enum.
         * @returns Target platform name represented by the passed in BuildTarget. 
         */
        static GetBuildTargetName(targetPlatform: BuildTarget): string
        static SetAssetBundleEncryptKey(password: string): void
        /** Builds a player. These overloads are still supported, but will be replaced. Please use BuildPlayer (BuildPlayerOptions buildPlayerOptions)  instead.
         * @param scenes The Scenes to include in the build. If empty, the build only includes the currently open Scene. Paths are relative to the project folder (AssetsMyLevelsMyScene.unity).
         * @param locationPathName The path where the application will be built.
         * @param target The BuildTarget to build.
         * @param options Additional BuildOptions, like whether to run the built player.
         * @returns An error message if an error occurred. 
         */
        static BuildPlayer(levels: Array<any>, locationPathName: string, target: BuildTarget, options: any): BuildReport
        /** Builds a player. These overloads are still supported, but will be replaced. Please use BuildPlayer (BuildPlayerOptions buildPlayerOptions)  instead.
         * @param scenes The Scenes to include in the build. If empty, the build only includes the currently open Scene. Paths are relative to the project folder (AssetsMyLevelsMyScene.unity).
         * @param locationPathName The path where the application will be built.
         * @param target The BuildTarget to build.
         * @param options Additional BuildOptions, like whether to run the built player.
         * @returns An error message if an error occurred. 
         */
        static BuildPlayer(levels: Array<string>, locationPathName: string, target: BuildTarget, options: any): BuildReport
        /** Builds a player.
         * @param buildPlayerOptions Provide various options to control the behavior of BuildPipeline.BuildPlayer.
         * @returns A BuildReport giving build process information. 
         */
        static BuildPlayer(buildPlayerOptions: BuildPlayerOptions): BuildReport
        /** Build AssetBundles from a building map.
         * @param outputPath Output path for the AssetBundles.
         * @param builds AssetBundle building map.
         * @param assetBundleOptions AssetBundle building options.
         * @param targetPlatform Target build platform.
         * @returns The manifest listing all AssetBundles included in this build. 
         */
        static BuildAssetBundles(outputPath: string, builds: Array<any>, assetBundleOptions: BuildAssetBundleOptions, targetPlatform: BuildTarget): AssetBundleManifest
        /** Build all AssetBundles specified in the editor.
         * @param outputPath Output path for the AssetBundles.
         * @param assetBundleOptions AssetBundle building options.
         * @param targetPlatform Chosen target build platform.
         * @returns The manifest listing all AssetBundles included in this build. 
         */
        static BuildAssetBundles(outputPath: string, assetBundleOptions: BuildAssetBundleOptions, targetPlatform: BuildTarget): AssetBundleManifest
        /** Extract the crc checksum for the given AssetBundle.
         */
        static GetCRCForAssetBundle(targetPath: string, crc: jsb.Out<number>): boolean
        /** Extract the hash for the given AssetBundle.
         */
        static GetHashForAssetBundle(targetPath: string, hash: jsb.Out<Hash128>): boolean
        /** Returns true if the specified build target is currently available in the Editor.
         * @param buildTargetGroup build target group
         * @param target build target
         */
        static IsBuildTargetSupported(buildTargetGroup: any, target: BuildTarget): boolean
        /** Returns the path of a player directory. For ex., Editor\Data\PlaybackEngines\AndroidPlayer.

In some cases the player directory path can be affected by BuildOptions.Development.
         * @param target Build target.
         * @param options Build options.
         * @param buildTargetGroup Build target group.
         */
        static GetPlaybackEngineDirectory(buildTargetGroup: any, target: BuildTarget, options: any): string
        /** Returns the path of a player directory. For ex., Editor\Data\PlaybackEngines\AndroidPlayer.

In some cases the player directory path can be affected by BuildOptions.Development.
         * @param target Build target.
         * @param options Build options.
         * @param buildTargetGroup Build target group.
         */
        static GetPlaybackEngineDirectory(target: BuildTarget, options: any): string
        protected constructor()
        /** Is a player currently being built?
         */
        static readonly isBuildingPlayer: boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { List, IEnumerable } from "System.Collections.Generic";
    import { Object as Object1, Hash128, Texture } from "UnityEngine";
    /** An Interface for accessing assets and performing operations on assets.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class AssetDatabase extends Object {
        static IsOpenForEdit(assetOrMetaFilePaths: Array<string>, outNotEditablePaths: List<string>, statusQueryOptions: StatusQueryOptions): void
        /** Query whether an Asset file is open for editing in version control.
         * @param assetObject Object representing the asset whose status you wish to query.
         * @param assetOrMetaFilePath Path to the asset file or its .meta file on disk, relative to project folder.
         * @param message Returns a reason for the asset not being open for edit.
         * @param statusOptions Options for how the version control system should be queried. These options can effect the speed and accuracy of the query. Default is StatusQueryOptions.UseCachedIfPossible.
         * @returns True if the asset is considered open for edit by the selected version control system. 
         */
        static IsOpenForEdit(assetObject: Object1, message: jsb.Out<string>, statusOptions: StatusQueryOptions): boolean
        /** Query whether an Asset file is open for editing in version control.
         * @param assetObject Object representing the asset whose status you wish to query.
         * @param assetOrMetaFilePath Path to the asset file or its .meta file on disk, relative to project folder.
         * @param message Returns a reason for the asset not being open for edit.
         * @param statusOptions Options for how the version control system should be queried. These options can effect the speed and accuracy of the query. Default is StatusQueryOptions.UseCachedIfPossible.
         * @returns True if the asset is considered open for edit by the selected version control system. 
         */
        static IsOpenForEdit(assetOrMetaFilePath: string, message: jsb.Out<string>, statusOptions: StatusQueryOptions): boolean
        /** Query whether an Asset file is open for editing in version control.
         * @param assetObject Object representing the asset whose status you wish to query.
         * @param assetOrMetaFilePath Path to the asset file or its .meta file on disk, relative to project folder.
         * @param message Returns a reason for the asset not being open for edit.
         * @param statusOptions Options for how the version control system should be queried. These options can effect the speed and accuracy of the query. Default is StatusQueryOptions.UseCachedIfPossible.
         * @returns True if the asset is considered open for edit by the selected version control system. 
         */
        static IsOpenForEdit(assetObject: Object1, statusOptions: StatusQueryOptions): boolean
        /** Query whether an Asset file is open for editing in version control.
         * @param assetObject Object representing the asset whose status you wish to query.
         * @param assetOrMetaFilePath Path to the asset file or its .meta file on disk, relative to project folder.
         * @param message Returns a reason for the asset not being open for edit.
         * @param statusOptions Options for how the version control system should be queried. These options can effect the speed and accuracy of the query. Default is StatusQueryOptions.UseCachedIfPossible.
         * @returns True if the asset is considered open for edit by the selected version control system. 
         */
        static IsOpenForEdit(assetOrMetaFilePath: string, statusOptions: StatusQueryOptions): boolean
        /** Query whether an Asset file is open for editing in version control.
         * @param assetObject Object representing the asset whose status you wish to query.
         * @param assetOrMetaFilePath Path to the asset file or its .meta file on disk, relative to project folder.
         * @param message Returns a reason for the asset not being open for edit.
         * @param statusOptions Options for how the version control system should be queried. These options can effect the speed and accuracy of the query. Default is StatusQueryOptions.UseCachedIfPossible.
         * @returns True if the asset is considered open for edit by the selected version control system. 
         */
        static IsOpenForEdit(assetObject: Object1, message: jsb.Out<string>): boolean
        /** Query whether an Asset file is open for editing in version control.
         * @param assetObject Object representing the asset whose status you wish to query.
         * @param assetOrMetaFilePath Path to the asset file or its .meta file on disk, relative to project folder.
         * @param message Returns a reason for the asset not being open for edit.
         * @param statusOptions Options for how the version control system should be queried. These options can effect the speed and accuracy of the query. Default is StatusQueryOptions.UseCachedIfPossible.
         * @returns True if the asset is considered open for edit by the selected version control system. 
         */
        static IsOpenForEdit(assetOrMetaFilePath: string, message: jsb.Out<string>): boolean
        /** Query whether an Asset file is open for editing in version control.
         * @param assetObject Object representing the asset whose status you wish to query.
         * @param assetOrMetaFilePath Path to the asset file or its .meta file on disk, relative to project folder.
         * @param message Returns a reason for the asset not being open for edit.
         * @param statusOptions Options for how the version control system should be queried. These options can effect the speed and accuracy of the query. Default is StatusQueryOptions.UseCachedIfPossible.
         * @returns True if the asset is considered open for edit by the selected version control system. 
         */
        static IsOpenForEdit(assetObject: Object1): boolean
        /** Query whether an Asset file is open for editing in version control.
         * @param assetObject Object representing the asset whose status you wish to query.
         * @param assetOrMetaFilePath Path to the asset file or its .meta file on disk, relative to project folder.
         * @param message Returns a reason for the asset not being open for edit.
         * @param statusOptions Options for how the version control system should be queried. These options can effect the speed and accuracy of the query. Default is StatusQueryOptions.UseCachedIfPossible.
         * @returns True if the asset is considered open for edit by the selected version control system. 
         */
        static IsOpenForEdit(assetOrMetaFilePath: string): boolean
        static MakeEditable(paths: Array<string>, prompt: string, outNotEditablePaths: List<string>): boolean
        /** Makes a file open for editing in version control.
         * @param path Specifies the path to a file relative to the project root.
         * @returns true if Unity successfully made the file editable in the version control system. Otherwise, returns false. 
         */
        static MakeEditable(path: string): boolean
        /** Search the asset database using the search filter string.
         * @param filter The filter string can contain search data.  See below for details about this string.
         * @param searchInFolders The folders where the search will start.
         * @returns Array of matching asset. Note that GUIDs will be returned. 
         */
        static FindAssets(filter: string, searchInFolders: Array<string>): Array<string>
        /** Search the asset database using the search filter string.
         * @param filter The filter string can contain search data.  See below for details about this string.
         * @param searchInFolders The folders where the search will start.
         * @returns Array of matching asset. Note that GUIDs will be returned. 
         */
        static FindAssets(filter: string): Array<string>
        /** Is object an asset?
         */
        static Contains(obj: Object1): boolean
        /** Is object an asset?
         */
        static Contains(instanceID: number): boolean
        /** Creates a new folder, in the specified parent folder.

The parent folder string must start with the "Assets" folder, and all folders within the parent folder string must already exist. For example, when specifying "AssetsParentFolder1Parentfolder2/", the new folder will be created in "ParentFolder2" only if ParentFolder1 and ParentFolder2 already exist.
         * @param parentFolder The path to the parent folder. Must start with "Assets/".
         * @param newFolderName The name of the new folder.
         * @returns The GUID of the newly created folder, if the folder was created successfully. Otherwise returns an empty string. 
         */
        static CreateFolder(parentFolder: string, newFolderName: string): string
        /** Is asset a main asset in the project window?
         */
        static IsMainAsset(obj: Object1): boolean
        /** Is asset a main asset in the project window?
         */
        static IsMainAsset(instanceID: number): boolean
        /** Does the asset form part of another asset?
         * @param obj The asset Object to query.
         * @param instanceID Instance ID of the asset Object to query.
         */
        static IsSubAsset(obj: Object1): boolean
        /** Does the asset form part of another asset?
         * @param obj The asset Object to query.
         * @param instanceID Instance ID of the asset Object to query.
         */
        static IsSubAsset(instanceID: number): boolean
        /** Determines whether the Asset is a foreign Asset.
         */
        static IsForeignAsset(obj: Object1): boolean
        /** Determines whether the Asset is a foreign Asset.
         */
        static IsForeignAsset(instanceID: number): boolean
        /** Determines whether the Asset is a native Asset.
         */
        static IsNativeAsset(obj: Object1): boolean
        /** Determines whether the Asset is a native Asset.
         */
        static IsNativeAsset(instanceID: number): boolean
        static GetCurrentCacheServerIp(): string
        /** Creates a new unique path for an asset.
         */
        static GenerateUniqueAssetPath(path: string): string
        static StartAssetEditing(): void
        static StopAssetEditing(): void
        static ReleaseCachedFileHandles(): void
        /** Checks if an asset file can be moved from one folder to another. (Without actually moving the file).
         * @param oldPath The path where the asset currently resides.
         * @param newPath The path which the asset should be moved to.
         * @returns An empty string if the asset can be moved, otherwise an error message. 
         */
        static ValidateMoveAsset(oldPath: string, newPath: string): string
        /** Move an asset file (or folder) from one folder to another.
         * @param oldPath The path where the asset currently resides.
         * @param newPath The path which the asset should be moved to.
         * @returns An empty string if the asset has been successfully moved, otherwise an error message. 
         */
        static MoveAsset(oldPath: string, newPath: string): string
        /** Creates an external Asset from an object (such as a Material) by extracting it from within an imported asset (such as an FBX file).
         * @param asset The sub-asset to extract.
         * @param newPath The file path of the new Asset.
         * @returns An empty string if Unity has successfully extracted the Asset, or an error message if not. 
         */
        static ExtractAsset(asset: Object1, newPath: string): string
        /** Rename an asset file.
         * @param pathName The path where the asset currently resides.
         * @param newName The new name which should be given to the asset.
         * @returns An empty string, if the asset has been successfully renamed, otherwise an error message. 
         */
        static RenameAsset(pathName: string, newName: string): string
        /** Moves the asset at path to the trash.
         */
        static MoveAssetToTrash(path: string): boolean
        /** Deletes the asset file at path.
         * @param path Filesystem path of the asset to be deleted.
         */
        static DeleteAsset(path: string): boolean
        /** Import asset at path.
         */
        static ImportAsset(path: string, options: ImportAssetOptions): void
        /** Import asset at path.
         */
        static ImportAsset(path: string): void
        /** Duplicates the asset at path and stores it at newPath.
         * @param path Filesystem path of the source asset.
         * @param newPath Filesystem path of the new asset to create.
         * @returns Returns true if the copy operation is successful or false if part of the process fails. 
         */
        static CopyAsset(path: string, newPath: string): boolean
        /** Writes the import settings to disk.
         */
        static WriteImportSettingsIfDirty(path: string): boolean
        /** Given a path to a directory in the Assets folder, relative to the project folder, this method will return an array of all its subdirectories.
         */
        static GetSubFolders(path: string): Array<string>
        /** Given a path to a folder, returns true if it exists, false otherwise.
         * @param path The path to the folder.
         * @returns Returns true if the folder exists. 
         */
        static IsValidFolder(path: string): boolean
        /** Creates a new asset at path.
         * @param asset Object to use in creating the asset.
         * @param path Filesystem path for the new asset.
         */
        static CreateAsset(asset: Object1, path: string): void
        /** Adds objectToAdd to an existing asset at path.
         * @param objectToAdd Object to add to the existing asset.
         * @param path Filesystem path to the asset.
         */
        static AddObjectToAsset(objectToAdd: Object1, path: string): void
        /** Adds objectToAdd to an existing asset identified by assetObject.
         */
        static AddObjectToAsset(objectToAdd: Object1, assetObject: Object1): void
        /** Specifies which object in the asset file should become the main object after the next import.
         * @param mainObject The object to become the main object.
         * @param assetPath Path to the asset file.
         */
        static SetMainObject(mainObject: Object1, assetPath: string): void
        /** Returns the path name relative to the project folder where the asset is stored.
         * @param instanceID The instance ID of the asset.
         * @param assetObject A reference to the asset.
         * @returns The asset path name, or null, or an empty string if the asset does not exist. 
         */
        static GetAssetPath(assetObject: Object1): string
        /** Returns the path name relative to the project folder where the asset is stored.
         * @param instanceID The instance ID of the asset.
         * @param assetObject A reference to the asset.
         * @returns The asset path name, or null, or an empty string if the asset does not exist. 
         */
        static GetAssetPath(instanceID: number): string
        /** Returns the path name relative to the project folder where the asset is stored.
         */
        static GetAssetOrScenePath(assetObject: Object1): string
        /** Gets the path to the text .meta file associated with an asset.
         * @param path The path to the asset.
         * @returns The path to the .meta text file or empty string if the file does not exist. 
         */
        static GetTextMetaFilePathFromAssetPath(path: string): string
        /** Gets the path to the asset file associated with a text .meta file.
         */
        static GetAssetPathFromTextMetaFilePath(path: string): string
        /** Returns the first asset object of type type at given path assetPath.
         * @param assetPath Path of the asset to load.
         * @param type Data type of the asset.
         * @returns The asset matching the parameters. 
         */
        static LoadAssetAtPath(assetPath: string, type: any): Object1
        /** Returns the main asset object at assetPath.
         * @param assetPath Filesystem path of the asset to load.
         */
        static LoadMainAssetAtPath(assetPath: string): Object1
        /** Returns the type of the main asset object at assetPath.
         * @param assetPath Filesystem path of the asset to load.
         */
        static GetMainAssetTypeAtPath(assetPath: string): any
        /** Returns true if the main asset object at assetPath is loaded in memory.
         * @param assetPath Filesystem path of the asset to load.
         */
        static IsMainAssetAtPathLoaded(assetPath: string): boolean
        /** Returns all sub Assets at assetPath.
         */
        static LoadAllAssetRepresentationsAtPath(assetPath: string): Array<Object1>
        /** Returns an array of all Assets at assetPath.
         * @param assetPath Filesystem path to the asset.
         */
        static LoadAllAssetsAtPath(assetPath: string): Array<Object1>
        static GetAllAssetPaths(): Array<string>
        /** Import any changed assets.
         */
        static Refresh(options: ImportAssetOptions): void
        /** Import any changed assets.
         */
        static Refresh(): void
        /** Opens the asset with associated application.
         */
        static OpenAsset(instanceID: number, lineNumber: number, columnNumber: number): boolean
        /** Opens the asset with associated application.
         */
        static OpenAsset(target: Object1, lineNumber: number, columnNumber: number): boolean
        /** Opens the asset with associated application.
         */
        static OpenAsset(instanceID: number, lineNumber: number): boolean
        /** Opens the asset with associated application.
         */
        static OpenAsset(target: Object1, lineNumber: number): boolean
        /** Opens the asset with associated application.
         */
        static OpenAsset(instanceID: number): boolean
        /** Opens the asset with associated application.
         */
        static OpenAsset(target: Object1): boolean
        /** Opens the asset(s) with associated application(s).
         */
        static OpenAsset(objects: Array<Object1>): boolean
        /** Get the GUID for the asset at path.
         * @param path Filesystem path for the asset.
         * @returns GUID. 
         */
        static AssetPathToGUID(path: string): string
        /** Gets the corresponding asset path for the supplied guid, or an empty string if the GUID can't be found.
         */
        static GUIDToAssetPath(guid: string): string
        /** Returns the hash of all the dependencies of an asset.
         * @param path Path to the asset.
         * @returns Aggregate hash. 
         */
        static GetAssetDependencyHash(path: string): Hash128
        static SaveAssets(): void
        /** Retrieves an icon for the asset at the given asset path.
         */
        static GetCachedIcon(path: string): Texture
        /** Replaces that list of labels on an asset.
         */
        static SetLabels(obj: Object1, labels: Array<string>): void
        /** Returns all labels attached to a given asset.
         */
        static GetLabels(obj: Object1): Array<string>
        /** Removes all labels attached to an asset.
         */
        static ClearLabels(obj: Object1): void
        static GetAllAssetBundleNames(): Array<string>
        static GetUnusedAssetBundleNames(): Array<string>
        /** Remove the assetBundle name from the asset database. The forceRemove flag is used to indicate if you want to remove it even it's in use.
         * @param assetBundleName The assetBundle name you want to remove.
         * @param forceRemove Flag to indicate if you want to remove the assetBundle name even it's in use.
         */
        static RemoveAssetBundleName(assetBundleName: string, forceRemove: boolean): boolean
        static RemoveUnusedAssetBundleNames(): void
        /** Returns an array containing the paths of all assets marked with the specified Asset Bundle name.
         */
        static GetAssetPathsFromAssetBundle(assetBundleName: string): Array<string>
        /** Get the Asset paths for all Assets tagged with assetBundleName and
                named assetName.
         */
        static GetAssetPathsFromAssetBundleAndAssetName(assetBundleName: string, assetName: string): Array<string>
        /** Returns the name of the AssetBundle that a given asset belongs to.
         * @param assetPath The asset's path.
         * @returns Returns the name of the AssetBundle that a given asset belongs to. See the method description for more details. 
         */
        static GetImplicitAssetBundleName(assetPath: string): string
        /** Returns the name of the AssetBundle Variant that a given asset belongs to.
         * @param assetPath The asset's path.
         * @returns Returns the name of the AssetBundle Variant that a given asset belongs to. See the method description for more details. 
         */
        static GetImplicitAssetBundleVariantName(assetPath: string): string
        /** Given an assetBundleName, returns the list of AssetBundles that it depends on.
         * @param assetBundleName The name of the AssetBundle for which dependencies are required.
         * @param recursive If false, returns only AssetBundles which are direct dependencies of the input; if true, includes all indirect dependencies of the input.
         * @returns The names of all AssetBundles that the input depends on. 
         */
        static GetAssetBundleDependencies(assetBundleName: string, recursive: boolean): Array<string>
        /** Returns an array of all the assets that are dependencies of the asset at the specified pathName.

Note: GetDependencies() gets the Assets that are referenced by other Assets. For example, a Scene could contain many GameObjects with a Material attached to them. In this case,  GetDependencies() will return the path to the Material Assets, but not the GameObjects as those are not Assets on your disk.
         * @param pathName The path to the asset for which dependencies are required.
         * @param recursive Controls whether this method recursively checks and returns all dependencies including indirect dependencies (when set to true), or whether it only returns direct dependencies (when set to false).
         * @returns The paths of all assets that the input depends on. 
         */
        static GetDependencies(pathName: string, recursive: boolean): Array<string>
        /** Returns an array of the paths of assets that are dependencies of all the assets in the list of pathNames that you provide.

Note: GetDependencies() gets the Assets that are referenced by other Assets. For example, a Scene could contain many GameObjects with a Material attached to them. In this case,  GetDependencies() will return the path to the Material Assets, but not the GameObjects as those are not Assets on your disk.
         * @param pathNames The path to the assets for which dependencies are required.
         * @param recursive Controls whether this method recursively checks and returns all dependencies including indirect dependencies (when set to true), or whether it only returns direct dependencies (when set to false).
         * @returns The paths of all assets that the input depends on. 
         */
        static GetDependencies(pathNames: Array<string>, recursive: boolean): Array<string>
        /** Returns an array of all the assets that are dependencies of the asset at the specified pathName.

Note: GetDependencies() gets the Assets that are referenced by other Assets. For example, a Scene could contain many GameObjects with a Material attached to them. In this case,  GetDependencies() will return the path to the Material Assets, but not the GameObjects as those are not Assets on your disk.
         * @param pathName The path to the asset for which dependencies are required.
         * @param recursive Controls whether this method recursively checks and returns all dependencies including indirect dependencies (when set to true), or whether it only returns direct dependencies (when set to false).
         * @returns The paths of all assets that the input depends on. 
         */
        static GetDependencies(pathName: string): Array<string>
        /** Returns an array of the paths of assets that are dependencies of all the assets in the list of pathNames that you provide.

Note: GetDependencies() gets the Assets that are referenced by other Assets. For example, a Scene could contain many GameObjects with a Material attached to them. In this case,  GetDependencies() will return the path to the Material Assets, but not the GameObjects as those are not Assets on your disk.
         * @param pathNames The path to the assets for which dependencies are required.
         * @param recursive Controls whether this method recursively checks and returns all dependencies including indirect dependencies (when set to true), or whether it only returns direct dependencies (when set to false).
         * @returns The paths of all assets that the input depends on. 
         */
        static GetDependencies(pathNames: Array<string>): Array<string>
        /** Exports the assets identified by assetPathNames to a unitypackage file in fileName.
         */
        static ExportPackage(assetPathName: string, fileName: string, flags: ExportPackageOptions): void
        /** Exports the assets identified by assetPathNames to a unitypackage file in fileName.
         */
        static ExportPackage(assetPathNames: Array<string>, fileName: string, flags: ExportPackageOptions): void
        /** Exports the assets identified by assetPathNames to a unitypackage file in fileName.
         */
        static ExportPackage(assetPathName: string, fileName: string): void
        /** Exports the assets identified by assetPathNames to a unitypackage file in fileName.
         */
        static ExportPackage(assetPathNames: Array<string>, fileName: string): void
        /** Query whether an asset's metadata (.meta) file is open for edit in version control.
         * @param assetObject Object representing the asset whose metadata status you wish to query.
         * @param message Returns a reason for the asset metadata not being open for edit.
         * @param statusOptions Options for how the version control system should be queried. These options can effect the speed and accuracy of the query. Default is StatusQueryOptions.UseCachedIfPossible.
         * @returns True if the asset's metadata is considered open for edit by the selected version control system. 
         */
        static IsMetaFileOpenForEdit(assetObject: Object1, message: jsb.Out<string>, statusOptions: StatusQueryOptions): boolean
        /** Query whether an asset's metadata (.meta) file is open for edit in version control.
         * @param assetObject Object representing the asset whose metadata status you wish to query.
         * @param message Returns a reason for the asset metadata not being open for edit.
         * @param statusOptions Options for how the version control system should be queried. These options can effect the speed and accuracy of the query. Default is StatusQueryOptions.UseCachedIfPossible.
         * @returns True if the asset's metadata is considered open for edit by the selected version control system. 
         */
        static IsMetaFileOpenForEdit(assetObject: Object1, statusOptions: StatusQueryOptions): boolean
        /** Query whether an asset's metadata (.meta) file is open for edit in version control.
         * @param assetObject Object representing the asset whose metadata status you wish to query.
         * @param message Returns a reason for the asset metadata not being open for edit.
         * @param statusOptions Options for how the version control system should be queried. These options can effect the speed and accuracy of the query. Default is StatusQueryOptions.UseCachedIfPossible.
         * @returns True if the asset's metadata is considered open for edit by the selected version control system. 
         */
        static IsMetaFileOpenForEdit(assetObject: Object1, message: jsb.Out<string>): boolean
        /** Query whether an asset's metadata (.meta) file is open for edit in version control.
         * @param assetObject Object representing the asset whose metadata status you wish to query.
         * @param message Returns a reason for the asset metadata not being open for edit.
         * @param statusOptions Options for how the version control system should be queried. These options can effect the speed and accuracy of the query. Default is StatusQueryOptions.UseCachedIfPossible.
         * @returns True if the asset's metadata is considered open for edit by the selected version control system. 
         */
        static IsMetaFileOpenForEdit(assetObject: Object1): boolean
        static GetBuiltinExtraResource(type: any, path: string): Object1
        static ForceReserializeAssets(assetPaths: IEnumerable<string>, options: ForceReserializeAssetsOptions): void
        static ForceReserializeAssets(): void
        /** Warning Use the overload with a long localId parameter. Using the overload with an integer localId parameter can cause an integer overflow in localId. This can happen when the object passed to the API is part of a Prefab.

Get the GUID and local file id from an object instance id.
         * @param instanceID InstanceID of the object to retrieve information for.
         * @param obj The object to retrieve GUID and File Id for.
         * @param assetRef The asset reference to retrieve GUID and File Id for.
         * @param guid The GUID of the asset.
         * @param localId The local file identifier of this asset.
         * @returns True if the guid and file id were successfully found, false if not. 
         */
        static TryGetGUIDAndLocalFileIdentifier(obj: Object1, guid: jsb.Out<string>, localId: jsb.Out<number>): boolean
        /** Warning Use the overload with a long localId parameter. Using the overload with an integer localId parameter can cause an integer overflow in localId. This can happen when the object passed to the API is part of a Prefab.

Get the GUID and local file id from an object instance id.
         * @param instanceID InstanceID of the object to retrieve information for.
         * @param obj The object to retrieve GUID and File Id for.
         * @param assetRef The asset reference to retrieve GUID and File Id for.
         * @param guid The GUID of the asset.
         * @param localId The local file identifier of this asset.
         * @returns True if the guid and file id were successfully found, false if not. 
         */
        static TryGetGUIDAndLocalFileIdentifier(instanceID: number, guid: jsb.Out<string>, localId: jsb.Out<number>): boolean
        /** Removes object from its asset (See Also: AssetDatabase.AddObjectToAsset).
         */
        static RemoveObjectFromAsset(objectToRemove: Object1): void
        /** Imports package at packagePath into the current project.
         */
        static ImportPackage(packagePath: string, interactive: boolean): void
        static DisallowAutoRefresh(): void
        static AllowAutoRefresh(): void
        protected constructor()
        static importPackageStarted(op: "add" | "remove", fn: (packageName: string) => void): void
        static importPackageCompleted(op: "add" | "remove", fn: (packageName: string) => void): void
        static importPackageCancelled(op: "add" | "remove", fn: (packageName: string) => void): void
        static importPackageFailed(op: "add" | "remove", fn: (packageName: string, errorMessage: string) => void): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array, ValueType, Enum } from "System";
    import { Object as Object1, Material } from "UnityEngine";
    /** Utility functions to assist with working with shaders from the editor.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ShaderUtil extends Object {
        /** Determines whether the specified Shader contains a valid Procedural Instancing variant.
         * @param s The Shader to check.
         * @returns Returns true if the Shader has a valid Procedural Instancing variant. Returns false otherwise. 
         */
        static HasProceduralInstancing(s: any): boolean
        /** Returns the number of errors and warnings generated by the Unity Shader Compiler for the given Shader.
         * @param s The Shader instance to check for messages.
         * @returns The number of errors and warnings generated by the Unity Shader Compiler. 
         */
        static GetShaderMessageCount(s: any): number
        /** Returns each error and warning generated by the Unity Shader Compiler for the given Shader.
         * @param s The Shader instance to check for messages.
         * @returns An array of ShaderMessage structs containing the generated messages. 
         */
        static GetShaderMessages(s: any): Array<any>
        /** Clear compile time messages for the given shader.
         */
        static ClearShaderMessages(s: any): void
        /** Returns the number of errors and warnings generated by the Unity Shader Compiler for the given ComputeShader.
         * @param s The ComputeShader instance to check for messages.
         * @returns The number of errors and warnings generated by the Unity Shader Compiler. 
         */
        static GetComputeShaderMessageCount(s: any): number
        /** Returns each error and warning generated by the Unity Shader Compiler for the given ComputeShader.
         * @param s The ComputeShader instance to check for messages.
         * @returns An array of ShaderMessage structs containing the generated messages. 
         */
        static GetComputeShaderMessages(s: any): Array<any>
        /** Returns the number of errors and warnings generated by the Shader Compiler for the given RayTracingShader.
         * @param s The RayTracingShader instance to check for messages.
         * @returns The number of errors and warnings generated by the Shader Compiler. 
         */
        static GetRayTracingShaderMessageCount(s: any): number
        /** Returns each error and warning generated by the Shader Compiler for the given RayTracingShader.
         * @param s The RayTracingShader instance to check for messages.
         * @returns An array of ShaderMessage structs containing the generated messages. 
         */
        static GetRayTracingShaderMessages(s: any): Array<any>
        /** Returns the number of ray generation Shaders defined whitin a given RayTracingShader.
         * @param s The RayTracingShader instance.
         * @returns The number of ray generation Shaders defined in the RayTracingShader instance passed as argument. 
         */
        static GetRayGenerationShaderCount(s: any): number
        /** Returns the name of a user-defined ray generation Shader from within a RayTracingShader.
         * @param s The RayTracingShader instance.
         * @param shaderIndex The ray generation Shader index for which to retrieve the name. The ray generation Shaders defined in a RayTracingShader are sorted alphabetically by the Shader compiler.
         * @returns The name of the ray generation Shader at the index passed using the "shaderIndex" argument. 
         */
        static GetRayGenerationShaderName(s: any, shaderIndex: number): string
        /** Returns the number of miss Shaders defined whitin a given RayTracingShader.
         * @param s The RayTracingShader instance.
         * @returns The number of miss Shaders defined in the RayTracingShader instance passed as argument. 
         */
        static GetMissShaderCount(s: any): number
        /** Returns the name of a user-defined miss Shader from within a RayTracingShader.
         * @param s The RayTracingShader instance.
         * @param shaderIndex The miss Shader index for which to retrieve the name. The miss Shaders defined in a RayTracingShader are sorted alphabetically by the Shader compiler.
         * @returns The name of the miss Shader at the index passed using the "shaderIndex" argument. 
         */
        static GetMissShaderName(s: any, shaderIndex: number): string
        /** Returns the ray payload size of a user-defined miss Shader from within a RayTracingShader.
         * @param s The RayTracingShader instance.
         * @param shaderIndex The miss Shader index for which to retrieve the ray payload size.
         * @returns The ray payload size in bytes. 
         */
        static GetMissShaderRayPayloadSize(s: any, shaderIndex: number): number
        /** Returns the number of callable Shaders defined whitin a given RayTracingShader.
         * @param s The RayTracingShader instance.
         * @returns The number of callable Shaders defined in the RayTracingShader instance passed as argument. 
         */
        static GetCallableShaderCount(s: any): number
        /** Returns the name of a user-defined callable Shader from within a RayTracingShader.
         * @param s The RayTracingShader instance.
         * @param shaderIndex The callable Shader index for which to retrieve the name. The callable Shaders defined in a RayTracingShader are sorted alphabetically by the Shader compiler.
         * @returns The name of the callable Shader at the index passed using the "shaderIndex" argument. 
         */
        static GetCallableShaderName(s: any, shaderIndex: number): string
        /** Returns the parameter size of a user-defined callable Shader from within a RayTracingShader.
         * @param s The RayTracingShader instance.
         * @param shaderIndex The callable Shader index for which to retrieve the parameter size.
         * @returns The parameter size in bytes. 
         */
        static GetCallableShaderParamSize(s: any, shaderIndex: number): number
        /** Clears all internally-cached data that was generated for the given shader, such as errors and compilation info.
         */
        static ClearCachedData(s: any): void
        /** Creates a new Shader object from the provided source code string. You can use this method alongside the ScriptedImporter to create custom shader generation tools in the Editor.
         * @param context A context object that the asset system needs to register shader dependencies properly.
         * @param source A string that contains a shader written in code.
         * @param compileInitialShaderVariants Set to true to compile the code contained in the source string; otherwise false.
         */
        static CreateShaderAsset(context: any, source: string, compileInitialShaderVariants: boolean): any
        /** Creates a new Shader object from the provided source code string. You can use this method alongside the ScriptedImporter to create custom shader generation tools in the Editor.
         * @param context A context object that the asset system needs to register shader dependencies properly.
         * @param source A string that contains a shader written in code.
         * @param compileInitialShaderVariants Set to true to compile the code contained in the source string; otherwise false.
         */
        static CreateShaderAsset(source: string, compileInitialShaderVariants: boolean): any
        /** Creates a new Shader object from the provided source code string. You can use this method alongside the ScriptedImporter to create custom shader generation tools in the Editor.
         * @param context A context object that the asset system needs to register shader dependencies properly.
         * @param source A string that contains a shader written in code.
         * @param compileInitialShaderVariants Set to true to compile the code contained in the source string; otherwise false.
         */
        static CreateShaderAsset(source: string): any
        /** Replaces the existing source code in the specified shader with the source code in the supplied string.
         * @param context A context object that the asset system needs to register shader dependencies properly.
         * @param source A string that contains a shader written in code.
         * @param compileInitialShaderVariants Set to true to compile the code contained in the source string; otherwise false.
         * @param shader The Shader to update.
         */
        static UpdateShaderAsset(context: any, shader: any, source: string, compileInitialShaderVariants: boolean): void
        /** Replaces the existing source code in the specified shader with the source code in the supplied string.
         * @param context A context object that the asset system needs to register shader dependencies properly.
         * @param source A string that contains a shader written in code.
         * @param compileInitialShaderVariants Set to true to compile the code contained in the source string; otherwise false.
         * @param shader The Shader to update.
         */
        static UpdateShaderAsset(shader: any, source: string, compileInitialShaderVariants: boolean): void
        /** Replaces the existing source code in the specified shader with the source code in the supplied string.
         * @param context A context object that the asset system needs to register shader dependencies properly.
         * @param source A string that contains a shader written in code.
         * @param compileInitialShaderVariants Set to true to compile the code contained in the source string; otherwise false.
         * @param shader The Shader to update.
         */
        static UpdateShaderAsset(shader: any, source: string): void
        /** Register a user created shader.
         */
        static RegisterShader(shader: any): void
        static GetAllShaderInfo(): Array<any>
        /** Adds shader compilation mode command in the CommandBuffer.
         * @param cmd Target CommandBuffer.
         * @param allow Is async Shader compilation allowed or not.
         */
        static SetAsyncCompilation(cmd: any, allow: boolean): void
        /** Restores the previous Shader compilation mode in this CommandBuffer scope.
         * @param cmd Target CommandBuffer.
         */
        static RestoreAsyncCompilation(cmd: any): void
        /** Checks if the Shader variant for the given pass in the Material has already been compiled.
         * @param material The Material to check against.
         * @param pass The index of the Shader pass to check.
         */
        static IsPassCompiled(material: Material, pass: number): boolean
        /** Request the Editor to compile the Shader Variant needed for the specific pass of the given Material.
         * @param material Target Material.
         * @param pass Index of the target Shader pass.
         * @param forceSync Forces the script execution to wait until the compilation has finished. Optional.
         */
        static CompilePass(material: Material, pass: number, forceSync: boolean): void
        /** Get the number of properties in Shader s.
         * @param s The shader to check against.
         */
        static GetPropertyCount(s: any): number
        /** Get the name of the shader propery at index propertyIdx of Shader s.
         * @param s The shader to check against.
         * @param propertyIdx The property index to use.
         */
        static GetPropertyName(s: any, propertyIdx: number): string
        /** Get the ShaderProperyType of the shader propery at index propertyIdx of Shader s.
         * @param s The shader to check against.
         * @param propertyIdx The property index to use.
         */
        static GetPropertyType(s: any, propertyIdx: number): any
        /** Get the description of the shader propery at index propertyIdx of Shader s.
         * @param s The shader to check against.
         * @param propertyIdx The property index to use.
         * @returns Returns the description of the given shader property. 
         */
        static GetPropertyDescription(s: any, propertyIdx: number): string
        /** Get Limits for a range property at index propertyIdx of Shader s.
         * @param defminmax Which value to get: 0 = default, 1 = min, 2 = max.
         * @param s The shader to check against.
         * @param propertyIdx The property index to use.
         */
        static GetRangeLimits(s: any, propertyIdx: number, defminmax: number): number
        /** Gets texture dimension of a shader property.
         * @param s The shader to get the property from.
         * @param propertyIdx The property index to use.
         * @returns Texture dimension. 
         */
        static GetTexDim(s: any, propertyIdx: number): any
        /** Is the shader propery at index propertyIdx of Shader s hidden?
         * @param s The shader to check against.
         * @param propertyIdx The property index to use.
         */
        static IsShaderPropertyHidden(s: any, propertyIdx: number): boolean
        /** Is the shader propery at index propertyIdx of Shader s a NonModifiableTextureProperty?
         * @param s The shader to check against.
         * @param propertyIdx The property index to use.
         */
        static IsShaderPropertyNonModifiableTexureProperty(s: any, propertyIdx: number): boolean
        /** Get the shader data for a specific shader.
         * @param shader The shader to get data from.
         * @returns The shader data for the provided shader. 
         */
        static GetShaderData(shader: any): any
        /** Returns true if the given Shader generated any errors. Ignores warnings.
         * @param shader The Shader instance to check for errors.
         * @returns True if the Shader generated errors, false if there were no errors. 
         */
        static ShaderHasError(shader: any): boolean
        protected constructor()
        /** Does the current hardware support render textues.
         */
        static readonly hardwareSupportsRectRenderTexture: boolean
        /** When true, the Editor is compiling some Shaders asynchronously at the point of query.
         */
        static readonly anythingCompiling: boolean
        /** When true, asynchronous Shader compilation is allowed at the current call site.
         */
        static allowAsyncCompilation: boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array, Enum } from "System";
    import { Object as Object1, Texture2D, Texture, Renderer, Camera, Rect, GUIContent, GameObject } from "UnityEngine";
    /** Editor utility functions.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class EditorUtility extends Object {
        /** Displays the "open file" dialog and returns the selected path name.
         */
        static OpenFilePanel(title: string, directory: string, extension: string): string
        /** Displays the "open file" dialog and returns the selected path name.
         * @param title Title for dialog.
         * @param directory Default directory.
         * @param filters File extensions in form { "Image files", "png,jpg,jpeg", "All files", "*" }.
         */
        static OpenFilePanelWithFilters(title: string, directory: string, filters: Array<string>): string
        static RevealInFinder(path: string): void
        /** This method displays a modal dialog that lets the user opt-out of being shown the current dialog box again.
         * @param title The title of the message box.
         * @param message The text of the message.
         * @param ok Label displayed on the OK dialog button.
         * @param cancel Label displayed on the Cancel dialog button.
         * @param dialogOptOutDecisionType The type of opt-out decision a user can make.
         * @param dialogOptOutDecisionStorageKey The unique key setting to store the decision under.
         * @returns true if the user clicks the ok button, or previously opted out. Returns false if the user cancels or closes the dialog without making a decision. 
         */
        static DisplayDialog(title: string, message: string, ok: string, cancel: string, dialogOptOutDecisionType: any, dialogOptOutDecisionStorageKey: string): boolean
        /** This method displays a modal dialog that lets the user opt-out of being shown the current dialog box again.
         * @param title The title of the message box.
         * @param message The text of the message.
         * @param ok Label displayed on the OK dialog button.
         * @param cancel Label displayed on the Cancel dialog button.
         * @param dialogOptOutDecisionType The type of opt-out decision a user can make.
         * @param dialogOptOutDecisionStorageKey The unique key setting to store the decision under.
         * @returns true if the user clicks the ok button, or previously opted out. Returns false if the user cancels or closes the dialog without making a decision. 
         */
        static DisplayDialog(title: string, message: string, ok: string, dialogOptOutDecisionType: any, dialogOptOutDecisionStorageKey: string): boolean
        /** This method displays a modal dialog.
         * @param title The title of the message box.
         * @param message The text of the message.
         * @param ok Label displayed on the OK dialog button.
         * @param cancel Label displayed on the Cancel dialog button.
         * @returns Returns true if the user clicks the OK button. Returns false otherwise. 
         */
        static DisplayDialog(title: string, message: string, ok: string, cancel: string): boolean
        /** This method displays a modal dialog.
         * @param title The title of the message box.
         * @param message The text of the message.
         * @param ok Label displayed on the OK dialog button.
         * @param cancel Label displayed on the Cancel dialog button.
         * @returns Returns true if the user clicks the OK button. Returns false otherwise. 
         */
        static DisplayDialog(title: string, message: string, ok: string): boolean
        /** Displays a modal dialog with three buttons.
         * @param title Title for dialog.
         * @param message Purpose for the dialog.
         * @param ok Dialog function chosen.
         * @param cancel Close dialog with no operation.
         * @param alt Choose alternative dialog purpose.
         * @returns Returns the id of the chosen button. The ids are 0, 1 or 2 corresponding to the ok, cancel and alt buttons respectively. 
         */
        static DisplayDialogComplex(title: string, message: string, ok: string, cancel: string, alt: string): number
        /** Displays the "open folder" dialog and returns the selected path name.
         */
        static OpenFolderPanel(title: string, folder: string, defaultName: string): string
        /** Displays the "save folder" dialog and returns the selected path name.
         */
        static SaveFolderPanel(title: string, folder: string, defaultName: string): string
        static WarnPrefab(target: Object1, title: string, warning: string, okButton: string): boolean
        /** Determines if an object is stored on disk.
         */
        static IsPersistent(target: Object1): boolean
        /** Displays the "save file" dialog and returns the selected path name.
         */
        static SaveFilePanel(title: string, directory: string, defaultName: string, extension: string): string
        /** Human-like sorting.
         */
        static NaturalCompare(a: string, b: string): number
        /** Translates an instance ID to a reference to an object.
         */
        static InstanceIDToObject(instanceID: number): Object1
        /** Compress a texture.
         */
        static CompressTexture(texture: Texture2D, format: any, quality: number): void
        /** Compress a texture.
         */
        static CompressTexture(texture: Texture2D, format: any, quality: any): void
        /** Compress a cubemap texture.
         */
        static CompressCubemapTexture(texture: any, format: any, quality: number): void
        /** Compress a cubemap texture.
         */
        static CompressCubemapTexture(texture: any, format: any, quality: any): void
        /** Marks target object as dirty. (Only suitable for non-scene objects).
         * @param target The object to mark as dirty.
         */
        static SetDirty(target: Object1): void
        /** Clear target's dirty flag.
         */
        static ClearDirty(target: Object1): void
        static InvokeDiffTool(leftTitle: string, leftFile: string, rightTitle: string, rightFile: string, ancestorTitle: string, ancestorFile: string): string
        /** Copy all settings of a Unity Object.
         */
        static CopySerialized(source: Object1, dest: Object1): void
        /** Copies the serializable fields from one managed object to another.
         * @param source The object to copy data from.
         * @param dest The object to copy data to.
         */
        static CopySerializedManagedFieldsOnly(source: Object, dest: Object): void
        /** Calculates and returns a list of all assets the assets listed in roots depend on.
         */
        static CollectDependencies(roots: Array<Object1>): Array<Object1>
        /** Collect all objects in the hierarchy rooted at each of the given objects.
         * @param roots Array of objects where the search will start.
         * @returns Array of objects heirarchically attached to the search array. 
         */
        static CollectDeepHierarchy(roots: Array<Object1>): Array<Object1>
        static FormatBytes(bytes: number): string
        /** Returns a text for a number of bytes.
         */
        static FormatBytes(bytes: number): string
        /** Displays or updates a progress bar.
         */
        static DisplayProgressBar(title: string, info: string, progress: number): void
        /** Displays or updates a progress bar that has a cancel button.
         */
        static DisplayCancelableProgressBar(title: string, info: string, progress: number): boolean
        static ClearProgressBar(): void
        /** Is the object enabled (0 disabled, 1 enabled, -1 has no enabled button).
         */
        static GetObjectEnabled(target: Object1): number
        /** Set the enabled state of the object.
         */
        static SetObjectEnabled(target: Object1, enabled: boolean): void
        /** Set the Scene View selected display mode for this Renderer.
         */
        static SetSelectedRenderState(renderer: Renderer, renderState: any): void
        static OpenWithDefaultApp(fileName: string): void
        /** Sets this camera to allow animation of materials in the Editor.
         */
        static SetCameraAnimateMaterials(camera: Camera, animate: boolean): void
        /** Sets the global time for this camera to use when rendering.
         */
        static SetCameraAnimateMaterialsTime(camera: Camera, time: number): void
        /** Updates the global shader properties to use when rendering.
         * @param time Time to use. -1 to disable.
         */
        static UpdateGlobalShaderProperties(time: number): void
        /** Returns an integer that indicates the number of times the specified object's serialized properties have changed.
         * @param instanceID The object's instance ID.
         * @param target The object.
         */
        static GetDirtyCount(instanceID: number): number
        /** Returns an integer that indicates the number of times the specified object's serialized properties have changed.
         * @param instanceID The object's instance ID.
         * @param target The object.
         */
        static GetDirtyCount(target: Object1): number
        /** Gets a boolean value that indicates whether the specified object has changed since the last time it was saved.
         * @param instanceID The object's instance ID.
         * @param target The object.
         * @returns True if the object has changed; otherwise false. 
         */
        static IsDirty(instanceID: number): boolean
        /** Gets a boolean value that indicates whether the specified object has changed since the last time it was saved.
         * @param instanceID The object's instance ID.
         * @param target The object.
         * @returns True if the object has changed; otherwise false. 
         */
        static IsDirty(target: Object1): boolean
        static FocusProjectWindow(): void
        static RequestScriptReload(): void
        static IsRunningUnderCPUEmulation(): boolean
        static LoadWindowLayout(path: string): boolean
        static SaveFilePanelInProject(title: string, defaultName: string, extension: string, message: string, path: string): string
        /** Displays the "save file" dialog in the Assets folder of the project and returns the selected path name.
         */
        static SaveFilePanelInProject(title: string, defaultName: string, extension: string, message: string): string
        /** Copy all settings of a Unity Object to a second Object if they differ.
         */
        static CopySerializedIfDifferent(source: Object1, dest: Object1): void
        static UnloadUnusedAssetsImmediate(includeMonoReferencesAsRoots: boolean): void
        static UnloadUnusedAssetsImmediate(): void
        /** This method displays a modal dialog that lets the user opt-out of being shown the current dialog box again.
         * @param dialogOptOutDecisionType The type of opt-out decision a user can make.
         * @param dialogOptOutDecisionStorageKey The unique key setting to store the decision under.
         * @returns true if the user previously opted out of seeing the dialog associated with dialogOptOutDecisionStorageKey. Returns false if the user did not yet opt out. 
         */
        static GetDialogOptOutDecision(dialogOptOutDecisionType: any, dialogOptOutDecisionStorageKey: string): boolean
        /** This method displays a modal dialog that lets the user opt-out of being shown the current dialog box again.
         * @param dialogOptOutDecisionType The type of opt-out decision a user can make.
         * @param dialogOptOutDecisionStorageKey The unique key setting to store the decision under.
         * @param optOutDecision The unique key setting to store the decision under.
         */
        static SetDialogOptOutDecision(dialogOptOutDecisionType: any, dialogOptOutDecisionStorageKey: string, optOutDecision: boolean): void
        /** Displays a popup menu.
         */
        static DisplayPopupMenu(position: Rect, menuItemPath: string, command: any): void
        static DisplayCustomMenu(position: Rect, options: Array<GUIContent>, checkEnabled: (arg: number) => boolean, selected: number, callback: (userData: Object, options: Array<string>, selected: number) => void, userData: Object, showHotkey: boolean): void
        static DisplayCustomMenu(position: Rect, options: Array<GUIContent>, selected: number, callback: (userData: Object, options: Array<string>, selected: number) => void, userData: Object, showHotkey: boolean): void
        static DisplayCustomMenu(position: Rect, options: Array<GUIContent>, selected: number, callback: (userData: Object, options: Array<string>, selected: number) => void, userData: Object): void
        /** Creates a game object with HideFlags and specified components.
         */
        static CreateGameObjectWithHideFlags(name: string, flags: any, ...components: any[]): GameObject
        static CompileCSharp(sources: Array<string>, references: Array<string>, defines: Array<string>, outputFile: string): Array<string>
        static DisplayCustomMenuWithSeparators(position: Rect, options: Array<string>, enabled: Array<boolean>, separator: Array<boolean>, selected: Array<number>, callback: (userData: Object, options: Array<string>, selected: number) => void, userData: Object): void
        protected constructor()
        static audioMasterMute: boolean
        /** True if there are any compilation error messages in the log.
         */
        static readonly scriptCompilationFailed: boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array, Enum } from "System";
    import { Rect, GUIStyle, GUIContent, Object as Object1, Vector2, Vector3, Vector4, Vector2Int, Vector3Int, RectInt, Bounds, BoundsInt, Color, AnimationCurve, FocusType, Texture, ScaleMode, Material, Gradient } from "UnityEngine";
    /** These work pretty much like the normal GUI functions - and also have matching implementations in EditorGUILayout.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class EditorGUI extends Object {
        /** Move keyboard focus to a named text field and begin editing of the content.
         * @param name Name set using GUI.SetNextControlName.
         */
        static FocusTextInControl(name: string): void
        /** Create a group of controls that can be disabled.
         * @param disabled Boolean specifying if the controls inside the group should be disabled.
         */
        static BeginDisabledGroup(disabled: boolean): void
        static EndDisabledGroup(): void
        static BeginChangeCheck(): void
        static EndChangeCheck(): boolean
        /** Draws a label with a drop shadow.
         * @param position Where to show the label.
         * @param content Text to show
@style style to use.
         */
        static DropShadowLabel(position: Rect, text: string, style: GUIStyle): void
        /** Draws a label with a drop shadow.
         * @param position Where to show the label.
         * @param content Text to show
@style style to use.
         */
        static DropShadowLabel(position: Rect, content: GUIContent, style: GUIStyle): void
        /** Draws a label with a drop shadow.
         * @param position Where to show the label.
         * @param content Text to show
@style style to use.
         */
        static DropShadowLabel(position: Rect, text: string): void
        /** Draws a label with a drop shadow.
         * @param position Where to show the label.
         * @param content Text to show
@style style to use.
         */
        static DropShadowLabel(position: Rect, content: GUIContent): void
        /** Makes a toggle.
         * @param position Rectangle on the screen to use for the toggle.
         * @param label Optional label in front of the toggle.
         * @param value The shown state of the toggle.
         * @param style Optional GUIStyle.
         * @returns The selected state of the toggle. 
         */
        static Toggle(position: Rect, label: string, value: boolean, style: GUIStyle): boolean
        /** Makes a toggle.
         * @param position Rectangle on the screen to use for the toggle.
         * @param label Optional label in front of the toggle.
         * @param value The shown state of the toggle.
         * @param style Optional GUIStyle.
         * @returns The selected state of the toggle. 
         */
        static Toggle(position: Rect, label: GUIContent, value: boolean, style: GUIStyle): boolean
        /** Makes a toggle.
         * @param position Rectangle on the screen to use for the toggle.
         * @param label Optional label in front of the toggle.
         * @param value The shown state of the toggle.
         * @param style Optional GUIStyle.
         * @returns The selected state of the toggle. 
         */
        static Toggle(position: Rect, label: string, value: boolean): boolean
        /** Makes a toggle.
         * @param position Rectangle on the screen to use for the toggle.
         * @param label Optional label in front of the toggle.
         * @param value The shown state of the toggle.
         * @param style Optional GUIStyle.
         * @returns The selected state of the toggle. 
         */
        static Toggle(position: Rect, value: boolean, style: GUIStyle): boolean
        /** Makes a toggle.
         * @param position Rectangle on the screen to use for the toggle.
         * @param label Optional label in front of the toggle.
         * @param value The shown state of the toggle.
         * @param style Optional GUIStyle.
         * @returns The selected state of the toggle. 
         */
        static Toggle(position: Rect, label: GUIContent, value: boolean): boolean
        /** Makes a toggle.
         * @param position Rectangle on the screen to use for the toggle.
         * @param label Optional label in front of the toggle.
         * @param value The shown state of the toggle.
         * @param style Optional GUIStyle.
         * @returns The selected state of the toggle. 
         */
        static Toggle(position: Rect, value: boolean): boolean
        /** Makes a slider the user can drag to change a value between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param label Optional label in front of the slider.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @returns The value that has been set by the user. 
         */
        static Slider(position: Rect, label: string, value: number, leftValue: number, rightValue: number): number
        /** Makes a slider the user can drag to change a value between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param label Optional label in front of the slider.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @returns The value that has been set by the user. 
         */
        static Slider(position: Rect, label: GUIContent, value: number, leftValue: number, rightValue: number): number
        /** Makes a slider the user can drag to change a value between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param label Optional label in front of the slider.
         * @param property The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         */
        static Slider(position: Rect, property: SerializedProperty, leftValue: number, rightValue: number, label: string): void
        /** Makes a slider the user can drag to change a value between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param label Optional label in front of the slider.
         * @param property The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         */
        static Slider(position: Rect, property: SerializedProperty, leftValue: number, rightValue: number, label: GUIContent): void
        /** Makes a slider the user can drag to change a value between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param label Optional label in front of the slider.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @returns The value that has been set by the user. 
         */
        static Slider(position: Rect, value: number, leftValue: number, rightValue: number): number
        /** Makes a slider the user can drag to change a value between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param label Optional label in front of the slider.
         * @param property The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         */
        static Slider(position: Rect, property: SerializedProperty, leftValue: number, rightValue: number): void
        /** Makes a slider the user can drag to change an integer value between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param label Optional label in front of the slider.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @returns The value that has been set by the user. 
         */
        static IntSlider(position: Rect, label: string, value: number, leftValue: number, rightValue: number): number
        /** Makes a slider the user can drag to change an integer value between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param label Optional label in front of the slider.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @returns The value that has been set by the user. 
         */
        static IntSlider(position: Rect, label: GUIContent, value: number, leftValue: number, rightValue: number): number
        /** Makes a slider the user can drag to change a value between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param label Optional label in front of the slider.
         * @param property The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         */
        static IntSlider(position: Rect, property: SerializedProperty, leftValue: number, rightValue: number, label: string): void
        /** Makes a slider the user can drag to change a value between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param label Optional label in front of the slider.
         * @param property The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         */
        static IntSlider(position: Rect, property: SerializedProperty, leftValue: number, rightValue: number, label: GUIContent): void
        /** Makes a slider the user can drag to change an integer value between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param label Optional label in front of the slider.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @returns The value that has been set by the user. 
         */
        static IntSlider(position: Rect, value: number, leftValue: number, rightValue: number): number
        /** Makes a slider the user can drag to change a value between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param label Optional label in front of the slider.
         * @param property The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         */
        static IntSlider(position: Rect, property: SerializedProperty, leftValue: number, rightValue: number): void
        /** Makes a special slider the user can use to specify a range between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param label Optional label in front of the slider.
         * @param minValue The lower value of the range the slider shows, passed by reference.
         * @param maxValue The upper value at the range the slider shows, passed by reference.
         * @param minLimit The limit at the left end of the slider.
         * @param maxLimit The limit at the right end of the slider.
         */
        static MinMaxSlider(position: Rect, label: string, minValue: jsb.Ref<number>, maxValue: jsb.Ref<number>, minLimit: number, maxLimit: number): void
        /** Makes a special slider the user can use to specify a range between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param label Optional label in front of the slider.
         * @param minValue The lower value of the range the slider shows, passed by reference.
         * @param maxValue The upper value at the range the slider shows, passed by reference.
         * @param minLimit The limit at the left end of the slider.
         * @param maxLimit The limit at the right end of the slider.
         */
        static MinMaxSlider(position: Rect, label: GUIContent, minValue: jsb.Ref<number>, maxValue: jsb.Ref<number>, minLimit: number, maxLimit: number): void
        /** Makes a special slider the user can use to specify a range between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param label Optional label in front of the slider.
         * @param minValue The lower value of the range the slider shows, passed by reference.
         * @param maxValue The upper value at the range the slider shows, passed by reference.
         * @param minLimit The limit at the left end of the slider.
         * @param maxLimit The limit at the right end of the slider.
         */
        static MinMaxSlider(position: Rect, minValue: jsb.Ref<number>, maxValue: jsb.Ref<number>, minLimit: number, maxLimit: number): void
        /** Displays a menu with an option for every value of the enum type when clicked. An option for the value 0 with name "Nothing" and an option for the value ~0 (that is, all bits set) with the name "Everything" are always displayed at the top of the menu. The names for the values 0 and ~0 can be overriden by defining these values in the enum type.
         * @param position Rectangle on the screen to use for the enum flags field.
         * @param label Optional label to display in front of the enum flags field.
         * @param enumValue Enum flags value (Only supports enum values for enum types with int as the underlying type).
         * @param style Optional GUIStyle.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @returns The enum flags value modified by the user. This is a selection BitMask where each bit represents an Enum value index. (Note this returned value is not itself an Enum). 
         */
        static EnumFlagsField(position: Rect, label: GUIContent, enumValue: Enum, includeObsolete: boolean, style: GUIStyle): Enum
        /** Displays a menu with an option for every value of the enum type when clicked. An option for the value 0 with name "Nothing" and an option for the value ~0 (that is, all bits set) with the name "Everything" are always displayed at the top of the menu. The names for the values 0 and ~0 can be overriden by defining these values in the enum type.
         * @param position Rectangle on the screen to use for the enum flags field.
         * @param label Optional label to display in front of the enum flags field.
         * @param enumValue Enum flags value (Only supports enum values for enum types with int as the underlying type).
         * @param style Optional GUIStyle.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @returns The enum flags value modified by the user. This is a selection BitMask where each bit represents an Enum value index. (Note this returned value is not itself an Enum). 
         */
        static EnumFlagsField(position: Rect, label: string, enumValue: Enum, style: GUIStyle): Enum
        /** Displays a menu with an option for every value of the enum type when clicked. An option for the value 0 with name "Nothing" and an option for the value ~0 (that is, all bits set) with the name "Everything" are always displayed at the top of the menu. The names for the values 0 and ~0 can be overriden by defining these values in the enum type.
         * @param position Rectangle on the screen to use for the enum flags field.
         * @param label Optional label to display in front of the enum flags field.
         * @param enumValue Enum flags value (Only supports enum values for enum types with int as the underlying type).
         * @param style Optional GUIStyle.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @returns The enum flags value modified by the user. This is a selection BitMask where each bit represents an Enum value index. (Note this returned value is not itself an Enum). 
         */
        static EnumFlagsField(position: Rect, label: GUIContent, enumValue: Enum, style: GUIStyle): Enum
        /** Displays a menu with an option for every value of the enum type when clicked. An option for the value 0 with name "Nothing" and an option for the value ~0 (that is, all bits set) with the name "Everything" are always displayed at the top of the menu. The names for the values 0 and ~0 can be overriden by defining these values in the enum type.
         * @param position Rectangle on the screen to use for the enum flags field.
         * @param label Optional label to display in front of the enum flags field.
         * @param enumValue Enum flags value (Only supports enum values for enum types with int as the underlying type).
         * @param style Optional GUIStyle.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @returns The enum flags value modified by the user. This is a selection BitMask where each bit represents an Enum value index. (Note this returned value is not itself an Enum). 
         */
        static EnumFlagsField(position: Rect, enumValue: Enum, style: GUIStyle): Enum
        /** Displays a menu with an option for every value of the enum type when clicked. An option for the value 0 with name "Nothing" and an option for the value ~0 (that is, all bits set) with the name "Everything" are always displayed at the top of the menu. The names for the values 0 and ~0 can be overriden by defining these values in the enum type.
         * @param position Rectangle on the screen to use for the enum flags field.
         * @param label Optional label to display in front of the enum flags field.
         * @param enumValue Enum flags value (Only supports enum values for enum types with int as the underlying type).
         * @param style Optional GUIStyle.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @returns The enum flags value modified by the user. This is a selection BitMask where each bit represents an Enum value index. (Note this returned value is not itself an Enum). 
         */
        static EnumFlagsField(position: Rect, label: string, enumValue: Enum): Enum
        /** Displays a menu with an option for every value of the enum type when clicked. An option for the value 0 with name "Nothing" and an option for the value ~0 (that is, all bits set) with the name "Everything" are always displayed at the top of the menu. The names for the values 0 and ~0 can be overriden by defining these values in the enum type.
         * @param position Rectangle on the screen to use for the enum flags field.
         * @param label Optional label to display in front of the enum flags field.
         * @param enumValue Enum flags value (Only supports enum values for enum types with int as the underlying type).
         * @param style Optional GUIStyle.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @returns The enum flags value modified by the user. This is a selection BitMask where each bit represents an Enum value index. (Note this returned value is not itself an Enum). 
         */
        static EnumFlagsField(position: Rect, label: GUIContent, enumValue: Enum): Enum
        /** Displays a menu with an option for every value of the enum type when clicked. An option for the value 0 with name "Nothing" and an option for the value ~0 (that is, all bits set) with the name "Everything" are always displayed at the top of the menu. The names for the values 0 and ~0 can be overriden by defining these values in the enum type.
         * @param position Rectangle on the screen to use for the enum flags field.
         * @param label Optional label to display in front of the enum flags field.
         * @param enumValue Enum flags value (Only supports enum values for enum types with int as the underlying type).
         * @param style Optional GUIStyle.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @returns The enum flags value modified by the user. This is a selection BitMask where each bit represents an Enum value index. (Note this returned value is not itself an Enum). 
         */
        static EnumFlagsField(position: Rect, enumValue: Enum): Enum
        /** Makes an object field. You can assign objects either by drag and drop objects or by selecting an object using the Object Picker.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param obj The object the field shows.
         * @param objType The type of the objects that can be assigned.
         * @param allowSceneObjects Allow assigning Scene objects. See Description for more info.
         * @returns The object that has been set by the user. 
         */
        static ObjectField(position: Rect, label: string, obj: Object1, objType: any, allowSceneObjects: boolean): Object1
        /** Makes an object field. You can assign objects either by drag and drop objects or by selecting an object using the Object Picker.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param obj The object the field shows.
         * @param objType The type of the objects that can be assigned.
         * @param allowSceneObjects Allow assigning Scene objects. See Description for more info.
         * @returns The object that has been set by the user. 
         */
        static ObjectField(position: Rect, label: GUIContent, obj: Object1, objType: any, allowSceneObjects: boolean): Object1
        /** Makes an object field. You can assign objects either by drag and drop objects or by selecting an object using the Object Picker.
         * @param position Rectangle on the screen to use for the field.
         * @param property The object reference property the field shows.
         * @param objType The type of the objects that can be assigned.
         * @param label Optional label to display in front of the field. Pass GUIContent.none to hide the label.
         */
        static ObjectField(position: Rect, property: SerializedProperty, objType: any, label: GUIContent): void
        /** Makes an object field. You can assign objects either by drag and drop objects or by selecting an object using the Object Picker.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param obj The object the field shows.
         * @param objType The type of the objects that can be assigned.
         * @param allowSceneObjects Allow assigning Scene objects. See Description for more info.
         * @returns The object that has been set by the user. 
         */
        static ObjectField(position: Rect, obj: Object1, objType: any, allowSceneObjects: boolean): Object1
        /** Makes an object field. You can assign objects either by drag and drop objects or by selecting an object using the Object Picker.
         * @param position Rectangle on the screen to use for the field.
         * @param property The object reference property the field shows.
         * @param objType The type of the objects that can be assigned.
         * @param label Optional label to display in front of the field. Pass GUIContent.none to hide the label.
         */
        static ObjectField(position: Rect, property: SerializedProperty, label: GUIContent): void
        /** Makes an object field. You can assign objects either by drag and drop objects or by selecting an object using the Object Picker.
         * @param position Rectangle on the screen to use for the field.
         * @param property The object reference property the field shows.
         * @param objType The type of the objects that can be assigned.
         * @param label Optional label to display in front of the field. Pass GUIContent.none to hide the label.
         */
        static ObjectField(position: Rect, property: SerializedProperty, objType: any): void
        /** Makes an object field. You can assign objects either by drag and drop objects or by selecting an object using the Object Picker.
         * @param position Rectangle on the screen to use for the field.
         * @param property The object reference property the field shows.
         * @param objType The type of the objects that can be assigned.
         * @param label Optional label to display in front of the field. Pass GUIContent.none to hide the label.
         */
        static ObjectField(position: Rect, property: SerializedProperty): void
        static IndentedRect(source: Rect): Rect
        /** Makes an X and Y field for entering a Vector2.
         * @param position Rectangle on the screen to use for the field.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static Vector2Field(position: Rect, label: string, value: Vector2): Vector2
        /** Makes an X and Y field for entering a Vector2.
         * @param position Rectangle on the screen to use for the field.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static Vector2Field(position: Rect, label: GUIContent, value: Vector2): Vector2
        /** Makes an X, Y, and Z field for entering a Vector3.
         * @param position Rectangle on the screen to use for the field.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static Vector3Field(position: Rect, label: string, value: Vector3): Vector3
        /** Makes an X, Y, and Z field for entering a Vector3.
         * @param position Rectangle on the screen to use for the field.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static Vector3Field(position: Rect, label: GUIContent, value: Vector3): Vector3
        /** Makes an X, Y, Z, and W field for entering a Vector4.
         * @param position Rectangle on the screen to use for the field.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static Vector4Field(position: Rect, label: string, value: Vector4): Vector4
        static Vector4Field(position: Rect, label: GUIContent, value: Vector4): Vector4
        /** Makes an X and Y integer field for entering a Vector2Int.
         * @param position Rectangle on the screen to use for the field.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static Vector2IntField(position: Rect, label: string, value: Vector2Int): Vector2Int
        /** Makes an X and Y integer field for entering a Vector2Int.
         * @param position Rectangle on the screen to use for the field.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static Vector2IntField(position: Rect, label: GUIContent, value: Vector2Int): Vector2Int
        /** Makes an X, Y, and Z integer field for entering a Vector3Int.
         * @param position Rectangle on the screen to use for the field.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static Vector3IntField(position: Rect, label: string, value: Vector3Int): Vector3Int
        /** Makes an X, Y, and Z integer field for entering a Vector3Int.
         * @param position Rectangle on the screen to use for the field.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static Vector3IntField(position: Rect, label: GUIContent, value: Vector3Int): Vector3Int
        /** Makes an X, Y, W, and H field for entering a Rect.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static RectField(position: Rect, label: string, value: Rect): Rect
        /** Makes an X, Y, W, and H field for entering a Rect.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static RectField(position: Rect, label: GUIContent, value: Rect): Rect
        /** Makes an X, Y, W, and H field for entering a Rect.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static RectField(position: Rect, value: Rect): Rect
        /** Makes an X, Y, W, and H field for entering a RectInt.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static RectIntField(position: Rect, label: string, value: RectInt): RectInt
        /** Makes an X, Y, W, and H field for entering a RectInt.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static RectIntField(position: Rect, label: GUIContent, value: RectInt): RectInt
        /** Makes an X, Y, W, and H field for entering a RectInt.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static RectIntField(position: Rect, value: RectInt): RectInt
        static BoundsField(position: Rect, label: string, value: Bounds): Bounds
        /** Makes Center and Extents field for entering a Bounds.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static BoundsField(position: Rect, label: GUIContent, value: Bounds): Bounds
        /** Makes Center and Extents field for entering a Bounds.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static BoundsField(position: Rect, value: Bounds): Bounds
        /** Makes Position and Size field for entering a BoundsInt.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static BoundsIntField(position: Rect, label: string, value: BoundsInt): BoundsInt
        /** Makes Position and Size field for entering a BoundsInt.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static BoundsIntField(position: Rect, label: GUIContent, value: BoundsInt): BoundsInt
        /** Makes Position and Size field for entering a BoundsInt.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static BoundsIntField(position: Rect, value: BoundsInt): BoundsInt
        /** Makes a multi-control with text fields for entering multiple floats in the same line.
         * @param position Rectangle on the screen to use for the float field.
         * @param label Optional label to display in front of the float field.
         * @param subLabels Array with small labels to show in front of each float field. There is room for one letter per field only.
         * @param values Array with the values to edit.
         */
        static MultiFloatField(position: Rect, label: GUIContent, subLabels: Array<GUIContent>, values: Array<number>): void
        /** Makes a multi-control with text fields for entering multiple floats in the same line.
         * @param position Rectangle on the screen to use for the float field.
         * @param label Optional label to display in front of the float field.
         * @param subLabels Array with small labels to show in front of each float field. There is room for one letter per field only.
         * @param values Array with the values to edit.
         */
        static MultiFloatField(position: Rect, subLabels: Array<GUIContent>, values: Array<number>): void
        /** Makes a multi-control with text fields for entering multiple integers in the same line.
         * @param position Rectangle on the screen to use for the integer field.
         * @param subLabels Array with small labels to show in front of each int field. There is room for one letter per field only.
         * @param values Array with the values to edit.
         */
        static MultiIntField(position: Rect, subLabels: Array<GUIContent>, values: Array<number>): void
        /** Makes a multi-control with several property fields in the same line.
         * @param position Rectangle on the screen to use for the multi-property field.
         * @param valuesIterator The SerializedProperty of the first property to make a control for.
         * @param label Optional label to use. If not specified the label of the property itself is used. Use GUIContent.none to not display a label at all.
         * @param subLabels Array with small labels to show in front of each float field. There is room for one letter per field only.
         */
        static MultiPropertyField(position: Rect, subLabels: Array<GUIContent>, valuesIterator: SerializedProperty, label: GUIContent): void
        /** Makes a multi-control with several property fields in the same line.
         * @param position Rectangle on the screen to use for the multi-property field.
         * @param valuesIterator The SerializedProperty of the first property to make a control for.
         * @param label Optional label to use. If not specified the label of the property itself is used. Use GUIContent.none to not display a label at all.
         * @param subLabels Array with small labels to show in front of each float field. There is room for one letter per field only.
         */
        static MultiPropertyField(position: Rect, subLabels: Array<GUIContent>, valuesIterator: SerializedProperty): void
        /** Makes a field for selecting a Color.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display in front of the field.
         * @param value The color to edit.
         * @param showEyedropper If true, the color picker should show the eyedropper control. If false, don't show it.
         * @param showAlpha If true, allow the user to set an alpha value for the color. If false, hide the alpha component.
         * @param hdr If true, treat the color as an HDR value. If false, treat it as a standard LDR value.
         * @returns The color selected by the user. 
         */
        static ColorField(position: Rect, label: GUIContent, value: Color, showEyedropper: boolean, showAlpha: boolean, hdr: boolean): Color
        /** Makes a field for selecting a Color.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display in front of the field.
         * @param value The color to edit.
         * @param showEyedropper If true, the color picker should show the eyedropper control. If false, don't show it.
         * @param showAlpha If true, allow the user to set an alpha value for the color. If false, hide the alpha component.
         * @param hdr If true, treat the color as an HDR value. If false, treat it as a standard LDR value.
         * @returns The color selected by the user. 
         */
        static ColorField(position: Rect, label: string, value: Color): Color
        /** Makes a field for selecting a Color.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display in front of the field.
         * @param value The color to edit.
         * @param showEyedropper If true, the color picker should show the eyedropper control. If false, don't show it.
         * @param showAlpha If true, allow the user to set an alpha value for the color. If false, hide the alpha component.
         * @param hdr If true, treat the color as an HDR value. If false, treat it as a standard LDR value.
         * @returns The color selected by the user. 
         */
        static ColorField(position: Rect, label: GUIContent, value: Color): Color
        /** Makes a field for selecting a Color.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display in front of the field.
         * @param value The color to edit.
         * @param showEyedropper If true, the color picker should show the eyedropper control. If false, don't show it.
         * @param showAlpha If true, allow the user to set an alpha value for the color. If false, hide the alpha component.
         * @param hdr If true, treat the color as an HDR value. If false, treat it as a standard LDR value.
         * @returns The color selected by the user. 
         */
        static ColorField(position: Rect, value: Color): Color
        /** Makes a field for editing an AnimationCurve.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display in front of the field.
         * @param value The curve to edit.
         * @param color The color to show the curve with.
         * @param ranges Optional rectangle that the curve is restrained within.
         * @returns The curve edited by the user. 
         */
        static CurveField(position: Rect, label: string, value: AnimationCurve, color: Color, ranges: Rect): AnimationCurve
        /** Makes a field for editing an AnimationCurve.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display in front of the field.
         * @param value The curve to edit.
         * @param color The color to show the curve with.
         * @param ranges Optional rectangle that the curve is restrained within.
         * @returns The curve edited by the user. 
         */
        static CurveField(position: Rect, label: GUIContent, value: AnimationCurve, color: Color, ranges: Rect): AnimationCurve
        /** Makes a field for editing an AnimationCurve.
         * @param position Rectangle on the screen to use for the field.
         * @param property The curve to edit.
         * @param color The color to show the curve with.
         * @param ranges Optional rectangle that the curve is restrained within.
         * @param label Optional label to display in front of the field. Pass [[GUIContent.none] to hide the label.
         */
        static CurveField(position: Rect, property: SerializedProperty, color: Color, ranges: Rect, label: GUIContent): void
        /** Makes a field for editing an AnimationCurve.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display in front of the field.
         * @param value The curve to edit.
         * @param color The color to show the curve with.
         * @param ranges Optional rectangle that the curve is restrained within.
         * @returns The curve edited by the user. 
         */
        static CurveField(position: Rect, value: AnimationCurve, color: Color, ranges: Rect): AnimationCurve
        /** Makes a field for editing an AnimationCurve.
         * @param position Rectangle on the screen to use for the field.
         * @param property The curve to edit.
         * @param color The color to show the curve with.
         * @param ranges Optional rectangle that the curve is restrained within.
         * @param label Optional label to display in front of the field. Pass [[GUIContent.none] to hide the label.
         */
        static CurveField(position: Rect, property: SerializedProperty, color: Color, ranges: Rect): void
        /** Makes a field for editing an AnimationCurve.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display in front of the field.
         * @param value The curve to edit.
         * @param color The color to show the curve with.
         * @param ranges Optional rectangle that the curve is restrained within.
         * @returns The curve edited by the user. 
         */
        static CurveField(position: Rect, label: string, value: AnimationCurve): AnimationCurve
        /** Makes a field for editing an AnimationCurve.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display in front of the field.
         * @param value The curve to edit.
         * @param color The color to show the curve with.
         * @param ranges Optional rectangle that the curve is restrained within.
         * @returns The curve edited by the user. 
         */
        static CurveField(position: Rect, label: GUIContent, value: AnimationCurve): AnimationCurve
        /** Makes a field for editing an AnimationCurve.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display in front of the field.
         * @param value The curve to edit.
         * @param color The color to show the curve with.
         * @param ranges Optional rectangle that the curve is restrained within.
         * @returns The curve edited by the user. 
         */
        static CurveField(position: Rect, value: AnimationCurve): AnimationCurve
        /** Makes an inspector-window-like titlebar.
         * @param position Rectangle on the screen to use for the titlebar.
         * @param foldout The foldout state shown with the arrow.
         * @param targetObj The object (for example a component) that the titlebar is for.
         * @param targetObjs The objects that the titlebar is for.
         * @param expandable Whether this editor should display a foldout arrow in order to toggle the display of its properties.
         * @returns The foldout state selected by the user. 
         */
        static InspectorTitlebar(position: Rect, foldout: boolean, targetObj: Object1, expandable: boolean): boolean
        /** Makes an inspector-window-like titlebar.
         * @param position Rectangle on the screen to use for the titlebar.
         * @param foldout The foldout state shown with the arrow.
         * @param targetObj The object (for example a component) that the titlebar is for.
         * @param targetObjs The objects that the titlebar is for.
         * @param expandable Whether this editor should display a foldout arrow in order to toggle the display of its properties.
         * @returns The foldout state selected by the user. 
         */
        static InspectorTitlebar(position: Rect, foldout: boolean, targetObjs: Array<Object1>, expandable: boolean): boolean
        static InspectorTitlebar(position: Rect, foldout: boolean, editor: Editor): boolean
        static InspectorTitlebar(position: Rect, targetObjs: Array<Object1>): void
        /** Makes a progress bar.
         * @param totalPosition Rectangle on the screen to use in total for both the control.
         * @param value Value that is shown.
         */
        static ProgressBar(position: Rect, value: number, text: string): void
        /** Makes a help box with a message to the user.
         * @param position Rectangle on the screen to draw the help box within.
         * @param message The message text.
         * @param type The type of message.
         */
        static HelpBox(position: Rect, message: string, type: MessageType): void
        /** Makes a label in front of some control.
         * @param totalPosition Rectangle on the screen to use in total for both the label and the control.
         * @param id The unique ID of the control. If none specified, the ID of the following control is used.
         * @param label Label to show in front of the control.
         * @param style Style to use for the label.
         * @returns Rectangle on the screen to use just for the control itself. 
         */
        static PrefixLabel(totalPosition: Rect, id: number, label: GUIContent, style: GUIStyle): Rect
        /** Makes a label in front of some control.
         * @param totalPosition Rectangle on the screen to use in total for both the label and the control.
         * @param id The unique ID of the control. If none specified, the ID of the following control is used.
         * @param label Label to show in front of the control.
         * @param style Style to use for the label.
         * @returns Rectangle on the screen to use just for the control itself. 
         */
        static PrefixLabel(totalPosition: Rect, label: GUIContent, style: GUIStyle): Rect
        /** Makes a label in front of some control.
         * @param totalPosition Rectangle on the screen to use in total for both the label and the control.
         * @param id The unique ID of the control. If none specified, the ID of the following control is used.
         * @param label Label to show in front of the control.
         * @param style Style to use for the label.
         * @returns Rectangle on the screen to use just for the control itself. 
         */
        static PrefixLabel(totalPosition: Rect, id: number, label: GUIContent): Rect
        /** Makes a label in front of some control.
         * @param totalPosition Rectangle on the screen to use in total for both the label and the control.
         * @param id The unique ID of the control. If none specified, the ID of the following control is used.
         * @param label Label to show in front of the control.
         * @param style Style to use for the label.
         * @returns Rectangle on the screen to use just for the control itself. 
         */
        static PrefixLabel(totalPosition: Rect, label: GUIContent): Rect
        /** Create a Property wrapper, useful for making regular GUI controls work with SerializedProperty.
         * @param totalPosition Rectangle on the screen to use for the control, including label if applicable.
         * @param label Optional label in front of the slider. Use null to use the name from the SerializedProperty. Use GUIContent.none to not display a label.
         * @param property The SerializedProperty to use for the control.
         * @returns The actual label to use for the control. 
         */
        static BeginProperty(totalPosition: Rect, label: GUIContent, property: SerializedProperty): GUIContent
        static EndProperty(): void
        /** Get the height needed for a PropertyField control.
         * @param property Height of the property area.
         * @param label Descriptive text or image.
         * @param includeChildren Should the returned height include the height of child properties?
         */
        static GetPropertyHeight(property: SerializedProperty, label: GUIContent, includeChildren: boolean): number
        /** Get the height needed for a PropertyField control.
         * @param property Height of the property area.
         * @param label Descriptive text or image.
         * @param includeChildren Should the returned height include the height of child properties?
         */
        static GetPropertyHeight(type: SerializedPropertyType, label: GUIContent): number
        /** Get the height needed for a PropertyField control.
         * @param property Height of the property area.
         * @param label Descriptive text or image.
         * @param includeChildren Should the returned height include the height of child properties?
         */
        static GetPropertyHeight(property: SerializedProperty, includeChildren: boolean): number
        /** Get the height needed for a PropertyField control.
         * @param property Height of the property area.
         * @param label Descriptive text or image.
         * @param includeChildren Should the returned height include the height of child properties?
         */
        static GetPropertyHeight(property: SerializedProperty, label: GUIContent): number
        /** Get the height needed for a PropertyField control.
         * @param property Height of the property area.
         * @param label Descriptive text or image.
         * @param includeChildren Should the returned height include the height of child properties?
         */
        static GetPropertyHeight(property: SerializedProperty): number
        /** Get whether a SerializedProperty's inspector GUI can be cached.
         * @param property The SerializedProperty in question.
         * @returns Whether the property's inspector GUI can be cached. 
         */
        static CanCacheInspectorGUI(property: SerializedProperty): boolean
        /** Makes a button that reacts to mouse down, for displaying your own dropdown content.
         * @param position Rectangle on the screen to use for the button.
         * @param content Text, image and tooltip for this button.
         * @param focusType Whether the button should be selectable by keyboard or not.
         * @param style Optional style to use.
         * @returns true when the user clicks the button. 
         */
        static DropdownButton(position: Rect, content: GUIContent, focusType: FocusType, style: GUIStyle): boolean
        /** Makes a button that reacts to mouse down, for displaying your own dropdown content.
         * @param position Rectangle on the screen to use for the button.
         * @param content Text, image and tooltip for this button.
         * @param focusType Whether the button should be selectable by keyboard or not.
         * @param style Optional style to use.
         * @returns true when the user clicks the button. 
         */
        static DropdownButton(position: Rect, content: GUIContent, focusType: FocusType): boolean
        /** Draws the alpha channel of a texture within a rectangle.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.
         * @param mipLevel What mip-level to sample. If negative, texture will be sampled normally.
It sets material _Mip property.
         */
        static DrawTextureAlpha(position: Rect, image: Texture, scaleMode: ScaleMode, imageAspect: number, mipLevel: number): void
        /** Draws the alpha channel of a texture within a rectangle.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.
         * @param mipLevel What mip-level to sample. If negative, texture will be sampled normally.
It sets material _Mip property.
         */
        static DrawTextureAlpha(position: Rect, image: Texture, scaleMode: ScaleMode, imageAspect: number): void
        /** Draws the alpha channel of a texture within a rectangle.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.
         * @param mipLevel What mip-level to sample. If negative, texture will be sampled normally.
It sets material _Mip property.
         */
        static DrawTextureAlpha(position: Rect, image: Texture, scaleMode: ScaleMode): void
        /** Draws the alpha channel of a texture within a rectangle.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.
         * @param mipLevel What mip-level to sample. If negative, texture will be sampled normally.
It sets material _Mip property.
         */
        static DrawTextureAlpha(position: Rect, image: Texture): void
        static DrawTextureTransparent(position: Rect, image: Texture, scaleMode: ScaleMode, imageAspect: number, mipLevel: number, colorWriteMask: any): void
        static DrawTextureTransparent(position: Rect, image: Texture, scaleMode: ScaleMode, imageAspect: number, mipLevel: number): void
        static DrawTextureTransparent(position: Rect, image: Texture, scaleMode: ScaleMode, imageAspect: number): void
        static DrawTextureTransparent(position: Rect, image: Texture, scaleMode: ScaleMode): void
        static DrawTextureTransparent(position: Rect, image: Texture): void
        /** Draws the texture within a rectangle.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param mat Material to be used when drawing the texture.
         * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.
         * @param mipLevel The mip-level to sample. If negative, the texture is sampled normally.
Sets material _Mip property.
         * @param colorWriteMask Specifies which color components of image will get written.
         */
        static DrawPreviewTexture(position: Rect, image: Texture, mat: Material, scaleMode: ScaleMode, imageAspect: number, mipLevel: number, colorWriteMask: any): void
        /** Draws the texture within a rectangle.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param mat Material to be used when drawing the texture.
         * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.
         * @param mipLevel The mip-level to sample. If negative, the texture is sampled normally.
Sets material _Mip property.
         * @param colorWriteMask Specifies which color components of image will get written.
         */
        static DrawPreviewTexture(position: Rect, image: Texture, mat: Material, scaleMode: ScaleMode, imageAspect: number, mipLevel: number): void
        /** Draws the texture within a rectangle.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param mat Material to be used when drawing the texture.
         * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.
         * @param mipLevel The mip-level to sample. If negative, the texture is sampled normally.
Sets material _Mip property.
         * @param colorWriteMask Specifies which color components of image will get written.
         */
        static DrawPreviewTexture(position: Rect, image: Texture, mat: Material, scaleMode: ScaleMode, imageAspect: number): void
        /** Draws the texture within a rectangle.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param mat Material to be used when drawing the texture.
         * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.
         * @param mipLevel The mip-level to sample. If negative, the texture is sampled normally.
Sets material _Mip property.
         * @param colorWriteMask Specifies which color components of image will get written.
         */
        static DrawPreviewTexture(position: Rect, image: Texture, mat: Material, scaleMode: ScaleMode): void
        /** Draws the texture within a rectangle.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param mat Material to be used when drawing the texture.
         * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.
         * @param mipLevel The mip-level to sample. If negative, the texture is sampled normally.
Sets material _Mip property.
         * @param colorWriteMask Specifies which color components of image will get written.
         */
        static DrawPreviewTexture(position: Rect, image: Texture, mat: Material): void
        /** Draws the texture within a rectangle.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param mat Material to be used when drawing the texture.
         * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.
         * @param mipLevel The mip-level to sample. If negative, the texture is sampled normally.
Sets material _Mip property.
         * @param colorWriteMask Specifies which color components of image will get written.
         */
        static DrawPreviewTexture(position: Rect, image: Texture): void
        /** Makes a label field. (Useful for showing read-only info.)
         * @param position Rectangle on the screen to use for the label field.
         * @param label Label in front of the label field.
         * @param label2 The label to show to the right.
         * @param style Style information (color, etc) for displaying the label.
         */
        static LabelField(position: Rect, label: string, label2: string, style: GUIStyle): void
        /** Makes a label field. (Useful for showing read-only info.)
         * @param position Rectangle on the screen to use for the label field.
         * @param label Label in front of the label field.
         * @param label2 The label to show to the right.
         * @param style Style information (color, etc) for displaying the label.
         */
        static LabelField(position: Rect, label: GUIContent, label2: GUIContent, style: GUIStyle): void
        /** Makes a label field. (Useful for showing read-only info.)
         * @param position Rectangle on the screen to use for the label field.
         * @param label Label in front of the label field.
         * @param label2 The label to show to the right.
         * @param style Style information (color, etc) for displaying the label.
         */
        static LabelField(position: Rect, label: string, style: GUIStyle): void
        /** Makes a label field. (Useful for showing read-only info.)
         * @param position Rectangle on the screen to use for the label field.
         * @param label Label in front of the label field.
         * @param label2 The label to show to the right.
         * @param style Style information (color, etc) for displaying the label.
         */
        static LabelField(position: Rect, label: GUIContent, style: GUIStyle): void
        /** Makes a label field. (Useful for showing read-only info.)
         * @param position Rectangle on the screen to use for the label field.
         * @param label Label in front of the label field.
         * @param label2 The label to show to the right.
         * @param style Style information (color, etc) for displaying the label.
         */
        static LabelField(position: Rect, label: string, label2: string): void
        /** Makes a label field. (Useful for showing read-only info.)
         * @param position Rectangle on the screen to use for the label field.
         * @param label Label in front of the label field.
         * @param label2 The label to show to the right.
         * @param style Style information (color, etc) for displaying the label.
         */
        static LabelField(position: Rect, label: GUIContent, label2: GUIContent): void
        /** Makes a label field. (Useful for showing read-only info.)
         * @param position Rectangle on the screen to use for the label field.
         * @param label Label in front of the label field.
         * @param label2 The label to show to the right.
         * @param style Style information (color, etc) for displaying the label.
         */
        static LabelField(position: Rect, label: string): void
        /** Makes a label field. (Useful for showing read-only info.)
         * @param position Rectangle on the screen to use for the label field.
         * @param label Label in front of the label field.
         * @param label2 The label to show to the right.
         * @param style Style information (color, etc) for displaying the label.
         */
        static LabelField(position: Rect, label: GUIContent): void
        /** Makes a toggle field where the toggle is to the left and the label immediately to the right of it.
         * @param position Rectangle on the screen to use for the toggle.
         * @param label Label to display next to the toggle.
         * @param value The value to edit.
         * @param labelStyle Optional GUIStyle to use for the label.
         * @returns The value set by the user. 
         */
        static ToggleLeft(position: Rect, label: string, value: boolean, labelStyle: GUIStyle): boolean
        /** Makes a toggle field where the toggle is to the left and the label immediately to the right of it.
         * @param position Rectangle on the screen to use for the toggle.
         * @param label Label to display next to the toggle.
         * @param value The value to edit.
         * @param labelStyle Optional GUIStyle to use for the label.
         * @returns The value set by the user. 
         */
        static ToggleLeft(position: Rect, label: GUIContent, value: boolean, labelStyle: GUIStyle): boolean
        /** Makes a toggle field where the toggle is to the left and the label immediately to the right of it.
         * @param position Rectangle on the screen to use for the toggle.
         * @param label Label to display next to the toggle.
         * @param value The value to edit.
         * @param labelStyle Optional GUIStyle to use for the label.
         * @returns The value set by the user. 
         */
        static ToggleLeft(position: Rect, label: string, value: boolean): boolean
        /** Makes a toggle field where the toggle is to the left and the label immediately to the right of it.
         * @param position Rectangle on the screen to use for the toggle.
         * @param label Label to display next to the toggle.
         * @param value The value to edit.
         * @param labelStyle Optional GUIStyle to use for the label.
         * @returns The value set by the user. 
         */
        static ToggleLeft(position: Rect, label: GUIContent, value: boolean): boolean
        /** Makes a text field.
         * @param position Rectangle on the screen to use for the text field.
         * @param label Optional label to display in front of the text field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @returns The text entered by the user. 
         */
        static TextField(position: Rect, label: string, text: string, style: GUIStyle): string
        /** Makes a text field.
         * @param position Rectangle on the screen to use for the text field.
         * @param label Optional label to display in front of the text field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @returns The text entered by the user. 
         */
        static TextField(position: Rect, label: GUIContent, text: string, style: GUIStyle): string
        /** Makes a text field.
         * @param position Rectangle on the screen to use for the text field.
         * @param label Optional label to display in front of the text field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @returns The text entered by the user. 
         */
        static TextField(position: Rect, text: string, style: GUIStyle): string
        /** Makes a text field.
         * @param position Rectangle on the screen to use for the text field.
         * @param label Optional label to display in front of the text field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @returns The text entered by the user. 
         */
        static TextField(position: Rect, label: string, text: string): string
        /** Makes a text field.
         * @param position Rectangle on the screen to use for the text field.
         * @param label Optional label to display in front of the text field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @returns The text entered by the user. 
         */
        static TextField(position: Rect, label: GUIContent, text: string): string
        /** Makes a text field.
         * @param position Rectangle on the screen to use for the text field.
         * @param label Optional label to display in front of the text field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @returns The text entered by the user. 
         */
        static TextField(position: Rect, text: string): string
        static DelayedTextField(position: Rect, label: GUIContent, controlId: number, text: string, style: GUIStyle): string
        /** Makes a delayed text field.
         * @param position Rectangle on the screen to use for the text field.
         * @param label Optional label to display in front of the int field.
         * @param text The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the text field. 
         */
        static DelayedTextField(position: Rect, label: string, text: string, style: GUIStyle): string
        /** Makes a delayed text field.
         * @param position Rectangle on the screen to use for the text field.
         * @param label Optional label to display in front of the int field.
         * @param text The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the text field. 
         */
        static DelayedTextField(position: Rect, label: GUIContent, text: string, style: GUIStyle): string
        static DelayedTextField(position: Rect, label: GUIContent, controlId: number, text: string): string
        /** Makes a delayed text field.
         * @param position Rectangle on the screen to use for the text field.
         * @param label Optional label to display in front of the int field.
         * @param text The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the text field. 
         */
        static DelayedTextField(position: Rect, text: string, style: GUIStyle): string
        static DelayedTextField(position: Rect, label: string, text: string): string
        static DelayedTextField(position: Rect, label: GUIContent, text: string): string
        /** Makes a delayed text field.
         * @param position Rectangle on the screen to use for the text field.
         * @param property The text property to edit.
         * @param label Optional label to display in front of the int field. Pass GUIContent.none to hide label.
         */
        static DelayedTextField(position: Rect, property: SerializedProperty, label: GUIContent): void
        static DelayedTextField(position: Rect, text: string): string
        static DelayedTextField(position: Rect, property: SerializedProperty): void
        /** Makes a text area.
         * @param position Rectangle on the screen to use for the text field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @returns The text entered by the user. 
         */
        static TextArea(position: Rect, text: string, style: GUIStyle): string
        /** Makes a text area.
         * @param position Rectangle on the screen to use for the text field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @returns The text entered by the user. 
         */
        static TextArea(position: Rect, text: string): string
        /** Makes a selectable label field. (Useful for showing read-only info that can be copy-pasted.)
         * @param position Rectangle on the screen to use for the label.
         * @param text The text to show.
         * @param style Optional GUIStyle.
         */
        static SelectableLabel(position: Rect, text: string, style: GUIStyle): void
        /** Makes a selectable label field. (Useful for showing read-only info that can be copy-pasted.)
         * @param position Rectangle on the screen to use for the label.
         * @param text The text to show.
         * @param style Optional GUIStyle.
         */
        static SelectableLabel(position: Rect, text: string): void
        /** Makes a text field where the user can enter a password.
         * @param position Rectangle on the screen to use for the password field.
         * @param label Optional label to display in front of the password field.
         * @param password The password to edit.
         * @param style Optional GUIStyle.
         * @returns The password entered by the user. 
         */
        static PasswordField(position: Rect, label: string, password: string, style: GUIStyle): string
        /** Makes a text field where the user can enter a password.
         * @param position Rectangle on the screen to use for the password field.
         * @param label Optional label to display in front of the password field.
         * @param password The password to edit.
         * @param style Optional GUIStyle.
         * @returns The password entered by the user. 
         */
        static PasswordField(position: Rect, label: GUIContent, password: string, style: GUIStyle): string
        /** Makes a text field where the user can enter a password.
         * @param position Rectangle on the screen to use for the password field.
         * @param label Optional label to display in front of the password field.
         * @param password The password to edit.
         * @param style Optional GUIStyle.
         * @returns The password entered by the user. 
         */
        static PasswordField(position: Rect, password: string, style: GUIStyle): string
        /** Makes a text field where the user can enter a password.
         * @param position Rectangle on the screen to use for the password field.
         * @param label Optional label to display in front of the password field.
         * @param password The password to edit.
         * @param style Optional GUIStyle.
         * @returns The password entered by the user. 
         */
        static PasswordField(position: Rect, label: string, password: string): string
        /** Makes a text field where the user can enter a password.
         * @param position Rectangle on the screen to use for the password field.
         * @param label Optional label to display in front of the password field.
         * @param password The password to edit.
         * @param style Optional GUIStyle.
         * @returns The password entered by the user. 
         */
        static PasswordField(position: Rect, label: GUIContent, password: string): string
        /** Makes a text field where the user can enter a password.
         * @param position Rectangle on the screen to use for the password field.
         * @param label Optional label to display in front of the password field.
         * @param password The password to edit.
         * @param style Optional GUIStyle.
         * @returns The password entered by the user. 
         */
        static PasswordField(position: Rect, password: string): string
        /** Makes a text field for entering floats.
         * @param position Rectangle on the screen to use for the float field.
         * @param label Optional label to display in front of the float field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. 
         */
        static FloatField(position: Rect, label: string, value: number, style: GUIStyle): number
        /** Makes a text field for entering floats.
         * @param position Rectangle on the screen to use for the float field.
         * @param label Optional label to display in front of the float field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. 
         */
        static FloatField(position: Rect, label: GUIContent, value: number, style: GUIStyle): number
        /** Makes a text field for entering floats.
         * @param position Rectangle on the screen to use for the float field.
         * @param label Optional label to display in front of the float field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. 
         */
        static FloatField(position: Rect, value: number, style: GUIStyle): number
        static FloatField(position: Rect, label: string, value: number): number
        static FloatField(position: Rect, label: GUIContent, value: number): number
        static FloatField(position: Rect, value: number): number
        /** Makes a delayed text field for entering floats.
         * @param position Rectangle on the screen to use for the float field.
         * @param label Optional label to display in front of the float field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the float field. 
         */
        static DelayedFloatField(position: Rect, label: string, value: number, style: GUIStyle): number
        /** Makes a delayed text field for entering floats.
         * @param position Rectangle on the screen to use for the float field.
         * @param label Optional label to display in front of the float field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the float field. 
         */
        static DelayedFloatField(position: Rect, label: GUIContent, value: number, style: GUIStyle): number
        /** Makes a delayed text field for entering floats.
         * @param position Rectangle on the screen to use for the float field.
         * @param label Optional label to display in front of the float field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the float field. 
         */
        static DelayedFloatField(position: Rect, value: number, style: GUIStyle): number
        static DelayedFloatField(position: Rect, label: string, value: number): number
        static DelayedFloatField(position: Rect, label: GUIContent, value: number): number
        /** Makes a delayed text field for entering floats.
         * @param position Rectangle on the screen to use for the float field.
         * @param property The float property to edit.
         * @param label Optional label to display in front of the float field. Pass GUIContent.none to hide label.
         */
        static DelayedFloatField(position: Rect, property: SerializedProperty, label: GUIContent): void
        static DelayedFloatField(position: Rect, value: number): number
        static DelayedFloatField(position: Rect, property: SerializedProperty): void
        /** Makes a text field for entering doubles.
         * @param position Rectangle on the screen to use for the double field.
         * @param label Optional label to display in front of the double field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. 
         */
        static DoubleField(position: Rect, label: string, value: number, style: GUIStyle): number
        /** Makes a text field for entering doubles.
         * @param position Rectangle on the screen to use for the double field.
         * @param label Optional label to display in front of the double field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. 
         */
        static DoubleField(position: Rect, label: GUIContent, value: number, style: GUIStyle): number
        /** Makes a text field for entering doubles.
         * @param position Rectangle on the screen to use for the double field.
         * @param label Optional label to display in front of the double field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. 
         */
        static DoubleField(position: Rect, value: number, style: GUIStyle): number
        static DoubleField(position: Rect, label: string, value: number): number
        static DoubleField(position: Rect, label: GUIContent, value: number): number
        static DoubleField(position: Rect, value: number): number
        /** Makes a delayed text field for entering doubles.
         * @param position Rectangle on the screen to use for the double field.
         * @param label Optional label to display in front of the double field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the double field. 
         */
        static DelayedDoubleField(position: Rect, label: string, value: number, style: GUIStyle): number
        /** Makes a delayed text field for entering doubles.
         * @param position Rectangle on the screen to use for the double field.
         * @param label Optional label to display in front of the double field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the double field. 
         */
        static DelayedDoubleField(position: Rect, label: GUIContent, value: number, style: GUIStyle): number
        /** Makes a delayed text field for entering doubles.
         * @param position Rectangle on the screen to use for the double field.
         * @param label Optional label to display in front of the double field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the double field. 
         */
        static DelayedDoubleField(position: Rect, value: number, style: GUIStyle): number
        static DelayedDoubleField(position: Rect, label: string, value: number): number
        static DelayedDoubleField(position: Rect, label: GUIContent, value: number): number
        static DelayedDoubleField(position: Rect, value: number): number
        /** Makes a text field for entering integers.
         * @param position Rectangle on the screen to use for the int field.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. 
         */
        static IntField(position: Rect, label: string, value: number, style: GUIStyle): number
        /** Makes a text field for entering integers.
         * @param position Rectangle on the screen to use for the int field.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. 
         */
        static IntField(position: Rect, label: GUIContent, value: number, style: GUIStyle): number
        /** Makes a text field for entering integers.
         * @param position Rectangle on the screen to use for the int field.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. 
         */
        static IntField(position: Rect, value: number, style: GUIStyle): number
        /** Makes a text field for entering integers.
         * @param position Rectangle on the screen to use for the int field.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. 
         */
        static IntField(position: Rect, label: string, value: number): number
        /** Makes a text field for entering integers.
         * @param position Rectangle on the screen to use for the int field.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. 
         */
        static IntField(position: Rect, label: GUIContent, value: number): number
        /** Makes a text field for entering integers.
         * @param position Rectangle on the screen to use for the int field.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. 
         */
        static IntField(position: Rect, value: number): number
        /** Makes a delayed text field for entering integers.
         * @param position Rectangle on the screen to use for the int field.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the int field. 
         */
        static DelayedIntField(position: Rect, label: string, value: number, style: GUIStyle): number
        /** Makes a delayed text field for entering integers.
         * @param position Rectangle on the screen to use for the int field.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the int field. 
         */
        static DelayedIntField(position: Rect, label: GUIContent, value: number, style: GUIStyle): number
        /** Makes a delayed text field for entering integers.
         * @param position Rectangle on the screen to use for the int field.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the int field. 
         */
        static DelayedIntField(position: Rect, value: number, style: GUIStyle): number
        static DelayedIntField(position: Rect, label: string, value: number): number
        static DelayedIntField(position: Rect, label: GUIContent, value: number): number
        /** The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the int field.
         * @param position Rectangle on the screen to use for the int field.
         * @param property The int property to edit.
         * @param label Optional label to display in front of the int field. Pass GUIContent.none to hide label.
         */
        static DelayedIntField(position: Rect, property: SerializedProperty, label: GUIContent): void
        static DelayedIntField(position: Rect, value: number): number
        static DelayedIntField(position: Rect, property: SerializedProperty): void
        /** Makes a text field for entering long integers.
         * @param position Rectangle on the screen to use for the long field.
         * @param label Optional label to display in front of the long field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. 
         */
        static LongField(position: Rect, label: string, value: number, style: GUIStyle): number
        /** Makes a text field for entering long integers.
         * @param position Rectangle on the screen to use for the long field.
         * @param label Optional label to display in front of the long field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. 
         */
        static LongField(position: Rect, label: GUIContent, value: number, style: GUIStyle): number
        static LongField(position: Rect, value: number, style: GUIStyle): number
        /** Makes a text field for entering long integers.
         * @param position Rectangle on the screen to use for the long field.
         * @param label Optional label to display in front of the long field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. 
         */
        static LongField(position: Rect, label: string, value: number): number
        /** Makes a text field for entering long integers.
         * @param position Rectangle on the screen to use for the long field.
         * @param label Optional label to display in front of the long field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. 
         */
        static LongField(position: Rect, label: GUIContent, value: number): number
        /** Makes a text field for entering long integers.
         * @param position Rectangle on the screen to use for the long field.
         * @param label Optional label to display in front of the long field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. 
         */
        static LongField(position: Rect, value: number): number
        /** Makes a generic popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selectedIndex The index of the option the field shows.
         * @param displayedOptions An array with the options shown in the popup.
         * @param style Optional GUIStyle.
         * @returns The index of the option that has been selected by the user. 
         */
        static Popup(position: Rect, label: string, selectedIndex: number, displayedOptions: Array<string>, style: GUIStyle): number
        /** Makes a generic popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selectedIndex The index of the option the field shows.
         * @param displayedOptions An array with the options shown in the popup.
         * @param style Optional GUIStyle.
         * @returns The index of the option that has been selected by the user. 
         */
        static Popup(position: Rect, label: GUIContent, selectedIndex: number, displayedOptions: Array<GUIContent>, style: GUIStyle): number
        /** Makes a generic popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selectedIndex The index of the option the field shows.
         * @param displayedOptions An array with the options shown in the popup.
         * @param style Optional GUIStyle.
         * @returns The index of the option that has been selected by the user. 
         */
        static Popup(position: Rect, selectedIndex: number, displayedOptions: Array<string>, style: GUIStyle): number
        /** Makes a generic popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selectedIndex The index of the option the field shows.
         * @param displayedOptions An array with the options shown in the popup.
         * @param style Optional GUIStyle.
         * @returns The index of the option that has been selected by the user. 
         */
        static Popup(position: Rect, selectedIndex: number, displayedOptions: Array<GUIContent>, style: GUIStyle): number
        /** Makes a generic popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selectedIndex The index of the option the field shows.
         * @param displayedOptions An array with the options shown in the popup.
         * @param style Optional GUIStyle.
         * @returns The index of the option that has been selected by the user. 
         */
        static Popup(position: Rect, label: string, selectedIndex: number, displayedOptions: Array<string>): number
        /** Makes a generic popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selectedIndex The index of the option the field shows.
         * @param displayedOptions An array with the options shown in the popup.
         * @param style Optional GUIStyle.
         * @returns The index of the option that has been selected by the user. 
         */
        static Popup(position: Rect, label: GUIContent, selectedIndex: number, displayedOptions: Array<GUIContent>): number
        /** Makes a generic popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selectedIndex The index of the option the field shows.
         * @param displayedOptions An array with the options shown in the popup.
         * @param style Optional GUIStyle.
         * @returns The index of the option that has been selected by the user. 
         */
        static Popup(position: Rect, selectedIndex: number, displayedOptions: Array<string>): number
        /** Makes a generic popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selectedIndex The index of the option the field shows.
         * @param displayedOptions An array with the options shown in the popup.
         * @param style Optional GUIStyle.
         * @returns The index of the option that has been selected by the user. 
         */
        static Popup(position: Rect, selectedIndex: number, displayedOptions: Array<GUIContent>): number
        static EnumPopup(position: Rect, label: GUIContent, selected: Enum, checkEnabled: (arg: Enum) => boolean, includeObsolete: boolean, style: GUIStyle): Enum
        /** Makes an enum popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selected The enum option the field shows.
         * @param style Optional GUIStyle.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @param checkEnabled Method called for each Enum value displayed. The specified method should return true if the option can be selected, false otherwise.
         * @returns The enum option that has been selected by the user. 
         */
        static EnumPopup(position: Rect, label: string, selected: Enum, style: GUIStyle): Enum
        /** Makes an enum popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selected The enum option the field shows.
         * @param style Optional GUIStyle.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @param checkEnabled Method called for each Enum value displayed. The specified method should return true if the option can be selected, false otherwise.
         * @returns The enum option that has been selected by the user. 
         */
        static EnumPopup(position: Rect, label: GUIContent, selected: Enum, style: GUIStyle): Enum
        /** Makes an enum popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selected The enum option the field shows.
         * @param style Optional GUIStyle.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @param checkEnabled Method called for each Enum value displayed. The specified method should return true if the option can be selected, false otherwise.
         * @returns The enum option that has been selected by the user. 
         */
        static EnumPopup(position: Rect, selected: Enum, style: GUIStyle): Enum
        /** Makes an enum popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selected The enum option the field shows.
         * @param style Optional GUIStyle.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @param checkEnabled Method called for each Enum value displayed. The specified method should return true if the option can be selected, false otherwise.
         * @returns The enum option that has been selected by the user. 
         */
        static EnumPopup(position: Rect, label: string, selected: Enum): Enum
        /** Makes an enum popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selected The enum option the field shows.
         * @param style Optional GUIStyle.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @param checkEnabled Method called for each Enum value displayed. The specified method should return true if the option can be selected, false otherwise.
         * @returns The enum option that has been selected by the user. 
         */
        static EnumPopup(position: Rect, label: GUIContent, selected: Enum): Enum
        /** Makes an enum popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selected The enum option the field shows.
         * @param style Optional GUIStyle.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @param checkEnabled Method called for each Enum value displayed. The specified method should return true if the option can be selected, false otherwise.
         * @returns The enum option that has been selected by the user. 
         */
        static EnumPopup(position: Rect, selected: Enum): Enum
        /** Makes an integer popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selectedValue The value of the option the field shows.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option. If optionValues a direct mapping of selectedValue to displayedOptions is assumed.
         * @param style Optional GUIStyle.
         * @returns The value of the option that has been selected by the user. 
         */
        static IntPopup(position: Rect, label: GUIContent, selectedValue: number, displayedOptions: Array<GUIContent>, optionValues: Array<number>, style: GUIStyle): number
        /** Makes an integer popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selectedValue The value of the option the field shows.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option. If optionValues a direct mapping of selectedValue to displayedOptions is assumed.
         * @param style Optional GUIStyle.
         * @returns The value of the option that has been selected by the user. 
         */
        static IntPopup(position: Rect, label: string, selectedValue: number, displayedOptions: Array<string>, optionValues: Array<number>, style: GUIStyle): number
        /** Makes an integer popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selectedValue The value of the option the field shows.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option. If optionValues a direct mapping of selectedValue to displayedOptions is assumed.
         * @param style Optional GUIStyle.
         * @returns The value of the option that has been selected by the user. 
         */
        static IntPopup(position: Rect, selectedValue: number, displayedOptions: Array<string>, optionValues: Array<number>, style: GUIStyle): number
        /** Makes an integer popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selectedValue The value of the option the field shows.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option. If optionValues a direct mapping of selectedValue to displayedOptions is assumed.
         * @param style Optional GUIStyle.
         * @returns The value of the option that has been selected by the user. 
         */
        static IntPopup(position: Rect, selectedValue: number, displayedOptions: Array<GUIContent>, optionValues: Array<number>, style: GUIStyle): number
        /** Makes an integer popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selectedValue The value of the option the field shows.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option. If optionValues a direct mapping of selectedValue to displayedOptions is assumed.
         * @param style Optional GUIStyle.
         * @returns The value of the option that has been selected by the user. 
         */
        static IntPopup(position: Rect, label: GUIContent, selectedValue: number, displayedOptions: Array<GUIContent>, optionValues: Array<number>): number
        /**
         * @param position Rectangle on the screen to use for the field.
         * @param property The SerializedProperty to use for the control.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option. If optionValues a direct   mapping of selectedValue to displayedOptions is assumed.
         * @param label Optional label in front of the field.
         */
        static IntPopup(position: Rect, property: SerializedProperty, displayedOptions: Array<GUIContent>, optionValues: Array<number>, label: GUIContent): void
        /** Makes an integer popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selectedValue The value of the option the field shows.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option. If optionValues a direct mapping of selectedValue to displayedOptions is assumed.
         * @param style Optional GUIStyle.
         * @returns The value of the option that has been selected by the user. 
         */
        static IntPopup(position: Rect, label: string, selectedValue: number, displayedOptions: Array<string>, optionValues: Array<number>): number
        /** Makes an integer popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selectedValue The value of the option the field shows.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option. If optionValues a direct mapping of selectedValue to displayedOptions is assumed.
         * @param style Optional GUIStyle.
         * @returns The value of the option that has been selected by the user. 
         */
        static IntPopup(position: Rect, selectedValue: number, displayedOptions: Array<string>, optionValues: Array<number>): number
        /** Makes an integer popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selectedValue The value of the option the field shows.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option. If optionValues a direct mapping of selectedValue to displayedOptions is assumed.
         * @param style Optional GUIStyle.
         * @returns The value of the option that has been selected by the user. 
         */
        static IntPopup(position: Rect, selectedValue: number, displayedOptions: Array<GUIContent>, optionValues: Array<number>): number
        /**
         * @param position Rectangle on the screen to use for the field.
         * @param property The SerializedProperty to use for the control.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option. If optionValues a direct   mapping of selectedValue to displayedOptions is assumed.
         * @param label Optional label in front of the field.
         */
        static IntPopup(position: Rect, property: SerializedProperty, displayedOptions: Array<GUIContent>, optionValues: Array<number>): void
        /** Makes a tag selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param tag The tag the field shows.
         * @param style Optional GUIStyle.
         * @returns The tag selected by the user. 
         */
        static TagField(position: Rect, label: string, tag: string, style: GUIStyle): string
        /** Makes a tag selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param tag The tag the field shows.
         * @param style Optional GUIStyle.
         * @returns The tag selected by the user. 
         */
        static TagField(position: Rect, label: GUIContent, tag: string, style: GUIStyle): string
        /** Makes a tag selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param tag The tag the field shows.
         * @param style Optional GUIStyle.
         * @returns The tag selected by the user. 
         */
        static TagField(position: Rect, tag: string, style: GUIStyle): string
        /** Makes a tag selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param tag The tag the field shows.
         * @param style Optional GUIStyle.
         * @returns The tag selected by the user. 
         */
        static TagField(position: Rect, label: string, tag: string): string
        /** Makes a tag selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param tag The tag the field shows.
         * @param style Optional GUIStyle.
         * @returns The tag selected by the user. 
         */
        static TagField(position: Rect, label: GUIContent, tag: string): string
        /** Makes a tag selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param tag The tag the field shows.
         * @param style Optional GUIStyle.
         * @returns The tag selected by the user. 
         */
        static TagField(position: Rect, tag: string): string
        /** Makes a layer selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param layer The layer shown in the field.
         * @param style Optional GUIStyle.
         * @returns The layer selected by the user. 
         */
        static LayerField(position: Rect, label: string, layer: number, style: GUIStyle): number
        /** Makes a layer selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param layer The layer shown in the field.
         * @param style Optional GUIStyle.
         * @returns The layer selected by the user. 
         */
        static LayerField(position: Rect, label: GUIContent, layer: number, style: GUIStyle): number
        /** Makes a layer selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param layer The layer shown in the field.
         * @param style Optional GUIStyle.
         * @returns The layer selected by the user. 
         */
        static LayerField(position: Rect, layer: number, style: GUIStyle): number
        /** Makes a layer selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param layer The layer shown in the field.
         * @param style Optional GUIStyle.
         * @returns The layer selected by the user. 
         */
        static LayerField(position: Rect, label: string, layer: number): number
        /** Makes a layer selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param layer The layer shown in the field.
         * @param style Optional GUIStyle.
         * @returns The layer selected by the user. 
         */
        static LayerField(position: Rect, label: GUIContent, layer: number): number
        /** Makes a layer selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param layer The layer shown in the field.
         * @param style Optional GUIStyle.
         * @returns The layer selected by the user. 
         */
        static LayerField(position: Rect, layer: number): number
        /** Makes a field for masks.
         * @param position Rectangle on the screen to use for this control.
         * @param label Label for the field.
         * @param mask The current mask to display.
         * @param displayedOption A string array containing the labels for each flag.
         * @param style Optional GUIStyle.
         * @param displayedOptions A string array containing the labels for each flag.
         * @returns The value modified by the user. 
         */
        static MaskField(position: Rect, label: GUIContent, mask: number, displayedOptions: Array<string>, style: GUIStyle): number
        /** Makes a field for masks.
         * @param position Rectangle on the screen to use for this control.
         * @param label Label for the field.
         * @param mask The current mask to display.
         * @param displayedOption A string array containing the labels for each flag.
         * @param style Optional GUIStyle.
         * @param displayedOptions A string array containing the labels for each flag.
         * @returns The value modified by the user. 
         */
        static MaskField(position: Rect, label: string, mask: number, displayedOptions: Array<string>, style: GUIStyle): number
        /** Makes a field for masks.
         * @param position Rectangle on the screen to use for this control.
         * @param label Label for the field.
         * @param mask The current mask to display.
         * @param displayedOption A string array containing the labels for each flag.
         * @param style Optional GUIStyle.
         * @param displayedOptions A string array containing the labels for each flag.
         * @returns The value modified by the user. 
         */
        static MaskField(position: Rect, label: GUIContent, mask: number, displayedOptions: Array<string>): number
        /** Makes a field for masks.
         * @param position Rectangle on the screen to use for this control.
         * @param label Label for the field.
         * @param mask The current mask to display.
         * @param displayedOption A string array containing the labels for each flag.
         * @param style Optional GUIStyle.
         * @param displayedOptions A string array containing the labels for each flag.
         * @returns The value modified by the user. 
         */
        static MaskField(position: Rect, label: string, mask: number, displayedOptions: Array<string>): number
        /** Makes a field for masks.
         * @param position Rectangle on the screen to use for this control.
         * @param label Label for the field.
         * @param mask The current mask to display.
         * @param displayedOption A string array containing the labels for each flag.
         * @param style Optional GUIStyle.
         * @param displayedOptions A string array containing the labels for each flag.
         * @returns The value modified by the user. 
         */
        static MaskField(position: Rect, mask: number, displayedOptions: Array<string>, style: GUIStyle): number
        /** Makes a field for masks.
         * @param position Rectangle on the screen to use for this control.
         * @param label Label for the field.
         * @param mask The current mask to display.
         * @param displayedOption A string array containing the labels for each flag.
         * @param style Optional GUIStyle.
         * @param displayedOptions A string array containing the labels for each flag.
         * @returns The value modified by the user. 
         */
        static MaskField(position: Rect, mask: number, displayedOptions: Array<string>): number
        /** Makes a label with a foldout arrow to the left of it.
         * @param position Rectangle on the screen to use for the arrow and label.
         * @param foldout The shown foldout state.
         * @param content The label to show.
         * @param style Optional GUIStyle.
         * @param toggleOnLabelClick Should the label be a clickable part of the control?
         * @returns The foldout state selected by the user. If true, you should render sub-objects. 
         */
        static Foldout(position: Rect, foldout: boolean, content: string, toggleOnLabelClick: boolean, style: GUIStyle): boolean
        /** Makes a label with a foldout arrow to the left of it.
         * @param position Rectangle on the screen to use for the arrow and label.
         * @param foldout The shown foldout state.
         * @param content The label to show.
         * @param style Optional GUIStyle.
         * @param toggleOnLabelClick Should the label be a clickable part of the control?
         * @returns The foldout state selected by the user. If true, you should render sub-objects. 
         */
        static Foldout(position: Rect, foldout: boolean, content: GUIContent, toggleOnLabelClick: boolean, style: GUIStyle): boolean
        /** Makes a label with a foldout arrow to the left of it.
         * @param position Rectangle on the screen to use for the arrow and label.
         * @param foldout The shown foldout state.
         * @param content The label to show.
         * @param style Optional GUIStyle.
         * @param toggleOnLabelClick Should the label be a clickable part of the control?
         * @returns The foldout state selected by the user. If true, you should render sub-objects. 
         */
        static Foldout(position: Rect, foldout: boolean, content: string, style: GUIStyle): boolean
        /** Makes a label with a foldout arrow to the left of it.
         * @param position Rectangle on the screen to use for the arrow and label.
         * @param foldout The shown foldout state.
         * @param content The label to show.
         * @param style Optional GUIStyle.
         * @param toggleOnLabelClick Should the label be a clickable part of the control?
         * @returns The foldout state selected by the user. If true, you should render sub-objects. 
         */
        static Foldout(position: Rect, foldout: boolean, content: string, toggleOnLabelClick: boolean): boolean
        /** Makes a label with a foldout arrow to the left of it.
         * @param position Rectangle on the screen to use for the arrow and label.
         * @param foldout The shown foldout state.
         * @param content The label to show.
         * @param style Optional GUIStyle.
         * @param toggleOnLabelClick Should the label be a clickable part of the control?
         * @returns The foldout state selected by the user. If true, you should render sub-objects. 
         */
        static Foldout(position: Rect, foldout: boolean, content: GUIContent, style: GUIStyle): boolean
        /** Makes a label with a foldout arrow to the left of it.
         * @param position Rectangle on the screen to use for the arrow and label.
         * @param foldout The shown foldout state.
         * @param content The label to show.
         * @param style Optional GUIStyle.
         * @param toggleOnLabelClick Should the label be a clickable part of the control?
         * @returns The foldout state selected by the user. If true, you should render sub-objects. 
         */
        static Foldout(position: Rect, foldout: boolean, content: GUIContent, toggleOnLabelClick: boolean): boolean
        /** Makes a label with a foldout arrow to the left of it.
         * @param position Rectangle on the screen to use for the arrow and label.
         * @param foldout The shown foldout state.
         * @param content The label to show.
         * @param style Optional GUIStyle.
         * @param toggleOnLabelClick Should the label be a clickable part of the control?
         * @returns The foldout state selected by the user. If true, you should render sub-objects. 
         */
        static Foldout(position: Rect, foldout: boolean, content: string): boolean
        /** Makes a label with a foldout arrow to the left of it.
         * @param position Rectangle on the screen to use for the arrow and label.
         * @param foldout The shown foldout state.
         * @param content The label to show.
         * @param style Optional GUIStyle.
         * @param toggleOnLabelClick Should the label be a clickable part of the control?
         * @returns The foldout state selected by the user. If true, you should render sub-objects. 
         */
        static Foldout(position: Rect, foldout: boolean, content: GUIContent): boolean
        /** Makes a label for some control.
         * @param totalPosition Rectangle on the screen to use in total for both the label and the control.
         * @param labelPosition Rectangle on the screen to use for the label.
         * @param label Label to show for the control.
         * @param id The unique ID of the control. If none specified, the ID of the following control is used.
         * @param style Optional GUIStyle to use for the label.
         */
        static HandlePrefixLabel(totalPosition: Rect, labelPosition: Rect, label: GUIContent, id: number, style: GUIStyle): void
        /** Makes a label for some control.
         * @param totalPosition Rectangle on the screen to use in total for both the label and the control.
         * @param labelPosition Rectangle on the screen to use for the label.
         * @param label Label to show for the control.
         * @param id The unique ID of the control. If none specified, the ID of the following control is used.
         * @param style Optional GUIStyle to use for the label.
         */
        static HandlePrefixLabel(totalPosition: Rect, labelPosition: Rect, label: GUIContent, id: number): void
        /** Makes a label for some control.
         * @param totalPosition Rectangle on the screen to use in total for both the label and the control.
         * @param labelPosition Rectangle on the screen to use for the label.
         * @param label Label to show for the control.
         * @param id The unique ID of the control. If none specified, the ID of the following control is used.
         * @param style Optional GUIStyle to use for the label.
         */
        static HandlePrefixLabel(totalPosition: Rect, labelPosition: Rect, label: GUIContent): void
        /** Use this to make a field for a SerializedProperty in the Editor.
         * @param position Rectangle on the screen to use for the property field.
         * @param property The SerializedProperty to make a field for.
         * @param label Optional label to use. If not specified the label of the property itself is used. Use GUIContent.none to not display a label at all.
         * @param includeChildren If true the property including children is drawn; otherwise only the control itself (such as only a foldout but nothing below it).
         * @returns True if the property has children and is expanded and includeChildren was set to false; otherwise false. 
         */
        static PropertyField(position: Rect, property: SerializedProperty, label: GUIContent, includeChildren: boolean): boolean
        /** Use this to make a field for a SerializedProperty in the Editor.
         * @param position Rectangle on the screen to use for the property field.
         * @param property The SerializedProperty to make a field for.
         * @param label Optional label to use. If not specified the label of the property itself is used. Use GUIContent.none to not display a label at all.
         * @param includeChildren If true the property including children is drawn; otherwise only the control itself (such as only a foldout but nothing below it).
         * @returns True if the property has children and is expanded and includeChildren was set to false; otherwise false. 
         */
        static PropertyField(position: Rect, property: SerializedProperty, includeChildren: boolean): boolean
        static PropertyField(position: Rect, property: SerializedProperty, label: GUIContent): boolean
        static PropertyField(position: Rect, property: SerializedProperty): boolean
        static BeginFoldoutHeaderGroup(position: Rect, foldout: boolean, content: string, style: GUIStyle, menuAction: (obj: Rect) => void, menuIcon: GUIStyle): boolean
        static BeginFoldoutHeaderGroup(position: Rect, foldout: boolean, content: GUIContent, style: GUIStyle, menuAction: (obj: Rect) => void, menuIcon: GUIStyle): boolean
        static EndFoldoutHeaderGroup(): void
        /** Makes a field for editing a Gradient.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display in front of the field.
         * @param gradient The gradient to edit.
         * @param hdr Display the HDR Gradient Editor.
         * @returns The gradient edited by the user. 
         */
        static GradientField(position: Rect, label: GUIContent, gradient: Gradient, hdr: boolean): Gradient
        /** Makes a field for editing a Gradient.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display in front of the field.
         * @param gradient The gradient to edit.
         * @param hdr Display the HDR Gradient Editor.
         * @returns The gradient edited by the user. 
         */
        static GradientField(position: Rect, label: string, gradient: Gradient): Gradient
        /** Makes a field for editing a Gradient.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display in front of the field.
         * @param gradient The gradient to edit.
         * @param hdr Display the HDR Gradient Editor.
         * @returns The gradient edited by the user. 
         */
        static GradientField(position: Rect, label: GUIContent, gradient: Gradient): Gradient
        /** Makes a field for editing a Gradient.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display in front of the field.
         * @param gradient The gradient to edit.
         * @param hdr Display the HDR Gradient Editor.
         * @returns The gradient edited by the user. 
         */
        static GradientField(position: Rect, gradient: Gradient): Gradient
        /** Draws a filled rectangle of color at the specified position and size within the current editor window.
         * @param rect The position and size of the rectangle to draw.
         * @param color The color of the rectange.
         */
        static DrawRect(rect: Rect, color: Color): void
        protected constructor()
        /** Makes the following controls give the appearance of editing multiple different values.
         */
        static showMixedValue: boolean
        /** Is the platform-dependent "action" modifier key held down? (Read Only)
         */
        static readonly actionKey: boolean
        /** The indent level of the field labels.
         */
        static indentLevel: number
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { GUIUtility, Texture2D, Vector2, Event, Rect, GUIStyle, GUIContent, Texture, Object as Object1, GUISkin, Color, AnimationCurve } from "UnityEngine";
    import { List } from "System.Collections.Generic";
    import { Object, Array, Enum } from "System";
    /** Miscellaneous helper stuff for EditorGUI.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class EditorGUIUtility extends GUIUtility {
        static SerializeMainMenuToString(): string
        static SetMenuLocalizationTestMode(onoff: boolean): void
        /** Set icons rendered as part of GUIContent to be rendered at a specific size.
         */
        static SetIconSize(size: Vector2): void
        static SetWantsMouseJumping(wantz: number): void
        /** Check if any enabled camera can render to a particular display.
         * @param displayIndex Display index.
         * @returns True if a camera will render to the display. 
         */
        static IsDisplayReferencedByCameras(displayIndex: number): boolean
        /** Send an input event into the game.
         */
        static QueueGameViewInputEvent(evt: Event): void
        /** Converts a position from point to pixel space.
         * @param rect A GUI position in point space.
         * @returns The same position in pixel space. 
         */
        static PointsToPixels(rect: Rect): Rect
        /** Convert a Rect from point space to pixel space.
         * @param position A GUI rect measured in points.
         * @returns A rect representing the same area in pixels. 
         */
        static PointsToPixels(position: Vector2): Vector2
        /** Convert a Rect from pixel space to point space.
         * @param rect A GUI rect measured in pixels.
         * @returns A rect representing the same area in points. 
         */
        static PixelsToPoints(rect: Rect): Rect
        /** Convert a position from pixel to point space.
         * @param position A GUI position in pixel space.
         * @returns A vector representing the same position in point space. 
         */
        static PixelsToPoints(position: Vector2): Vector2
        static GetFlowLayoutedRects(rect: Rect, style: GUIStyle, horizontalSpacing: number, verticalSpacing: number, items: List<string>): any
        /** Get a texture from its source filename.
         */
        static FindTexture(name: string): Texture2D
        static TrTextContent(key: string, text: string, tooltip: string, icon: Texture): GUIContent
        static TrTextContent(text: string, tooltip: string, icon: Texture): GUIContent
        static TrTextContent(text: string, tooltip: string, iconName: string): GUIContent
        static TrTextContent(text: string, icon: Texture): GUIContent
        static TrTextContentWithIcon(text: string, tooltip: string, iconName: string): GUIContent
        static TrTextContentWithIcon(text: string, tooltip: string, icon: Texture): GUIContent
        static TrTextContentWithIcon(text: string, tooltip: string, messageType: MessageType): GUIContent
        static TrTextContentWithIcon(text: string, icon: Texture): GUIContent
        static TrTextContentWithIcon(text: string, iconName: string): GUIContent
        static TrTextContentWithIcon(text: string, messageType: MessageType): GUIContent
        static TrIconContent(iconName: string, tooltip: string): GUIContent
        static TrIconContent(icon: Texture, tooltip: string): GUIContent
        static TrTempContent(texts: Array<string>, tooltips: Array<string>): Array<GUIContent>
        static TrTempContent(t: string): GUIContent
        static TrTempContent(texts: Array<string>): Array<GUIContent>
        /** Fetch the GUIContent from the Unity builtin resources with the given name.
         * @param name Name of the desired icon.
         * @param text Tooltip for hovering over the icon.
         */
        static IconContent(name: string, text: string): GUIContent
        /** Fetch the GUIContent from the Unity builtin resources with the given name.
         * @param name Name of the desired icon.
         * @param text Tooltip for hovering over the icon.
         */
        static IconContent(name: string): GUIContent
        /** Return a GUIContent object with the name and icon of an Object.
         */
        static ObjectContent(obj: Object1, type: any): GUIContent
        /** Does a given class have per-object thumbnails?
         */
        static HasObjectThumbnail(objType: any): boolean
        static GetIconSize(): Vector2
        /** Get one of the built-in GUI skins, which can be the game view, inspector or Scene view skin as chosen by the parameter.
         */
        static GetBuiltinSkin(skin: any): GUISkin
        /** Load a required built-in resource.
         */
        static LoadRequired(path: string): Object1
        /** Load a built-in resource.
         */
        static Load(path: string): Object1
        /** Ping an object in the Scene like clicking it in an inspector.
         * @param obj The object to be pinged.
         */
        static PingObject(obj: Object1): void
        /** Ping an object in the Scene like clicking it in an inspector.
         * @param obj The object to be pinged.
         */
        static PingObject(targetInstanceID: number): void
        /** Creates an event that can be sent to another window.
         * @param commandName The command to be sent.
         */
        static CommandEvent(commandName: string): Event
        /** Draw a color swatch.
         * @param position The rectangle to draw the color swatch within.
         * @param color The color to draw.
         */
        static DrawColorSwatch(position: Rect, color: Color): void
        static DrawCurveSwatch(position: Rect, curve: AnimationCurve, property: SerializedProperty, color: Color, bgColor: Color, topFillColor: Color, bottomFillColor: Color, curveRanges: Rect): void
        static DrawCurveSwatch(position: Rect, curve: AnimationCurve, property: SerializedProperty, color: Color, bgColor: Color, topFillColor: Color, bottomFillColor: Color): void
        /** Draw a curve swatch.
         * @param position The rectangle to draw the color swatch within.
         * @param curve The curve to draw.
         * @param property The curve to draw as a SerializedProperty.
         * @param color The color to draw the curve with.
         * @param bgColor The color to draw the background with.
         * @param curveRanges Optional parameter to specify the range of the curve which should be included in swatch.
         */
        static DrawCurveSwatch(position: Rect, curve: AnimationCurve, property: SerializedProperty, color: Color, bgColor: Color, curveRanges: Rect): void
        /** Draw a curve swatch.
         * @param position The rectangle to draw the color swatch within.
         * @param curve The curve to draw.
         * @param property The curve to draw as a SerializedProperty.
         * @param color The color to draw the curve with.
         * @param bgColor The color to draw the background with.
         * @param curveRanges Optional parameter to specify the range of the curve which should be included in swatch.
         */
        static DrawCurveSwatch(position: Rect, curve: AnimationCurve, property: SerializedProperty, color: Color, bgColor: Color): void
        /** Draw swatch with a filled region between two SerializedProperty curves.
         */
        static DrawRegionSwatch(position: Rect, property: SerializedProperty, property2: SerializedProperty, color: Color, bgColor: Color, curveRanges: Rect): void
        /** Draw swatch with a filled region between two curves.
         */
        static DrawRegionSwatch(position: Rect, curve: AnimationCurve, curve2: AnimationCurve, color: Color, bgColor: Color, curveRanges: Rect): void
        /** Add a custom mouse pointer to a control.
         * @param position The rectangle the control should be shown within.
         * @param mouse The mouse cursor to use.
         * @param controlID ID of a target control.
         */
        static AddCursorRect(position: Rect, mouse: MouseCursor, controlID: number): void
        /** Add a custom mouse pointer to a control.
         * @param position The rectangle the control should be shown within.
         * @param mouse The mouse cursor to use.
         * @param controlID ID of a target control.
         */
        static AddCursorRect(position: Rect, mouse: MouseCursor): void
        static GetObjectPickerObject(): Object1
        static GetObjectPickerControlID(): number
        protected constructor()
        /** Get a white texture.
         */
        static readonly whiteTexture: Texture2D
        /** The system copy buffer.
         */
        static systemCopyBuffer: string
        /** The scale of GUI points relative to screen pixels for the current view

This value is the number of screen pixels per point of interface space. For instance, 2.0 on retina displays. Note that the value may differ from one view to the next if the views are on monitors with different UI scales.
         */
        static readonly pixelsPerPoint: number
        /** Get the height used for a single Editor control such as a one-line EditorGUI.TextField or EditorGUI.Popup.
         */
        static readonly singleLineHeight: number
        /** Get the height used by default for vertical spacing between controls.
         */
        static readonly standardVerticalSpacing: number
        /** Is the user currently using the pro skin? (Read Only)
         */
        static readonly isProSkin: boolean
        /** Is a text field currently editing text?
         */
        static editingTextField: boolean
        /** True if a text field currently has focused and the text in it is selected.
         */
        static readonly textFieldHasSelection: boolean
        /** Is the Editor GUI is hierarchy mode?
         */
        static hierarchyMode: boolean
        /** Is the Editor GUI currently in wide mode?
         */
        static wideMode: boolean
        /** The width of the GUI area for the current EditorWindow or other view.
         */
        static readonly currentViewWidth: number
        /** The width in pixels reserved for labels of Editor GUI controls.
         */
        static labelWidth: number
        /** The minimum width in pixels reserved for the fields of Editor GUI controls.
         */
        static fieldWidth: number
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array, Enum } from "System";
    import { GUIStyle, GUIContent, GUILayoutOption, Object as Object1, Vector2, Vector3, Vector4, Vector2Int, Vector3Int, Rect, RectInt, Bounds, BoundsInt, Color, AnimationCurve, FocusType, Gradient, ScriptableObject } from "UnityEngine";
    /** Auto laid out version of EditorGUI.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class EditorGUILayout extends Object {
        /** Make a label with a foldout arrow to the left of it.
         * @param foldout The shown foldout state.
         * @param content The label to show.
         * @param style Optional GUIStyle.
         * @param toggleOnLabelClick Specifies whether clicking the label toggles the foldout state. The default value is false. Set to true to include the label in the clickable area.
         * @returns The foldout state selected by the user. If true, you should render sub-objects. 
         */
        static Foldout(foldout: boolean, content: string, toggleOnLabelClick: boolean, style: GUIStyle): boolean
        /** Make a label with a foldout arrow to the left of it.
         * @param foldout The shown foldout state.
         * @param content The label to show.
         * @param style Optional GUIStyle.
         * @param toggleOnLabelClick Specifies whether clicking the label toggles the foldout state. The default value is false. Set to true to include the label in the clickable area.
         * @returns The foldout state selected by the user. If true, you should render sub-objects. 
         */
        static Foldout(foldout: boolean, content: GUIContent, toggleOnLabelClick: boolean, style: GUIStyle): boolean
        /** Make a label with a foldout arrow to the left of it.
         * @param foldout The shown foldout state.
         * @param content The label to show.
         * @param style Optional GUIStyle.
         * @param toggleOnLabelClick Specifies whether clicking the label toggles the foldout state. The default value is false. Set to true to include the label in the clickable area.
         * @returns The foldout state selected by the user. If true, you should render sub-objects. 
         */
        static Foldout(foldout: boolean, content: string, style: GUIStyle): boolean
        /** Make a label with a foldout arrow to the left of it.
         * @param foldout The shown foldout state.
         * @param content The label to show.
         * @param style Optional GUIStyle.
         * @param toggleOnLabelClick Specifies whether clicking the label toggles the foldout state. The default value is false. Set to true to include the label in the clickable area.
         * @returns The foldout state selected by the user. If true, you should render sub-objects. 
         */
        static Foldout(foldout: boolean, content: GUIContent, style: GUIStyle): boolean
        static Foldout(foldout: boolean, content: string, toggleOnLabelClick: boolean): boolean
        static Foldout(foldout: boolean, content: GUIContent, toggleOnLabelClick: boolean): boolean
        /** Make a label with a foldout arrow to the left of it.
         * @param foldout The shown foldout state.
         * @param content The label to show.
         * @param style Optional GUIStyle.
         * @param toggleOnLabelClick Specifies whether clicking the label toggles the foldout state. The default value is false. Set to true to include the label in the clickable area.
         * @returns The foldout state selected by the user. If true, you should render sub-objects. 
         */
        static Foldout(foldout: boolean, content: string): boolean
        /** Make a label with a foldout arrow to the left of it.
         * @param foldout The shown foldout state.
         * @param content The label to show.
         * @param style Optional GUIStyle.
         * @param toggleOnLabelClick Specifies whether clicking the label toggles the foldout state. The default value is false. Set to true to include the label in the clickable area.
         * @returns The foldout state selected by the user. If true, you should render sub-objects. 
         */
        static Foldout(foldout: boolean, content: GUIContent): boolean
        /** Make a label in front of some control.
         * @param label Label to show to the left of the control.
         */
        static PrefixLabel(label: string, followingStyle: GUIStyle, labelStyle: GUIStyle): void
        /** Make a label in front of some control.
         * @param label Label to show to the left of the control.
         */
        static PrefixLabel(label: GUIContent, followingStyle: GUIStyle, labelStyle: GUIStyle): void
        /** Make a label in front of some control.
         * @param label Label to show to the left of the control.
         */
        static PrefixLabel(label: string, followingStyle: GUIStyle): void
        /** Make a label in front of some control.
         * @param label Label to show to the left of the control.
         */
        static PrefixLabel(label: GUIContent, followingStyle: GUIStyle): void
        /** Make a label in front of some control.
         * @param label Label to show to the left of the control.
         */
        static PrefixLabel(label: string): void
        /** Make a label in front of some control.
         * @param label Label to show to the left of the control.
         */
        static PrefixLabel(label: GUIContent): void
        /** Make a label field. (Useful for showing read-only info.)
         * @param label Label in front of the label field.
         * @param label2 The label to show to the right.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static LabelField(label: string, label2: string, style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Make a label field. (Useful for showing read-only info.)
         * @param label Label in front of the label field.
         * @param label2 The label to show to the right.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static LabelField(label: GUIContent, label2: GUIContent, style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Make a label field. (Useful for showing read-only info.)
         * @param label Label in front of the label field.
         * @param label2 The label to show to the right.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static LabelField(label: string, style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Make a label field. (Useful for showing read-only info.)
         * @param label Label in front of the label field.
         * @param label2 The label to show to the right.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static LabelField(label: GUIContent, style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Make a label field. (Useful for showing read-only info.)
         * @param label Label in front of the label field.
         * @param label2 The label to show to the right.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static LabelField(label: string, label2: string, ...options: GUILayoutOption[]): void
        /** Make a label field. (Useful for showing read-only info.)
         * @param label Label in front of the label field.
         * @param label2 The label to show to the right.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static LabelField(label: GUIContent, label2: GUIContent, ...options: GUILayoutOption[]): void
        /** Make a label field. (Useful for showing read-only info.)
         * @param label Label in front of the label field.
         * @param label2 The label to show to the right.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static LabelField(label: string, ...options: GUILayoutOption[]): void
        /** Make a label field. (Useful for showing read-only info.)
         * @param label Label in front of the label field.
         * @param label2 The label to show to the right.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static LabelField(label: GUIContent, ...options: GUILayoutOption[]): void
        /** Make a toggle.
         * @param label Optional label in front of the toggle.
         * @param value The shown state of the toggle.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout
        properties. Any values passed in here will override settings defined by the style.<br>

See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The selected state of the toggle. 
         */
        static Toggle(label: string, value: boolean, style: GUIStyle, ...options: GUILayoutOption[]): boolean
        /** Make a toggle.
         * @param label Optional label in front of the toggle.
         * @param value The shown state of the toggle.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout
        properties. Any values passed in here will override settings defined by the style.<br>

See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The selected state of the toggle. 
         */
        static Toggle(label: GUIContent, value: boolean, style: GUIStyle, ...options: GUILayoutOption[]): boolean
        /** Make a toggle.
         * @param label Optional label in front of the toggle.
         * @param value The shown state of the toggle.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout
        properties. Any values passed in here will override settings defined by the style.<br>

See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The selected state of the toggle. 
         */
        static Toggle(label: string, value: boolean, ...options: GUILayoutOption[]): boolean
        /** Make a toggle.
         * @param label Optional label in front of the toggle.
         * @param value The shown state of the toggle.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout
        properties. Any values passed in here will override settings defined by the style.<br>

See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The selected state of the toggle. 
         */
        static Toggle(label: GUIContent, value: boolean, ...options: GUILayoutOption[]): boolean
        /** Make a toggle.
         * @param label Optional label in front of the toggle.
         * @param value The shown state of the toggle.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout
        properties. Any values passed in here will override settings defined by the style.<br>

See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The selected state of the toggle. 
         */
        static Toggle(value: boolean, style: GUIStyle, ...options: GUILayoutOption[]): boolean
        /** Make a toggle.
         * @param label Optional label in front of the toggle.
         * @param value The shown state of the toggle.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout
        properties. Any values passed in here will override settings defined by the style.<br>

See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The selected state of the toggle. 
         */
        static Toggle(value: boolean, ...options: GUILayoutOption[]): boolean
        /** Make a toggle field where the toggle is to the left and the label immediately to the right of it.
         * @param label Label to display next to the toggle.
         * @param value The value to edit.
         * @param labelStyle Optional GUIStyle to use for the label.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static ToggleLeft(label: string, value: boolean, labelStyle: GUIStyle, ...options: GUILayoutOption[]): boolean
        /** Make a toggle field where the toggle is to the left and the label immediately to the right of it.
         * @param label Label to display next to the toggle.
         * @param value The value to edit.
         * @param labelStyle Optional GUIStyle to use for the label.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static ToggleLeft(label: GUIContent, value: boolean, labelStyle: GUIStyle, ...options: GUILayoutOption[]): boolean
        /** Make a toggle field where the toggle is to the left and the label immediately to the right of it.
         * @param label Label to display next to the toggle.
         * @param value The value to edit.
         * @param labelStyle Optional GUIStyle to use for the label.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static ToggleLeft(label: string, value: boolean, ...options: GUILayoutOption[]): boolean
        /** Make a toggle field where the toggle is to the left and the label immediately to the right of it.
         * @param label Label to display next to the toggle.
         * @param value The value to edit.
         * @param labelStyle Optional GUIStyle to use for the label.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static ToggleLeft(label: GUIContent, value: boolean, ...options: GUILayoutOption[]): boolean
        /** Make a text field.
         * @param label Optional label to display in front of the text field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The text entered by the user. 
         */
        static TextField(label: string, text: string, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a text field.
         * @param label Optional label to display in front of the text field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The text entered by the user. 
         */
        static TextField(label: GUIContent, text: string, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a text field.
         * @param label Optional label to display in front of the text field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The text entered by the user. 
         */
        static TextField(text: string, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a text field.
         * @param label Optional label to display in front of the text field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The text entered by the user. 
         */
        static TextField(label: string, text: string, ...options: GUILayoutOption[]): string
        /** Make a text field.
         * @param label Optional label to display in front of the text field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The text entered by the user. 
         */
        static TextField(label: GUIContent, text: string, ...options: GUILayoutOption[]): string
        /** Make a text field.
         * @param label Optional label to display in front of the text field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The text entered by the user. 
         */
        static TextField(text: string, ...options: GUILayoutOption[]): string
        /** Make a delayed text field.
         * @param label Optional label to display in front of the int field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the text field. 
         */
        static DelayedTextField(label: string, text: string, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a delayed text field.
         * @param label Optional label to display in front of the int field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the text field. 
         */
        static DelayedTextField(label: GUIContent, text: string, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a delayed text field.
         * @param label Optional label to display in front of the int field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the text field. 
         */
        static DelayedTextField(text: string, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a delayed text field.
         * @param label Optional label to display in front of the int field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the text field. 
         */
        static DelayedTextField(label: string, text: string, ...options: GUILayoutOption[]): string
        /** Make a delayed text field.
         * @param label Optional label to display in front of the int field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the text field. 
         */
        static DelayedTextField(label: GUIContent, text: string, ...options: GUILayoutOption[]): string
        /** Make a delayed text field.
         * @param property The text property to edit.
         * @param label Optional label to display in front of the int field. Pass GUIContent.none to hide label.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static DelayedTextField(property: SerializedProperty, label: GUIContent, ...options: GUILayoutOption[]): void
        /** Make a delayed text field.
         * @param label Optional label to display in front of the int field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the text field. 
         */
        static DelayedTextField(text: string, ...options: GUILayoutOption[]): string
        /** Make a delayed text field.
         * @param property The text property to edit.
         * @param label Optional label to display in front of the int field. Pass GUIContent.none to hide label.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static DelayedTextField(property: SerializedProperty, ...options: GUILayoutOption[]): void
        /** Make a text area.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The text entered by the user. 
         */
        static TextArea(text: string, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a text area.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The text entered by the user. 
         */
        static TextArea(text: string, ...options: GUILayoutOption[]): string
        /** Make a selectable label field. (Useful for showing read-only info that can be copy-pasted.)
         * @param text The text to show.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static SelectableLabel(text: string, style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Make a selectable label field. (Useful for showing read-only info that can be copy-pasted.)
         * @param text The text to show.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static SelectableLabel(text: string, ...options: GUILayoutOption[]): void
        /** Make a text field where the user can enter a password.
         * @param label Optional label to display in front of the password field.
         * @param password The password to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The password entered by the user. 
         */
        static PasswordField(label: string, password: string, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a text field where the user can enter a password.
         * @param label Optional label to display in front of the password field.
         * @param password The password to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The password entered by the user. 
         */
        static PasswordField(label: GUIContent, password: string, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a text field where the user can enter a password.
         * @param label Optional label to display in front of the password field.
         * @param password The password to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The password entered by the user. 
         */
        static PasswordField(password: string, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a text field where the user can enter a password.
         * @param label Optional label to display in front of the password field.
         * @param password The password to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The password entered by the user. 
         */
        static PasswordField(label: string, password: string, ...options: GUILayoutOption[]): string
        /** Make a text field where the user can enter a password.
         * @param label Optional label to display in front of the password field.
         * @param password The password to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The password entered by the user. 
         */
        static PasswordField(label: GUIContent, password: string, ...options: GUILayoutOption[]): string
        /** Make a text field where the user can enter a password.
         * @param label Optional label to display in front of the password field.
         * @param password The password to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The password entered by the user. 
         */
        static PasswordField(password: string, ...options: GUILayoutOption[]): string
        /** Make a text field for entering float values.
         * @param label Optional label to display in front of the float field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static FloatField(label: string, value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a text field for entering float values.
         * @param label Optional label to display in front of the float field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static FloatField(label: GUIContent, value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a text field for entering float values.
         * @param label Optional label to display in front of the float field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static FloatField(value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a text field for entering float values.
         * @param label Optional label to display in front of the float field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static FloatField(label: string, value: number, ...options: GUILayoutOption[]): number
        /** Make a text field for entering float values.
         * @param label Optional label to display in front of the float field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static FloatField(label: GUIContent, value: number, ...options: GUILayoutOption[]): number
        /** Make a text field for entering float values.
         * @param label Optional label to display in front of the float field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static FloatField(value: number, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering floats.
         * @param label Optional label to display in front of the float field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the float field. 
         */
        static DelayedFloatField(label: string, value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering floats.
         * @param label Optional label to display in front of the float field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the float field. 
         */
        static DelayedFloatField(label: GUIContent, value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering floats.
         * @param label Optional label to display in front of the float field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the float field. 
         */
        static DelayedFloatField(value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering floats.
         * @param label Optional label to display in front of the float field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the float field. 
         */
        static DelayedFloatField(label: string, value: number, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering floats.
         * @param label Optional label to display in front of the float field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the float field. 
         */
        static DelayedFloatField(label: GUIContent, value: number, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering floats.
         * @param property The float property to edit.
         * @param label Optional label to display in front of the float field. Pass GUIContent.none to hide label.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static DelayedFloatField(property: SerializedProperty, label: GUIContent, ...options: GUILayoutOption[]): void
        /** Make a delayed text field for entering floats.
         * @param label Optional label to display in front of the float field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the float field. 
         */
        static DelayedFloatField(value: number, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering floats.
         * @param property The float property to edit.
         * @param label Optional label to display in front of the float field. Pass GUIContent.none to hide label.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static DelayedFloatField(property: SerializedProperty, ...options: GUILayoutOption[]): void
        /** Make a text field for entering double values.
         * @param label Optional label to display in front of the double field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static DoubleField(label: string, value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a text field for entering double values.
         * @param label Optional label to display in front of the double field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static DoubleField(label: GUIContent, value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a text field for entering double values.
         * @param label Optional label to display in front of the double field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static DoubleField(value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a text field for entering double values.
         * @param label Optional label to display in front of the double field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static DoubleField(label: string, value: number, ...options: GUILayoutOption[]): number
        /** Make a text field for entering double values.
         * @param label Optional label to display in front of the double field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static DoubleField(label: GUIContent, value: number, ...options: GUILayoutOption[]): number
        /** Make a text field for entering double values.
         * @param label Optional label to display in front of the double field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static DoubleField(value: number, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering doubles.
         * @param label Optional label to display in front of the double field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options 
          An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
          See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
          GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
        
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the double field. 
         */
        static DelayedDoubleField(label: string, value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering doubles.
         * @param label Optional label to display in front of the double field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options 
          An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
          See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
          GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
        
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the double field. 
         */
        static DelayedDoubleField(label: GUIContent, value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering doubles.
         * @param label Optional label to display in front of the double field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options 
          An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
          See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
          GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
        
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the double field. 
         */
        static DelayedDoubleField(value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering doubles.
         * @param label Optional label to display in front of the double field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options 
          An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
          See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
          GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
        
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the double field. 
         */
        static DelayedDoubleField(label: string, value: number, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering doubles.
         * @param label Optional label to display in front of the double field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options 
          An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
          See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
          GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
        
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the double field. 
         */
        static DelayedDoubleField(label: GUIContent, value: number, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering doubles.
         * @param label Optional label to display in front of the double field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options 
          An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
          See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
          GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
        
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the double field. 
         */
        static DelayedDoubleField(value: number, ...options: GUILayoutOption[]): number
        /** Make a text field for entering integers.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static IntField(label: string, value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a text field for entering integers.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static IntField(label: GUIContent, value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a text field for entering integers.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static IntField(value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a text field for entering integers.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static IntField(label: string, value: number, ...options: GUILayoutOption[]): number
        /** Make a text field for entering integers.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static IntField(label: GUIContent, value: number, ...options: GUILayoutOption[]): number
        /** Make a text field for entering integers.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static IntField(value: number, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering integers.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the int field. 
         */
        static DelayedIntField(label: string, value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering integers.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the int field. 
         */
        static DelayedIntField(label: GUIContent, value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering integers.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the int field. 
         */
        static DelayedIntField(value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering integers.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the int field. 
         */
        static DelayedIntField(label: string, value: number, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering integers.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the int field. 
         */
        static DelayedIntField(label: GUIContent, value: number, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering integers.
         * @param property The int property to edit.
         * @param label Optional label to display in front of the int field. Pass GUIContent.none to hide label.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static DelayedIntField(property: SerializedProperty, label: GUIContent, ...options: GUILayoutOption[]): void
        /** Make a delayed text field for entering integers.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the int field. 
         */
        static DelayedIntField(value: number, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering integers.
         * @param property The int property to edit.
         * @param label Optional label to display in front of the int field. Pass GUIContent.none to hide label.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static DelayedIntField(property: SerializedProperty, ...options: GUILayoutOption[]): void
        /** Make a text field for entering long integers.
         * @param label Optional label to display in front of the long field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static LongField(label: string, value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a text field for entering long integers.
         * @param label Optional label to display in front of the long field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static LongField(label: GUIContent, value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a text field for entering long integers.
         * @param label Optional label to display in front of the long field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static LongField(value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a text field for entering long integers.
         * @param label Optional label to display in front of the long field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static LongField(label: string, value: number, ...options: GUILayoutOption[]): number
        /** Make a text field for entering long integers.
         * @param label Optional label to display in front of the long field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static LongField(label: GUIContent, value: number, ...options: GUILayoutOption[]): number
        /** Make a text field for entering long integers.
         * @param label Optional label to display in front of the long field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static LongField(value: number, ...options: GUILayoutOption[]): number
        /** Make a slider the user can drag to change a value between a min and a max.
         * @param label Optional label in front of the slider.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value that has been set by the user. 
         */
        static Slider(label: string, value: number, leftValue: number, rightValue: number, ...options: GUILayoutOption[]): number
        /** Make a slider the user can drag to change a value between a min and a max.
         * @param label Optional label in front of the slider.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value that has been set by the user. 
         */
        static Slider(label: GUIContent, value: number, leftValue: number, rightValue: number, ...options: GUILayoutOption[]): number
        /** Make a slider the user can drag to change a value between a min and a max.
         * @param label Optional label in front of the slider.
         * @param property The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static Slider(property: SerializedProperty, leftValue: number, rightValue: number, label: string, ...options: GUILayoutOption[]): void
        /** Make a slider the user can drag to change a value between a min and a max.
         * @param label Optional label in front of the slider.
         * @param property The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static Slider(property: SerializedProperty, leftValue: number, rightValue: number, label: GUIContent, ...options: GUILayoutOption[]): void
        /** Make a slider the user can drag to change a value between a min and a max.
         * @param label Optional label in front of the slider.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value that has been set by the user. 
         */
        static Slider(value: number, leftValue: number, rightValue: number, ...options: GUILayoutOption[]): number
        /** Make a slider the user can drag to change a value between a min and a max.
         * @param label Optional label in front of the slider.
         * @param property The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static Slider(property: SerializedProperty, leftValue: number, rightValue: number, ...options: GUILayoutOption[]): void
        /** Make a slider the user can drag to change an integer value between a min and a max.
         * @param label Optional label in front of the slider.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value that has been set by the user. 
         */
        static IntSlider(label: string, value: number, leftValue: number, rightValue: number, ...options: GUILayoutOption[]): number
        /** Make a slider the user can drag to change an integer value between a min and a max.
         * @param label Optional label in front of the slider.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value that has been set by the user. 
         */
        static IntSlider(label: GUIContent, value: number, leftValue: number, rightValue: number, ...options: GUILayoutOption[]): number
        /** Make a slider the user can drag to change an integer value between a min and a max.
         * @param label Optional label in front of the slider.
         * @param property The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static IntSlider(property: SerializedProperty, leftValue: number, rightValue: number, label: string, ...options: GUILayoutOption[]): void
        /** Make a slider the user can drag to change an integer value between a min and a max.
         * @param label Optional label in front of the slider.
         * @param property The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static IntSlider(property: SerializedProperty, leftValue: number, rightValue: number, label: GUIContent, ...options: GUILayoutOption[]): void
        /** Make a slider the user can drag to change an integer value between a min and a max.
         * @param label Optional label in front of the slider.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value that has been set by the user. 
         */
        static IntSlider(value: number, leftValue: number, rightValue: number, ...options: GUILayoutOption[]): number
        /** Make a slider the user can drag to change an integer value between a min and a max.
         * @param label Optional label in front of the slider.
         * @param property The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static IntSlider(property: SerializedProperty, leftValue: number, rightValue: number, ...options: GUILayoutOption[]): void
        /** Make a special slider the user can use to specify a range between a min and a max.
         * @param label Optional label in front of the slider.
         * @param minValue The lower value of the range the slider shows, passed by reference.
         * @param maxValue The upper value at the range the slider shows, passed by reference.
         * @param minLimit The limit at the left end of the slider.
         * @param maxLimit The limit at the right end of the slider.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static MinMaxSlider(label: string, minValue: jsb.Ref<number>, maxValue: jsb.Ref<number>, minLimit: number, maxLimit: number, ...options: GUILayoutOption[]): void
        /** Make a special slider the user can use to specify a range between a min and a max.
         * @param label Optional label in front of the slider.
         * @param minValue The lower value of the range the slider shows, passed by reference.
         * @param maxValue The upper value at the range the slider shows, passed by reference.
         * @param minLimit The limit at the left end of the slider.
         * @param maxLimit The limit at the right end of the slider.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static MinMaxSlider(label: GUIContent, minValue: jsb.Ref<number>, maxValue: jsb.Ref<number>, minLimit: number, maxLimit: number, ...options: GUILayoutOption[]): void
        /** Make a special slider the user can use to specify a range between a min and a max.
         * @param label Optional label in front of the slider.
         * @param minValue The lower value of the range the slider shows, passed by reference.
         * @param maxValue The upper value at the range the slider shows, passed by reference.
         * @param minLimit The limit at the left end of the slider.
         * @param maxLimit The limit at the right end of the slider.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static MinMaxSlider(minValue: jsb.Ref<number>, maxValue: jsb.Ref<number>, minLimit: number, maxLimit: number, ...options: GUILayoutOption[]): void
        /** Make a generic popup selection field.
         * @param label Optional label in front of the field.
         * @param selectedIndex The index of the option the field shows.
         * @param displayedOptions An array with the options shown in the popup.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The index of the option that has been selected by the user. 
         */
        static Popup(label: string, selectedIndex: number, displayedOptions: Array<string>, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a generic popup selection field.
         * @param label Optional label in front of the field.
         * @param selectedIndex The index of the option the field shows.
         * @param displayedOptions An array with the options shown in the popup.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The index of the option that has been selected by the user. 
         */
        static Popup(label: GUIContent, selectedIndex: number, displayedOptions: Array<GUIContent>, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a generic popup selection field.
         * @param label Optional label in front of the field.
         * @param selectedIndex The index of the option the field shows.
         * @param displayedOptions An array with the options shown in the popup.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The index of the option that has been selected by the user. 
         */
        static Popup(selectedIndex: number, displayedOptions: Array<string>, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a generic popup selection field.
         * @param label Optional label in front of the field.
         * @param selectedIndex The index of the option the field shows.
         * @param displayedOptions An array with the options shown in the popup.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The index of the option that has been selected by the user. 
         */
        static Popup(selectedIndex: number, displayedOptions: Array<GUIContent>, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a generic popup selection field.
         * @param label Optional label in front of the field.
         * @param selectedIndex The index of the option the field shows.
         * @param displayedOptions An array with the options shown in the popup.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The index of the option that has been selected by the user. 
         */
        static Popup(label: string, selectedIndex: number, displayedOptions: Array<string>, ...options: GUILayoutOption[]): number
        static Popup(label: GUIContent, selectedIndex: number, displayedOptions: Array<string>, ...options: GUILayoutOption[]): number
        /** Make a generic popup selection field.
         * @param label Optional label in front of the field.
         * @param selectedIndex The index of the option the field shows.
         * @param displayedOptions An array with the options shown in the popup.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The index of the option that has been selected by the user. 
         */
        static Popup(label: GUIContent, selectedIndex: number, displayedOptions: Array<GUIContent>, ...options: GUILayoutOption[]): number
        /** Make a generic popup selection field.
         * @param label Optional label in front of the field.
         * @param selectedIndex The index of the option the field shows.
         * @param displayedOptions An array with the options shown in the popup.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The index of the option that has been selected by the user. 
         */
        static Popup(selectedIndex: number, displayedOptions: Array<string>, ...options: GUILayoutOption[]): number
        /** Make a generic popup selection field.
         * @param label Optional label in front of the field.
         * @param selectedIndex The index of the option the field shows.
         * @param displayedOptions An array with the options shown in the popup.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The index of the option that has been selected by the user. 
         */
        static Popup(selectedIndex: number, displayedOptions: Array<GUIContent>, ...options: GUILayoutOption[]): number
        static EnumPopup(label: GUIContent, selected: Enum, checkEnabled: (arg: Enum) => boolean, includeObsolete: boolean, style: GUIStyle, ...options: GUILayoutOption[]): Enum
        static EnumPopup(label: GUIContent, selected: Enum, checkEnabled: (arg: Enum) => boolean, includeObsolete: boolean, ...options: GUILayoutOption[]): Enum
        /** Make an enum popup selection field.
         * @param label Optional label in front of the field.
         * @param selected The enum option the field shows.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @param checkEnabled Method called for each Enum value displayed. The specified method should return true if the option can be selected, false otherwise.
         * @returns The enum option that has been selected by the user. 
         */
        static EnumPopup(label: string, selected: Enum, style: GUIStyle, ...options: GUILayoutOption[]): Enum
        /** Make an enum popup selection field.
         * @param label Optional label in front of the field.
         * @param selected The enum option the field shows.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @param checkEnabled Method called for each Enum value displayed. The specified method should return true if the option can be selected, false otherwise.
         * @returns The enum option that has been selected by the user. 
         */
        static EnumPopup(label: GUIContent, selected: Enum, style: GUIStyle, ...options: GUILayoutOption[]): Enum
        /** Make an enum popup selection field.
         * @param label Optional label in front of the field.
         * @param selected The enum option the field shows.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @param checkEnabled Method called for each Enum value displayed. The specified method should return true if the option can be selected, false otherwise.
         * @returns The enum option that has been selected by the user. 
         */
        static EnumPopup(selected: Enum, style: GUIStyle, ...options: GUILayoutOption[]): Enum
        /** Make an enum popup selection field.
         * @param label Optional label in front of the field.
         * @param selected The enum option the field shows.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @param checkEnabled Method called for each Enum value displayed. The specified method should return true if the option can be selected, false otherwise.
         * @returns The enum option that has been selected by the user. 
         */
        static EnumPopup(label: string, selected: Enum, ...options: GUILayoutOption[]): Enum
        /** Make an enum popup selection field.
         * @param label Optional label in front of the field.
         * @param selected The enum option the field shows.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @param checkEnabled Method called for each Enum value displayed. The specified method should return true if the option can be selected, false otherwise.
         * @returns The enum option that has been selected by the user. 
         */
        static EnumPopup(label: GUIContent, selected: Enum, ...options: GUILayoutOption[]): Enum
        /** Make an enum popup selection field.
         * @param label Optional label in front of the field.
         * @param selected The enum option the field shows.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @param checkEnabled Method called for each Enum value displayed. The specified method should return true if the option can be selected, false otherwise.
         * @returns The enum option that has been selected by the user. 
         */
        static EnumPopup(selected: Enum, ...options: GUILayoutOption[]): Enum
        /** Make an integer popup selection field.
         * @param label Optional label in front of the field.
         * @param selectedValue The value of the option the field shows.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value of the option that has been selected by the user. 
         */
        static IntPopup(label: string, selectedValue: number, displayedOptions: Array<string>, optionValues: Array<number>, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make an integer popup selection field.
         * @param label Optional label in front of the field.
         * @param selectedValue The value of the option the field shows.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value of the option that has been selected by the user. 
         */
        static IntPopup(label: GUIContent, selectedValue: number, displayedOptions: Array<GUIContent>, optionValues: Array<number>, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make an integer popup selection field.
         * @param label Optional label in front of the field.
         * @param selectedValue The value of the option the field shows.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value of the option that has been selected by the user. 
         */
        static IntPopup(selectedValue: number, displayedOptions: Array<string>, optionValues: Array<number>, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make an integer popup selection field.
         * @param label Optional label in front of the field.
         * @param selectedValue The value of the option the field shows.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value of the option that has been selected by the user. 
         */
        static IntPopup(selectedValue: number, displayedOptions: Array<GUIContent>, optionValues: Array<number>, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make an integer popup selection field.
         * @param label Optional label in front of the field.
         * @param selectedValue The value of the option the field shows.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value of the option that has been selected by the user. 
         */
        static IntPopup(label: string, selectedValue: number, displayedOptions: Array<string>, optionValues: Array<number>, ...options: GUILayoutOption[]): number
        /** Make an integer popup selection field.
         * @param label Optional label in front of the field.
         * @param selectedValue The value of the option the field shows.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value of the option that has been selected by the user. 
         */
        static IntPopup(label: GUIContent, selectedValue: number, displayedOptions: Array<GUIContent>, optionValues: Array<number>, ...options: GUILayoutOption[]): number
        /** Make an integer popup selection field.
         * @param property The value of the option the field shows.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option.
         * @param label Optional label in front of the field.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static IntPopup(property: SerializedProperty, displayedOptions: Array<GUIContent>, optionValues: Array<number>, label: GUIContent, ...options: GUILayoutOption[]): void
        /** Make an integer popup selection field.
         * @param label Optional label in front of the field.
         * @param selectedValue The value of the option the field shows.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value of the option that has been selected by the user. 
         */
        static IntPopup(selectedValue: number, displayedOptions: Array<string>, optionValues: Array<number>, ...options: GUILayoutOption[]): number
        /** Make an integer popup selection field.
         * @param label Optional label in front of the field.
         * @param selectedValue The value of the option the field shows.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value of the option that has been selected by the user. 
         */
        static IntPopup(selectedValue: number, displayedOptions: Array<GUIContent>, optionValues: Array<number>, ...options: GUILayoutOption[]): number
        /** Make an integer popup selection field.
         * @param property The value of the option the field shows.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option.
         * @param label Optional label in front of the field.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static IntPopup(property: SerializedProperty, displayedOptions: Array<GUIContent>, optionValues: Array<number>, ...options: GUILayoutOption[]): void
        /** Make a tag selection field.
         * @param label Optional label in front of the field.
         * @param tag The tag the field shows.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The tag selected by the user. 
         */
        static TagField(label: string, tag: string, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a tag selection field.
         * @param label Optional label in front of the field.
         * @param tag The tag the field shows.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The tag selected by the user. 
         */
        static TagField(label: GUIContent, tag: string, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a tag selection field.
         * @param label Optional label in front of the field.
         * @param tag The tag the field shows.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The tag selected by the user. 
         */
        static TagField(tag: string, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a tag selection field.
         * @param label Optional label in front of the field.
         * @param tag The tag the field shows.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The tag selected by the user. 
         */
        static TagField(label: string, tag: string, ...options: GUILayoutOption[]): string
        /** Make a tag selection field.
         * @param label Optional label in front of the field.
         * @param tag The tag the field shows.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The tag selected by the user. 
         */
        static TagField(label: GUIContent, tag: string, ...options: GUILayoutOption[]): string
        /** Make a tag selection field.
         * @param label Optional label in front of the field.
         * @param tag The tag the field shows.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The tag selected by the user. 
         */
        static TagField(tag: string, ...options: GUILayoutOption[]): string
        /** Make a layer selection field.
         * @param label Optional label in front of the field.
         * @param layer The layer shown in the field.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The layer selected by the user. 
         */
        static LayerField(label: string, layer: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a layer selection field.
         * @param label Optional label in front of the field.
         * @param layer The layer shown in the field.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The layer selected by the user. 
         */
        static LayerField(label: GUIContent, layer: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a layer selection field.
         * @param label Optional label in front of the field.
         * @param layer The layer shown in the field.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The layer selected by the user. 
         */
        static LayerField(layer: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a layer selection field.
         * @param label Optional label in front of the field.
         * @param layer The layer shown in the field.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The layer selected by the user. 
         */
        static LayerField(label: string, layer: number, ...options: GUILayoutOption[]): number
        /** Make a layer selection field.
         * @param label Optional label in front of the field.
         * @param layer The layer shown in the field.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The layer selected by the user. 
         */
        static LayerField(label: GUIContent, layer: number, ...options: GUILayoutOption[]): number
        /** Make a layer selection field.
         * @param label Optional label in front of the field.
         * @param layer The layer shown in the field.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The layer selected by the user. 
         */
        static LayerField(layer: number, ...options: GUILayoutOption[]): number
        /** Make a field for masks.
         * @param label Prefix label of the field.
         * @param mask The current mask to display.
         * @param displayedOption A string array containing the labels for each flag.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value modified by the user. 
         */
        static MaskField(label: GUIContent, mask: number, displayedOptions: Array<string>, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a field for masks.
         * @param label Prefix label of the field.
         * @param mask The current mask to display.
         * @param displayedOption A string array containing the labels for each flag.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value modified by the user. 
         */
        static MaskField(label: string, mask: number, displayedOptions: Array<string>, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a field for masks.
         * @param label Prefix label of the field.
         * @param mask The current mask to display.
         * @param displayedOption A string array containing the labels for each flag.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value modified by the user. 
         */
        static MaskField(label: GUIContent, mask: number, displayedOptions: Array<string>, ...options: GUILayoutOption[]): number
        /** Make a field for masks.
         * @param label Prefix label of the field.
         * @param mask The current mask to display.
         * @param displayedOption A string array containing the labels for each flag.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value modified by the user. 
         */
        static MaskField(label: string, mask: number, displayedOptions: Array<string>, ...options: GUILayoutOption[]): number
        /** Make a field for masks.
         * @param label Prefix label of the field.
         * @param mask The current mask to display.
         * @param displayedOption A string array containing the labels for each flag.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value modified by the user. 
         */
        static MaskField(mask: number, displayedOptions: Array<string>, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a field for masks.
         * @param label Prefix label of the field.
         * @param mask The current mask to display.
         * @param displayedOption A string array containing the labels for each flag.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value modified by the user. 
         */
        static MaskField(mask: number, displayedOptions: Array<string>, ...options: GUILayoutOption[]): number
        /** Displays a menu with an option for every value of the enum type when clicked.
         * @param label Optional label to display in front of the enum flags field.
         * @param enumValue Enum flags value.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @returns The enum flags value modified by the user. This is a selection BitMask where each bit represents an Enum value index. (Note this returned value is not itself an Enum). 
         */
        static EnumFlagsField(label: GUIContent, enumValue: Enum, includeObsolete: boolean, style: GUIStyle, ...options: GUILayoutOption[]): Enum
        /** Displays a menu with an option for every value of the enum type when clicked.
         * @param label Optional label to display in front of the enum flags field.
         * @param enumValue Enum flags value.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @returns The enum flags value modified by the user. This is a selection BitMask where each bit represents an Enum value index. (Note this returned value is not itself an Enum). 
         */
        static EnumFlagsField(label: string, enumValue: Enum, style: GUIStyle, ...options: GUILayoutOption[]): Enum
        /** Displays a menu with an option for every value of the enum type when clicked.
         * @param label Optional label to display in front of the enum flags field.
         * @param enumValue Enum flags value.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @returns The enum flags value modified by the user. This is a selection BitMask where each bit represents an Enum value index. (Note this returned value is not itself an Enum). 
         */
        static EnumFlagsField(label: GUIContent, enumValue: Enum, style: GUIStyle, ...options: GUILayoutOption[]): Enum
        /** Displays a menu with an option for every value of the enum type when clicked.
         * @param label Optional label to display in front of the enum flags field.
         * @param enumValue Enum flags value.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @returns The enum flags value modified by the user. This is a selection BitMask where each bit represents an Enum value index. (Note this returned value is not itself an Enum). 
         */
        static EnumFlagsField(label: GUIContent, enumValue: Enum, includeObsolete: boolean, ...options: GUILayoutOption[]): Enum
        /** Displays a menu with an option for every value of the enum type when clicked.
         * @param label Optional label to display in front of the enum flags field.
         * @param enumValue Enum flags value.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @returns The enum flags value modified by the user. This is a selection BitMask where each bit represents an Enum value index. (Note this returned value is not itself an Enum). 
         */
        static EnumFlagsField(enumValue: Enum, style: GUIStyle, ...options: GUILayoutOption[]): Enum
        /** Displays a menu with an option for every value of the enum type when clicked.
         * @param label Optional label to display in front of the enum flags field.
         * @param enumValue Enum flags value.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @returns The enum flags value modified by the user. This is a selection BitMask where each bit represents an Enum value index. (Note this returned value is not itself an Enum). 
         */
        static EnumFlagsField(label: string, enumValue: Enum, ...options: GUILayoutOption[]): Enum
        /** Displays a menu with an option for every value of the enum type when clicked.
         * @param label Optional label to display in front of the enum flags field.
         * @param enumValue Enum flags value.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @returns The enum flags value modified by the user. This is a selection BitMask where each bit represents an Enum value index. (Note this returned value is not itself an Enum). 
         */
        static EnumFlagsField(label: GUIContent, enumValue: Enum, ...options: GUILayoutOption[]): Enum
        /** Displays a menu with an option for every value of the enum type when clicked.
         * @param label Optional label to display in front of the enum flags field.
         * @param enumValue Enum flags value.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @returns The enum flags value modified by the user. This is a selection BitMask where each bit represents an Enum value index. (Note this returned value is not itself an Enum). 
         */
        static EnumFlagsField(enumValue: Enum, ...options: GUILayoutOption[]): Enum
        /** Make a field to receive any object type.
         * @param label Optional label in front of the field.
         * @param obj The object the field shows.
         * @param objType The type of the objects that can be assigned.
         * @param allowSceneObjects Allow assigning Scene objects. See Description for more info.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The object that has been set by the user. 
         */
        static ObjectField(label: string, obj: Object1, objType: any, allowSceneObjects: boolean, ...options: GUILayoutOption[]): Object1
        /** Make a field to receive any object type.
         * @param label Optional label in front of the field.
         * @param obj The object the field shows.
         * @param objType The type of the objects that can be assigned.
         * @param allowSceneObjects Allow assigning Scene objects. See Description for more info.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The object that has been set by the user. 
         */
        static ObjectField(label: GUIContent, obj: Object1, objType: any, allowSceneObjects: boolean, ...options: GUILayoutOption[]): Object1
        /** Make a field to receive any object type.
         * @param label Optional label in front of the field.
         * @param obj The object the field shows.
         * @param objType The type of the objects that can be assigned.
         * @param allowSceneObjects Allow assigning Scene objects. See Description for more info.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The object that has been set by the user. 
         */
        static ObjectField(obj: Object1, objType: any, allowSceneObjects: boolean, ...options: GUILayoutOption[]): Object1
        /** Make a field to receive any object type.
         * @param property The object reference property the field shows.
         * @param objType The type of the objects that can be assigned.
         * @param label Optional label in front of the field. Pass GUIContent.none to hide the label.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static ObjectField(property: SerializedProperty, objType: any, label: GUIContent, ...options: GUILayoutOption[]): void
        /** Make a field to receive any object type.
         * @param property The object reference property the field shows.
         * @param objType The type of the objects that can be assigned.
         * @param label Optional label in front of the field. Pass GUIContent.none to hide the label.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static ObjectField(property: SerializedProperty, label: GUIContent, ...options: GUILayoutOption[]): void
        /** Make a field to receive any object type.
         * @param property The object reference property the field shows.
         * @param objType The type of the objects that can be assigned.
         * @param label Optional label in front of the field. Pass GUIContent.none to hide the label.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static ObjectField(property: SerializedProperty, objType: any, ...options: GUILayoutOption[]): void
        /** Make a field to receive any object type.
         * @param property The object reference property the field shows.
         * @param objType The type of the objects that can be assigned.
         * @param label Optional label in front of the field. Pass GUIContent.none to hide the label.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static ObjectField(property: SerializedProperty, ...options: GUILayoutOption[]): void
        /** Make an X & Y field for entering a Vector2.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
         * @returns The value entered by the user. 
         */
        static Vector2Field(label: string, value: Vector2, ...options: GUILayoutOption[]): Vector2
        /** Make an X & Y field for entering a Vector2.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
         * @returns The value entered by the user. 
         */
        static Vector2Field(label: GUIContent, value: Vector2, ...options: GUILayoutOption[]): Vector2
        /** Make an X, Y & Z field for entering a Vector3.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout
        properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static Vector3Field(label: string, value: Vector3, ...options: GUILayoutOption[]): Vector3
        /** Make an X, Y & Z field for entering a Vector3.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout
        properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static Vector3Field(label: GUIContent, value: Vector3, ...options: GUILayoutOption[]): Vector3
        /** Make an X, Y, Z & W field for entering a Vector4.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static Vector4Field(label: string, value: Vector4, ...options: GUILayoutOption[]): Vector4
        static Vector4Field(label: GUIContent, value: Vector4, ...options: GUILayoutOption[]): Vector4
        /** Make an X & Y integer field for entering a Vector2Int.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static Vector2IntField(label: string, value: Vector2Int, ...options: GUILayoutOption[]): Vector2Int
        /** Make an X & Y integer field for entering a Vector2Int.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static Vector2IntField(label: GUIContent, value: Vector2Int, ...options: GUILayoutOption[]): Vector2Int
        /** Make an X, Y & Z integer field for entering a Vector3Int.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static Vector3IntField(label: string, value: Vector3Int, ...options: GUILayoutOption[]): Vector3Int
        /** Make an X, Y & Z integer field for entering a Vector3Int.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static Vector3IntField(label: GUIContent, value: Vector3Int, ...options: GUILayoutOption[]): Vector3Int
        /** Make an X, Y, W & H field for entering a Rect.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static RectField(label: string, value: Rect, ...options: GUILayoutOption[]): Rect
        /** Make an X, Y, W & H field for entering a Rect.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static RectField(label: GUIContent, value: Rect, ...options: GUILayoutOption[]): Rect
        /** Make an X, Y, W & H field for entering a Rect.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static RectField(value: Rect, ...options: GUILayoutOption[]): Rect
        /** Make an X, Y, W & H field for entering a RectInt.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static RectIntField(label: string, value: RectInt, ...options: GUILayoutOption[]): RectInt
        /** Make an X, Y, W & H field for entering a RectInt.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static RectIntField(label: GUIContent, value: RectInt, ...options: GUILayoutOption[]): RectInt
        /** Make an X, Y, W & H field for entering a RectInt.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static RectIntField(value: RectInt, ...options: GUILayoutOption[]): RectInt
        /** Make Center & Extents field for entering a Bounds.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static BoundsField(label: string, value: Bounds, ...options: GUILayoutOption[]): Bounds
        /** Make Center & Extents field for entering a Bounds.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static BoundsField(label: GUIContent, value: Bounds, ...options: GUILayoutOption[]): Bounds
        /** Make Center & Extents field for entering a Bounds.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static BoundsField(value: Bounds, ...options: GUILayoutOption[]): Bounds
        /** Make Position & Size field for entering a BoundsInt.
         * @param label Make Position & Size field for entering a Bounds.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static BoundsIntField(label: string, value: BoundsInt, ...options: GUILayoutOption[]): BoundsInt
        /** Make Position & Size field for entering a BoundsInt.
         * @param label Make Position & Size field for entering a Bounds.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static BoundsIntField(label: GUIContent, value: BoundsInt, ...options: GUILayoutOption[]): BoundsInt
        /** Make Position & Size field for entering a BoundsInt.
         * @param label Make Position & Size field for entering a Bounds.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static BoundsIntField(value: BoundsInt, ...options: GUILayoutOption[]): BoundsInt
        /** Make a field for selecting a Color.
         * @param label Optional label to display in front of the field.
         * @param value The color to edit.
         * @param showEyedropper If true, the color picker should show the eyedropper control. If false, don't show it.
         * @param showAlpha If true, allow the user to set an alpha value for the color. If false, hide the alpha component.
         * @param hdr If true, treat the color as an HDR value. If false, treat it as a standard LDR value.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The color selected by the user. 
         */
        static ColorField(label: GUIContent, value: Color, showEyedropper: boolean, showAlpha: boolean, hdr: boolean, ...options: GUILayoutOption[]): Color
        /** Make a field for selecting a Color.
         * @param label Optional label to display in front of the field.
         * @param value The color to edit.
         * @param showEyedropper If true, the color picker should show the eyedropper control. If false, don't show it.
         * @param showAlpha If true, allow the user to set an alpha value for the color. If false, hide the alpha component.
         * @param hdr If true, treat the color as an HDR value. If false, treat it as a standard LDR value.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The color selected by the user. 
         */
        static ColorField(label: string, value: Color, ...options: GUILayoutOption[]): Color
        /** Make a field for selecting a Color.
         * @param label Optional label to display in front of the field.
         * @param value The color to edit.
         * @param showEyedropper If true, the color picker should show the eyedropper control. If false, don't show it.
         * @param showAlpha If true, allow the user to set an alpha value for the color. If false, hide the alpha component.
         * @param hdr If true, treat the color as an HDR value. If false, treat it as a standard LDR value.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The color selected by the user. 
         */
        static ColorField(label: GUIContent, value: Color, ...options: GUILayoutOption[]): Color
        /** Make a field for selecting a Color.
         * @param label Optional label to display in front of the field.
         * @param value The color to edit.
         * @param showEyedropper If true, the color picker should show the eyedropper control. If false, don't show it.
         * @param showAlpha If true, allow the user to set an alpha value for the color. If false, hide the alpha component.
         * @param hdr If true, treat the color as an HDR value. If false, treat it as a standard LDR value.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The color selected by the user. 
         */
        static ColorField(value: Color, ...options: GUILayoutOption[]): Color
        /** Make a field for editing an AnimationCurve.
         * @param label Optional label to display in front of the field.
         * @param value The curve to edit.
         * @param color The color to show the curve with.
         * @param ranges Optional rectangle that the curve is restrained within.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The curve edited by the user. 
         */
        static CurveField(label: string, value: AnimationCurve, color: Color, ranges: Rect, ...options: GUILayoutOption[]): AnimationCurve
        /** Make a field for editing an AnimationCurve.
         * @param label Optional label to display in front of the field.
         * @param value The curve to edit.
         * @param color The color to show the curve with.
         * @param ranges Optional rectangle that the curve is restrained within.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The curve edited by the user. 
         */
        static CurveField(label: GUIContent, value: AnimationCurve, color: Color, ranges: Rect, ...options: GUILayoutOption[]): AnimationCurve
        /** Make a field for editing an AnimationCurve.
         * @param property The curve to edit.
         * @param color The color to show the curve with.
         * @param ranges Optional rectangle that the curve is restrained within.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param label Optional label to display in front of the field. Pass [[GUIContent.none] to hide the label.
         */
        static CurveField(property: SerializedProperty, color: Color, ranges: Rect, label: GUIContent, ...options: GUILayoutOption[]): void
        /** Make a field for editing an AnimationCurve.
         * @param label Optional label to display in front of the field.
         * @param value The curve to edit.
         * @param color The color to show the curve with.
         * @param ranges Optional rectangle that the curve is restrained within.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The curve edited by the user. 
         */
        static CurveField(value: AnimationCurve, color: Color, ranges: Rect, ...options: GUILayoutOption[]): AnimationCurve
        /** Make a field for editing an AnimationCurve.
         * @param property The curve to edit.
         * @param color The color to show the curve with.
         * @param ranges Optional rectangle that the curve is restrained within.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param label Optional label to display in front of the field. Pass [[GUIContent.none] to hide the label.
         */
        static CurveField(property: SerializedProperty, color: Color, ranges: Rect, ...options: GUILayoutOption[]): void
        /** Make a field for editing an AnimationCurve.
         * @param label Optional label to display in front of the field.
         * @param value The curve to edit.
         * @param color The color to show the curve with.
         * @param ranges Optional rectangle that the curve is restrained within.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The curve edited by the user. 
         */
        static CurveField(label: string, value: AnimationCurve, ...options: GUILayoutOption[]): AnimationCurve
        /** Make a field for editing an AnimationCurve.
         * @param label Optional label to display in front of the field.
         * @param value The curve to edit.
         * @param color The color to show the curve with.
         * @param ranges Optional rectangle that the curve is restrained within.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The curve edited by the user. 
         */
        static CurveField(label: GUIContent, value: AnimationCurve, ...options: GUILayoutOption[]): AnimationCurve
        /** Make a field for editing an AnimationCurve.
         * @param label Optional label to display in front of the field.
         * @param value The curve to edit.
         * @param color The color to show the curve with.
         * @param ranges Optional rectangle that the curve is restrained within.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The curve edited by the user. 
         */
        static CurveField(value: AnimationCurve, ...options: GUILayoutOption[]): AnimationCurve
        static InspectorTitlebar(foldout: boolean, targetObj: Object1, expandable: boolean): boolean
        static InspectorTitlebar(foldout: boolean, targetObjs: Array<Object1>, expandable: boolean): boolean
        /** Make an inspector-window-like titlebar.
         * @param foldout The foldout state shown with the arrow.
         * @param targetObj The object (for example a component) or objects that the titlebar is for.
         * @returns The foldout state selected by the user. 
         */
        static InspectorTitlebar(foldout: boolean, targetObj: Object1): boolean
        /** Make an inspector-window-like titlebar.
         * @param foldout The foldout state shown with the arrow.
         * @param targetObj The object (for example a component) or objects that the titlebar is for.
         * @returns The foldout state selected by the user. 
         */
        static InspectorTitlebar(foldout: boolean, targetObjs: Array<Object1>): boolean
        static InspectorTitlebar(foldout: boolean, editor: Editor): boolean
        static InspectorTitlebar(targetObjs: Array<Object1>): void
        /** Make a help box with a message to the user.
         * @param message The message text.
         * @param type The type of message.
         * @param wide If true, the box will cover the whole width of the window; otherwise it will cover the controls part only.
         */
        static HelpBox(message: string, type: MessageType, wide: boolean): void
        /** Make a help box with a message to the user.
         * @param message The message text.
         * @param type The type of message.
         * @param wide If true, the box will cover the whole width of the window; otherwise it will cover the controls part only.
         */
        static HelpBox(message: string, type: MessageType): void
        static HelpBox(content: GUIContent, wide: boolean): void
        static Space(width: number, expand: boolean): void
        static Space(width: number): void
        static Space(): void
        static Separator(): void
        /** Begin a vertical group with a toggle to enable or disable all the controls within at once.
         * @param label Label to show above the toggled controls.
         * @param toggle Enabled state of the toggle group.
         * @returns The enabled state selected by the user. 
         */
        static BeginToggleGroup(label: string, toggle: boolean): boolean
        /** Begin a vertical group with a toggle to enable or disable all the controls within at once.
         * @param label Label to show above the toggled controls.
         * @param toggle Enabled state of the toggle group.
         * @returns The enabled state selected by the user. 
         */
        static BeginToggleGroup(label: GUIContent, toggle: boolean): boolean
        static EndToggleGroup(): void
        /** Begin a horizontal group and get its rect back.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout
        properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static BeginHorizontal(style: GUIStyle, ...options: GUILayoutOption[]): Rect
        /** Begin a horizontal group and get its rect back.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout
        properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static BeginHorizontal(...options: GUILayoutOption[]): Rect
        static EndHorizontal(): void
        /** Begin a vertical group and get its rect back.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties.
        Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static BeginVertical(style: GUIStyle, ...options: GUILayoutOption[]): Rect
        /** Begin a vertical group and get its rect back.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties.
        Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static BeginVertical(...options: GUILayoutOption[]): Rect
        static EndVertical(): void
        /** Begin an automatically laid out scrollview.
         * @param scrollPosition The position to use display.
         * @param alwayShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when the content inside the ScrollView is wider than the scrollview itself.
         * @param alwayShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when content inside the ScrollView is taller than the scrollview itself.
         * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
         * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
         */
        static BeginScrollView(scrollPosition: Vector2, alwaysShowHorizontal: boolean, alwaysShowVertical: boolean, horizontalScrollbar: GUIStyle, verticalScrollbar: GUIStyle, background: GUIStyle, ...options: GUILayoutOption[]): Vector2
        /** Begin an automatically laid out scrollview.
         * @param scrollPosition The position to use display.
         * @param alwayShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when the content inside the ScrollView is wider than the scrollview itself.
         * @param alwayShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when content inside the ScrollView is taller than the scrollview itself.
         * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
         * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
         */
        static BeginScrollView(scrollPosition: Vector2, alwaysShowHorizontal: boolean, alwaysShowVertical: boolean, ...options: GUILayoutOption[]): Vector2
        /** Begin an automatically laid out scrollview.
         * @param scrollPosition The position to use display.
         * @param alwayShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when the content inside the ScrollView is wider than the scrollview itself.
         * @param alwayShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when content inside the ScrollView is taller than the scrollview itself.
         * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
         * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
         */
        static BeginScrollView(scrollPosition: Vector2, horizontalScrollbar: GUIStyle, verticalScrollbar: GUIStyle, ...options: GUILayoutOption[]): Vector2
        static BeginScrollView(scrollPosition: Vector2, style: GUIStyle, ...options: GUILayoutOption[]): Vector2
        /** Begin an automatically laid out scrollview.
         * @param scrollPosition The position to use display.
         * @param alwayShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when the content inside the ScrollView is wider than the scrollview itself.
         * @param alwayShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when content inside the ScrollView is taller than the scrollview itself.
         * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
         * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
         */
        static BeginScrollView(scrollPosition: Vector2, ...options: GUILayoutOption[]): Vector2
        static EndScrollView(): void
        /** Make a field for SerializedProperty.
         * @param property The SerializedProperty to make a field for.
         * @param label Optional label to use. If not specified the label of the property itself is used. Use GUIContent.none to not display a label at all.
         * @param includeChildren If true the property including children is drawn; otherwise only the control itself (such as only a foldout but nothing below it).
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns True if the property has children and is expanded and includeChildren was set to false; otherwise false. 
         */
        static PropertyField(property: SerializedProperty, label: GUIContent, includeChildren: boolean, ...options: GUILayoutOption[]): boolean
        /** Make a field for SerializedProperty.
         * @param property The SerializedProperty to make a field for.
         * @param label Optional label to use. If not specified the label of the property itself is used. Use GUIContent.none to not display a label at all.
         * @param includeChildren If true the property including children is drawn; otherwise only the control itself (such as only a foldout but nothing below it).
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns True if the property has children and is expanded and includeChildren was set to false; otherwise false. 
         */
        static PropertyField(property: SerializedProperty, label: GUIContent, ...options: GUILayoutOption[]): boolean
        /** Make a field for SerializedProperty.
         * @param property The SerializedProperty to make a field for.
         * @param label Optional label to use. If not specified the label of the property itself is used. Use GUIContent.none to not display a label at all.
         * @param includeChildren If true the property including children is drawn; otherwise only the control itself (such as only a foldout but nothing below it).
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns True if the property has children and is expanded and includeChildren was set to false; otherwise false. 
         */
        static PropertyField(property: SerializedProperty, includeChildren: boolean, ...options: GUILayoutOption[]): boolean
        /** Make a field for SerializedProperty.
         * @param property The SerializedProperty to make a field for.
         * @param label Optional label to use. If not specified the label of the property itself is used. Use GUIContent.none to not display a label at all.
         * @param includeChildren If true the property including children is drawn; otherwise only the control itself (such as only a foldout but nothing below it).
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns True if the property has children and is expanded and includeChildren was set to false; otherwise false. 
         */
        static PropertyField(property: SerializedProperty, ...options: GUILayoutOption[]): boolean
        /** Get a rect for an Editor control.
         * @param hasLabel Optional boolean to specify if the control has a label. Default is true.
         * @param height The height in pixels of the control. Default is EditorGUIUtility.singleLineHeight.
         * @param style Optional GUIStyle to use for the control.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static GetControlRect(hasLabel: boolean, height: number, style: GUIStyle, ...options: GUILayoutOption[]): Rect
        /** Get a rect for an Editor control.
         * @param hasLabel Optional boolean to specify if the control has a label. Default is true.
         * @param height The height in pixels of the control. Default is EditorGUIUtility.singleLineHeight.
         * @param style Optional GUIStyle to use for the control.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static GetControlRect(hasLabel: boolean, height: number, ...options: GUILayoutOption[]): Rect
        /** Get a rect for an Editor control.
         * @param hasLabel Optional boolean to specify if the control has a label. Default is true.
         * @param height The height in pixels of the control. Default is EditorGUIUtility.singleLineHeight.
         * @param style Optional GUIStyle to use for the control.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static GetControlRect(hasLabel: boolean, ...options: GUILayoutOption[]): Rect
        /** Get a rect for an Editor control.
         * @param hasLabel Optional boolean to specify if the control has a label. Default is true.
         * @param height The height in pixels of the control. Default is EditorGUIUtility.singleLineHeight.
         * @param style Optional GUIStyle to use for the control.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static GetControlRect(...options: GUILayoutOption[]): Rect
        /** Begins a group that can be be hidden/shown and the transition will be animated.
         * @param value A value between 0 and 1, 0 being hidden, and 1 being fully visible.
         * @returns If the group is visible or not. 
         */
        static BeginFadeGroup(value: number): boolean
        static EndFadeGroup(): void
        static BeginBuildTargetSelectionGrouping(): any
        static EndBuildTargetSelectionGrouping(): void
        /** Make a button that reacts to mouse down, for displaying your own dropdown content.
         * @param content Text, image and tooltip for this button.
         * @param focusType Whether the button should be selectable by keyboard or not.
         * @param style Optional style to use.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns true when the user clicks the button. 
         */
        static DropdownButton(content: GUIContent, focusType: FocusType, style: GUIStyle, ...options: GUILayoutOption[]): boolean
        /** Make a button that reacts to mouse down, for displaying your own dropdown content.
         * @param content Text, image and tooltip for this button.
         * @param focusType Whether the button should be selectable by keyboard or not.
         * @param style Optional style to use.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns true when the user clicks the button. 
         */
        static DropdownButton(content: GUIContent, focusType: FocusType, ...options: GUILayoutOption[]): boolean
        static BeginFoldoutHeaderGroup(foldout: boolean, content: string, style: GUIStyle, menuAction: (obj: Rect) => void, menuIcon: GUIStyle): boolean
        static BeginFoldoutHeaderGroup(foldout: boolean, content: GUIContent, style: GUIStyle, menuAction: (obj: Rect) => void, menuIcon: GUIStyle): boolean
        static EndFoldoutHeaderGroup(): void
        /** Make a field for editing a Gradient.
         * @param label Optional label to display in front of the field.
         * @param value The gradient to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The gradient edited by the user. 
         */
        static GradientField(label: GUIContent, value: Gradient, hdr: boolean, ...options: GUILayoutOption[]): Gradient
        /** Make a field for editing a Gradient.
         * @param label Optional label to display in front of the field.
         * @param value The gradient to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The gradient edited by the user. 
         */
        static GradientField(label: string, value: Gradient, ...options: GUILayoutOption[]): Gradient
        /** Make a field for editing a Gradient.
         * @param label Optional label to display in front of the field.
         * @param value The gradient to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The gradient edited by the user. 
         */
        static GradientField(label: GUIContent, value: Gradient, ...options: GUILayoutOption[]): Gradient
        /** Make a field for editing a Gradient.
         * @param label Optional label to display in front of the field.
         * @param value The gradient to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
See Also: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The gradient edited by the user. 
         */
        static GradientField(value: Gradient, ...options: GUILayoutOption[]): Gradient
        static Knob(knobSize: Vector2, value: number, minValue: number, maxValue: number, unit: string, backgroundColor: Color, activeColor: Color, showValue: boolean, ...options: GUILayoutOption[]): number
        /** Makes a toolbar populated with the collection of editor tools that match the EditorToolAttribute of the target object.
         * @param target The target object.
         * @param content An optional prefix label.
         */
        static EditorToolbarForTarget(content: GUIContent, target: Object1): void
        /** Makes a toolbar populated with the collection of editor tools that match the EditorToolAttribute of the target object.
         * @param target The target object.
         * @param content An optional prefix label.
         */
        static EditorToolbarForTarget(target: Object1): void
        /** Makes a toolbar populated with the specified collection of editor tools.
         * @param tools The collection of editor tools for the toolbar.
         */
        static EditorToolbar(...tools: any[]): void
        protected constructor()
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Rect } from "UnityEngine";
    /** Main Application class.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class EditorApplication extends Object {
        /** Open another project.
         * @param projectPath The path of a project to open.
         * @param args Arguments to pass to command line.
         */
        static OpenProject(projectPath: string, ...args: string[]): void
        static EnterPlaymode(): void
        static ExitPlaymode(): void
        static Step(): void
        static LockReloadAssemblies(): void
        static UnlockReloadAssemblies(): void
        /** Invokes the menu item in the specified path.
         */
        static ExecuteMenuItem(menuItemPath: string): boolean
        /** Sets the path that Unity should store the current temporary project at, when the project is closed.
         * @param path The path that the current temporary project should be relocated to when closing it.
         */
        static SetTemporaryProjectKeepPath(path: string): void
        /** Exit the Unity editor application.
         */
        static Exit(returnValue: number): void
        static QueuePlayerLoopUpdate(): void
        static Beep(): void
        static RepaintProjectWindow(): void
        static RepaintAnimationWindow(): void
        static RepaintHierarchyWindow(): void
        static DirtyHierarchyWindowSorting(): void
        protected constructor()
        /** Is editor currently in play mode?
         */
        static isPlaying: boolean
        /** Is editor either currently in play mode, or about to switch to it? (Read Only)
         */
        static readonly isPlayingOrWillChangePlaymode: boolean
        /** Is editor currently paused?
         */
        static isPaused: boolean
        /** Is editor currently compiling scripts? (Read Only)
         */
        static readonly isCompiling: boolean
        /** True if the Editor is currently refreshing the AssetDatabase.
         */
        static readonly isUpdating: boolean
        /** Is editor currently connected to Unity Remote 4 client app.
         */
        static readonly isRemoteConnected: boolean
        /** Path to the Unity editor contents folder. (Read Only)
         */
        static readonly applicationContentsPath: string
        /** Returns the path to the Unity editor application. (Read Only)
         */
        static readonly applicationPath: string
        /** Returns true if the current project was created as a temporary project.
         */
        static readonly isTemporaryProject: boolean
        /** The time since the editor was started. (Read Only)
         */
        static readonly timeSinceStartup: number
        static wantsToQuit(op: "add" | "remove", fn: () => boolean): void
        static quitting(op: "add" | "remove", fn: () => void): void
        static hierarchyChanged(op: "add" | "remove", fn: () => void): void
        static projectChanged(op: "add" | "remove", fn: () => void): void
        static pauseStateChanged(op: "add" | "remove", fn: (obj: PauseState) => void): void
        static playModeStateChanged(op: "add" | "remove", fn: (obj: PlayModeStateChange) => void): void
        static projectWindowItemOnGUI(op: "get"): (guid: string, selectionRect: Rect) => void
        static projectWindowItemOnGUI(op: "add" | "remove" | "set", fn?: (guid: string, selectionRect: Rect) => void): void
        static projectWindowItemOnGUI(op: "add" | "remove" | "set" | "get", fn?: (guid: string, selectionRect: Rect) => void): (guid: string, selectionRect: Rect) => void | void
        static hierarchyWindowItemOnGUI(op: "get"): (instanceID: number, selectionRect: Rect) => void
        static hierarchyWindowItemOnGUI(op: "add" | "remove" | "set", fn?: (instanceID: number, selectionRect: Rect) => void): void
        static hierarchyWindowItemOnGUI(op: "add" | "remove" | "set" | "get", fn?: (instanceID: number, selectionRect: Rect) => void): (instanceID: number, selectionRect: Rect) => void | void
        static update(op: "get"): () => void
        static update(op: "add" | "remove" | "set", fn?: () => void): void
        static update(op: "add" | "remove" | "set" | "get", fn?: () => void): () => void | void
        static delayCall(op: "get"): () => void
        static delayCall(op: "add" | "remove" | "set", fn?: () => void): void
        static delayCall(op: "add" | "remove" | "set" | "get", fn?: () => void): () => void | void
        static searchChanged(op: "get"): () => void
        static searchChanged(op: "add" | "remove" | "set", fn?: () => void): void
        static searchChanged(op: "add" | "remove" | "set" | "get", fn?: () => void): () => void | void
        static modifierKeysChanged(op: "get"): () => void
        static modifierKeysChanged(op: "add" | "remove" | "set", fn?: () => void): void
        static modifierKeysChanged(op: "add" | "remove" | "set" | "get", fn?: () => void): () => void | void
        static contextualPropertyMenu(op: "get"): (menu: GenericMenu, property: SerializedProperty) => void
        static contextualPropertyMenu(op: "add" | "remove" | "set", fn?: (menu: GenericMenu, property: SerializedProperty) => void): void
        static contextualPropertyMenu(op: "add" | "remove" | "set" | "get", fn?: (menu: GenericMenu, property: SerializedProperty) => void): (menu: GenericMenu, property: SerializedProperty) => void | void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ScriptableObject, Object, GUIContent, Texture2D, Rect, GUIStyle } from "UnityEngine";
    import { Array, Object as Object1 } from "System";
    /** Derive from this base class to create a custom inspector or editor for your custom object.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class Editor extends ScriptableObject {
        constructor()
        DrawDefaultInspector(): boolean
        Repaint(): void
        OnInspectorGUI(): void
        CreateInspectorGUI(): any
        RequiresConstantRepaint(): boolean
        DrawHeader(): void
        HasPreviewGUI(): boolean
        GetPreviewTitle(): GUIContent
        /** Override this method if you want to render a static preview.
         * @param assetPath The asset to operate on.
         * @param subAssets An array of all Assets at assetPath.
         * @param width Width of the created texture.
         * @param height Height of the created texture.
         * @returns Generated texture or null. 
         */
        RenderStaticPreview(assetPath: string, subAssets: Array<Object>, width: number, height: number): Texture2D
        /** Implement to create your own custom preview for the preview area of the inspector, the headers of the primary editor, and the object selector.
         * @param r Rectangle in which to draw the preview.
         * @param background Background image.
         */
        OnPreviewGUI(r: Rect, background: GUIStyle): void
        /** Implement to create your own interactive custom preview. Interactive custom previews are used in the preview area of the inspector and the object selector.
         * @param r Rectangle in which to draw the preview.
         * @param background Background image.
         */
        OnInteractivePreviewGUI(r: Rect, background: GUIStyle): void
        OnPreviewSettings(): void
        GetInfoString(): string
        /** The first entry point for Preview Drawing.
         * @param previewPosition The available area to draw the preview.
         */
        DrawPreview(previewArea: Rect): void
        ReloadPreviewInstances(): void
        UseDefaultMargins(): boolean
        Initialize(targets: Array<Object>): void
        MoveNextTarget(): boolean
        ResetTarget(): void
        /** Make a custom editor for targetObject or targetObjects with a context object.
         */
        static CreateEditorWithContext(targetObjects: Array<Object>, context: Object, editorType: any): Editor
        static CreateEditorWithContext(targetObjects: Array<Object>, context: Object): Editor
        /** Creates a cached editor using a context object.
         */
        static CreateCachedEditorWithContext(targetObject: Object, context: Object, editorType: any, previousEditor: jsb.Ref<Editor>): void
        /** Creates a cached editor using a context object.
         */
        static CreateCachedEditorWithContext(targetObjects: Array<Object>, context: Object, editorType: any, previousEditor: jsb.Ref<Editor>): void
        /** On return previousEditor is an editor for targetObject or targetObjects. The function either returns if the editor is already tracking the objects, or destroys the previous editor and creates a new one.
         * @param obj The object the editor is tracking.
         * @param editorType The requested editor type. Set to null for the default editor for the object.
         * @param previousEditor The previous editor for the object. After returning from CreateCachedEditor previousEditor is an editor for the targetObject or targetObjects.
         * @param objects The objects the editor is tracking.
         */
        static CreateCachedEditor(targetObject: Object, editorType: any, previousEditor: jsb.Ref<Editor>): void
        /** On return previousEditor is an editor for targetObject or targetObjects. The function either returns if the editor is already tracking the objects, or destroys the previous editor and creates a new one.
         * @param obj The object the editor is tracking.
         * @param editorType The requested editor type. Set to null for the default editor for the object.
         * @param previousEditor The previous editor for the object. After returning from CreateCachedEditor previousEditor is an editor for the targetObject or targetObjects.
         * @param objects The objects the editor is tracking.
         */
        static CreateCachedEditor(targetObjects: Array<Object>, editorType: any, previousEditor: jsb.Ref<Editor>): void
        /** Make a custom editor for targetObject or targetObjects.
         * @param objects All objects must be of the same type.
         */
        static CreateEditor(targetObject: Object, editorType: any): Editor
        /** Make a custom editor for targetObject or targetObjects.
         * @param objects All objects must be of the same type.
         */
        static CreateEditor(targetObjects: Array<Object>, editorType: any): Editor
        /** Make a custom editor for targetObject or targetObjects.
         * @param objects All objects must be of the same type.
         */
        static CreateEditor(targetObject: Object): Editor
        /** Make a custom editor for targetObject or targetObjects.
         * @param objects All objects must be of the same type.
         */
        static CreateEditor(targetObjects: Array<Object>): Editor
        /** Draws the inspector GUI with a foldout header for target.
         * @param target The object to display the Inspector for.
         * @param editor The reference to a variable of type Editor.
         */
        static DrawFoldoutInspector(target: Object, editor: jsb.Ref<Editor>): void
        /** The object being inspected.
         */
        target: Object
        /** An array of all the object being inspected.
         */
        readonly targets: Array<Object>
        /** A SerializedObject representing the object or objects being inspected.
         */
        readonly serializedObject: SerializedObject
        static finishedDefaultHeaderGUI(op: "add" | "remove", fn: (obj: Editor) => void): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ScriptableObject, Vector2, GUIContent, Rect, Event } from "UnityEngine";
    import { Object } from "System";
    import { IEnumerable } from "System.Collections.Generic";
    /** Derive from this class to create an editor window.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class EditorWindow extends ScriptableObject {
        constructor()
        BeginWindows(): void
        EndWindows(): void
        /** Show a notification message.
         * @param notification The contents of the notification message.
         * @param fadeoutWait The duration the notification is displayed. Measured in seconds.
         */
        ShowNotification(notification: GUIContent, fadeoutWait: number): void
        /** Show a notification message.
         * @param notification The contents of the notification message.
         * @param fadeoutWait The duration the notification is displayed. Measured in seconds.
         */
        ShowNotification(notification: GUIContent): void
        RemoveNotification(): void
        ShowTab(): void
        Focus(): void
        ShowUtility(): void
        ShowPopup(): void
        ShowModalUtility(): void
        /** Shows a window with dropdown behaviour and styling.
         * @param buttonRect The button from which the position of the window will be determined (see description).
         * @param windowSize The initial size of the window.
         */
        ShowAsDropDown(buttonRect: Rect, windowSize: Vector2): void
        /** Show the EditorWindow window.
         * @param immediateDisplay Immediately display Show.
         */
        Show(immediateDisplay: boolean): void
        Show(): void
        ShowAuxWindow(): void
        ShowModal(): void
        Close(): void
        Repaint(): void
        /** Sends an Event to a window.
         */
        SendEvent(e: Event): boolean
        GetExtraPaneTypes(): any
        /** Returns the first EditorWindow of type t which is currently on the screen.
         * @param t The type of the window. Must derive from EditorWindow.
         * @param utility Set this to true, to create a floating utility window, false to create a normal window.
         * @param title If GetWindow creates a new window, it will get this title. If this value is null, use the class name as title.
         * @param focus Whether to give the window focus, if it already exists. (If GetWindow creates a new window, it will always get focus).
         */
        static GetWindow<T extends EditorWindow>(type: { new(): T }): T
        /** Focuses the first found EditorWindow of specified type if it is open.
         * @param t The type of the window. Must derive from EditorWindow.
         */
        static FocusWindowIfItsOpen(t: any): void
        static CreateWindow<T extends EditorWindow>(type: { new(): T }, ...desiredDockNextTo: any[]): T
        static CreateWindow<T extends EditorWindow>(type: { new(): T }, title: string, ...desiredDockNextTo: any[]): T
        /** Retrieves the root visual element of this window hierarchy.
         */
        readonly rootVisualElement: any
        /** Checks whether MouseMove events are received in the GUI in this Editor window.
         */
        wantsMouseMove: boolean
        /** Checks whether MouseEnterWindow and MouseLeaveWindow events are received in the GUI in this Editor window.
         */
        wantsMouseEnterLeaveWindow: boolean
        /** Does the window automatically repaint whenever the Scene has changed?
         */
        autoRepaintOnSceneChange: boolean
        /** Is this window maximized?
         */
        maximized: boolean
        /** The EditorWindow which currently has keyboard focus. (Read Only)
         */
        static readonly focusedWindow: EditorWindow
        /** The EditorWindow currently under the mouse cursor. (Read Only)
         */
        static readonly mouseOverWindow: EditorWindow
        /** The minimum size of this window.
         */
        minSize: Vector2
        /** The maximum size of this window.
         */
        maxSize: Vector2
        /** The GUIContent used for drawing the title of EditorWindows.
         */
        titleContent: GUIContent
        depthBufferBits: number
        /** The desired position of the window in screen space.
         */
        position: Rect
    }
}
declare module "FairyGUI" {
    import { Enum } from "System";
    enum ProgressTitleType {
        Percent = 0,
        ValueAndMax = 1,
        Value = 2,
        Max = 3,
    }
}
declare module "FairyGUI" {
    import { Enum } from "System";
    enum PackageItemType {
        Image = 0,
        MovieClip = 1,
        Sound = 2,
        Component = 3,
        Atlas = 4,
        Font = 5,
        Swf = 6,
        Misc = 7,
        Unknown = 8,
        Spine = 9,
        DragoneBones = 10,
    }
}
declare module "FairyGUI" {
    import { Enum } from "System";
    enum DestroyMethod {
        Destroy = 0,
        Unload = 1,
        None = 2,
        ReleaseTemp = 3,
        Custom = 4,
    }
}
declare module "FairyGUI" {
    import { Enum } from "System";
    enum ObjectType {
        Image = 0,
        MovieClip = 1,
        Swf = 2,
        Graph = 3,
        Loader = 4,
        Group = 5,
        Text = 6,
        RichText = 7,
        InputText = 8,
        Component = 9,
        List = 10,
        Label = 11,
        Button = 12,
        ComboBox = 13,
        ProgressBar = 14,
        Slider = 15,
        ScrollBar = 16,
        Tree = 17,
        Loader3D = 18,
    }
}
declare module "FairyGUI" {
    import { Enum } from "System";
    enum RelationType {
        Left_Left = 0,
        Left_Center = 1,
        Left_Right = 2,
        Center_Center = 3,
        Right_Left = 4,
        Right_Center = 5,
        Right_Right = 6,
        Top_Top = 7,
        Top_Middle = 8,
        Top_Bottom = 9,
        Middle_Middle = 10,
        Bottom_Top = 11,
        Bottom_Middle = 12,
        Bottom_Bottom = 13,
        Width = 14,
        Height = 15,
        LeftExt_Left = 16,
        LeftExt_Right = 17,
        RightExt_Left = 18,
        RightExt_Right = 19,
        TopExt_Top = 20,
        TopExt_Bottom = 21,
        BottomExt_Top = 22,
        BottomExt_Bottom = 23,
        Size = 24,
    }
}
declare module "FairyGUI" {
    import { Enum } from "System";
    enum GroupLayoutType {
        None = 0,
        Horizontal = 1,
        Vertical = 2,
    }
}
declare module "FairyGUI" {
    import { Enum } from "System";
    enum ChildrenRenderOrder {
        Ascent = 0,
        Descent = 1,
        Arch = 2,
    }
}
declare module "FairyGUI" {
    import { Enum } from "System";
    enum FlipType {
        None = 0,
        Horizontal = 1,
        Vertical = 2,
        Both = 3,
    }
}
declare module "FairyGUI" {
    import { Enum } from "System";
    enum FillMethod {
        None = 0,
        Horizontal = 1,
        Vertical = 2,
        Radial90 = 3,
        Radial180 = 4,
        Radial360 = 5,
    }
}
declare module "FairyGUI" {
    import { Enum } from "System";
    enum ListLayoutType {
        SingleColumn = 0,
        SingleRow = 1,
        FlowHorizontal = 2,
        FlowVertical = 3,
        Pagination = 4,
    }
}
declare module "FairyGUI" {
    import { Object } from "System";
    import { IEnumerable } from "System.Collections.Generic";
    class CustomEase extends Object {
        constructor(pointDensity: number)
        Create(pathPoints: IEnumerable<GPathPoint>): void
        Evaluate(time: number): number
    }
}
declare module "FairyGUI" {
    import { ValueType } from "System";
    import { Vector3 } from "UnityEngine";
    class GPathPoint extends ValueType {
        constructor(pos: Vector3, control1: Vector3, control2: Vector3)
        constructor(pos: Vector3, control: Vector3)
        constructor(pos: Vector3, curveType: GPathPoint.CurveType)
        constructor(pos: Vector3)
        pos: Vector3
        control1: Vector3
        control2: Vector3
        curveType: GPathPoint.CurveType
        smooth: boolean
    }
}
declare module "FairyGUI" {
    import { Enum } from "System";
    namespace GPathPoint {
        enum CurveType {
            CRSpline = 0,
            Bezier = 1,
            CubicBezier = 2,
            Straight = 3,
        }
    }
}
declare module "FairyGUI" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Rect, Vector2, Texture, Sprite } from "UnityEngine";
    class NTexture extends Object {
        constructor(root: NTexture, region: Rect, rotated: boolean, originalSize: Vector2, offset: Vector2)
        constructor(texture: Texture, alphaTexture: Texture, xScale: number, yScale: number)
        constructor(root: NTexture, region: Rect, rotated: boolean)
        constructor(texture: Texture, region: Rect)
        constructor(texture: Texture)
        constructor(sprite: Sprite)
        GetDrawRect(drawRect: Rect): Rect
        GetUV(uv: Array<Vector2>): void
        GetMaterialManager(shaderName: string): MaterialManager
        Unload(destroyMaterials: boolean): void
        Unload(): void
        Reload(nativeTexture: Texture, alphaTexture: Texture): void
        AddRef(): void
        ReleaseRef(): void
        Dispose(): void
        static DisposeEmpty(): void
        static readonly Empty: NTexture
        readonly width: number
        readonly height: number
        offset: Vector2
        originalSize: Vector2
        readonly root: NTexture
        readonly disposed: boolean
        readonly nativeTexture: Texture
        readonly alphaTexture: Texture
        uvRect: Rect
        rotated: boolean
        refCount: number
        lastActive: number
        destroyMethod: DestroyMethod
        static CustomDestroyMethod(op: "add" | "remove", fn: (obj: Texture) => void): void
        onSizeChanged(op: "add" | "remove", fn: (obj: NTexture) => void): void
        onRelease(op: "add" | "remove", fn: (obj: NTexture) => void): void
    }
}
declare module "FairyGUI.Utils" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { GPathPoint } from "FairyGUI";
    import { List } from "System.Collections.Generic";
    import { Color } from "UnityEngine";
    class ByteBuffer extends Object {
        constructor(data: Array<jsb.byte>, offset: number, length: number)
        Skip(count: number): number
        ReadByte(): jsb.byte
        ReadBytes(output: Array<jsb.byte>, destIndex: number, count: number): Array<jsb.byte>
        ReadBytes(count: number): Array<jsb.byte>
        ReadBuffer(): ByteBuffer
        ReadChar(): string
        ReadBool(): boolean
        ReadShort(): number
        ReadUshort(): number
        ReadInt(): number
        ReadUint(): number
        ReadFloat(): number
        ReadLong(): number
        ReadDouble(): number
        ReadString(len: number): string
        ReadString(): string
        ReadS(): string
        ReadSArray(cnt: number): Array<string>
        ReadPath(): any
        WriteS(value: string): void
        ReadColor(): Color
        Seek(indexTablePos: number, blockIndex: number): boolean
        position: number
        readonly length: number
        readonly bytesAvailable: boolean
        buffer: Array<jsb.byte>
        littleEndian: boolean
        stringTable: Array<string>
        version: number
    }
}
declare module "FairyGUI" {
    import { Enum } from "System";
    enum OverflowType {
        Visible = 0,
        Hidden = 1,
        Scroll = 2,
    }
}
declare module "FairyGUI" {
    import { Enum } from "System";
    enum FillType {
        None = 0,
        Scale = 1,
        ScaleMatchHeight = 2,
        ScaleMatchWidth = 3,
        ScaleFree = 4,
        ScaleNoBorder = 5,
    }
}
declare module "FairyGUI" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { ByteBuffer } from "FairyGUI.Utils";
    class PixelHitTestData extends Object {
        constructor()
        Load(ba: ByteBuffer): void
        pixelWidth: number
        scale: number
        pixels: Array<jsb.byte>
        pixelsLength: number
        pixelsOffset: number
    }
}
declare module "FairyGUI" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Vector3, Vector2, Color32 } from "UnityEngine";
    import { List } from "System.Collections.Generic";
    class BitmapFont extends Object {
        constructor()
        AddChar(ch: string, glyph: BitmapFont.BMGlyph): void
        SetFormat(format: TextFormat, fontSizeScale: number): void
        GetGlyph(ch: string, width: jsb.Out<number>, height: jsb.Out<number>, baseline: jsb.Out<number>): boolean
        DrawGlyph(x: number, y: number, vertList: any, uvList: any, uv2List: any, colList: any): number
        HasCharacter(ch: string): boolean
        GetLineHeight(size: number): number
        size: number
        resizable: boolean
        hasChannel: boolean
    }
}
declare module "FairyGUI" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Vector2 } from "UnityEngine";
    namespace BitmapFont {
        class BMGlyph extends Object {
            constructor()
            x: number
            y: number
            width: number
            height: number
            advance: number
            lineHeight: number
            uv: Array<Vector2>
            channel: number
        }
    }
}
declare module "FairyGUI" {
    import { Enum } from "System";
    enum TransitionActionType {
        XY = 0,
        Size = 1,
        Scale = 2,
        Pivot = 3,
        Alpha = 4,
        Rotation = 5,
        Color = 6,
        Animation = 7,
        Visible = 8,
        Sound = 9,
        Transition = 10,
        Shake = 11,
        ColorFilter = 12,
        Skew = 13,
        Text = 14,
        Icon = 15,
        Unknown = 16,
    }
}
declare module "FairyGUI" {
    import { Enum } from "System";
    enum AutoSizeType {
        None = 0,
        Both = 1,
        Height = 2,
        Shrink = 3,
    }
}
declare module "FairyGUI" {
    import { Enum } from "System";
    enum TweenPropType {
        None = 0,
        X = 1,
        Y = 2,
        Z = 3,
        XY = 4,
        Position = 5,
        Width = 6,
        Height = 7,
        Size = 8,
        ScaleX = 9,
        ScaleY = 10,
        Scale = 11,
        Rotation = 12,
        RotationX = 13,
        RotationY = 14,
        Alpha = 15,
        Progress = 16,
    }
}
declare module "FairyGUI" {
    import { Enum } from "System";
    enum ScrollType {
        Horizontal = 0,
        Vertical = 1,
        Both = 2,
    }
}
declare module "FairyGUI" {
    import { Enum } from "System";
    enum ScrollBarDisplayType {
        Default = 0,
        Visible = 1,
        Auto = 2,
        Hidden = 3,
    }
}
declare module "FairyGUI" {
    import { Enum } from "System";
    enum ButtonMode {
        Common = 0,
        Check = 1,
        Radio = 2,
    }
}
declare module "FairyGUI" {
    import { Enum } from "System";
    enum AlignType {
        Left = 0,
        Center = 1,
        Right = 2,
    }
}
declare module "FairyGUI" {
    import { Enum } from "System";
    enum VertAlignType {
        Top = 0,
        Middle = 1,
        Bottom = 2,
    }
}
declare module "FairyGUI" {
    import { Enum } from "System";
    enum OriginHorizontal {
        Left = 0,
        Right = 1,
    }
}
declare module "FairyGUI" {
    import { Enum } from "System";
    enum OriginVertical {
        Top = 0,
        Bottom = 1,
    }
}
declare module "FairyGUI" {
    import { Enum } from "System";
    enum ListSelectionMode {
        Single = 0,
        Multiple = 1,
        Multiple_SingleClick = 2,
        None = 3,
    }
}
declare module "FairyGUI" {
    import { Enum } from "System";
    enum PopupDirection {
        Auto = 0,
        Up = 1,
        Down = 2,
    }
}
declare module "FairyGUI" {
    import { Object } from "System";
    import { AudioClip } from "UnityEngine";
    class NAudioClip extends Object {
        constructor(audioClip: AudioClip)
        Unload(): void
        Reload(audioClip: AudioClip): void
        destroyMethod: DestroyMethod
        nativeClip: AudioClip
        static CustomDestroyMethod(op: "get"): (obj: AudioClip) => void
        static CustomDestroyMethod(op: "add" | "remove" | "set", fn?: (obj: AudioClip) => void): void
        static CustomDestroyMethod(op: "add" | "remove" | "set" | "get", fn?: (obj: AudioClip) => void): (obj: AudioClip) => void | void
    }
}
declare module "FairyGUI" {
    import { MonoBehaviour } from "UnityEngine";
    class UIContentScaler extends MonoBehaviour {
        constructor()
        ApplyModifiedProperties(): void
        ApplyChange(): void
        scaleMode: UIContentScaler.ScaleMode
        screenMatchMode: UIContentScaler.ScreenMatchMode
        designResolutionX: number
        designResolutionY: number
        fallbackScreenDPI: number
        defaultSpriteDPI: number
        constantScaleFactor: number
        ignoreOrientation: boolean
        static scaleFactor: number
        static scaleLevel: number
    }
}
declare module "FairyGUI" {
    import { Enum } from "System";
    namespace UIContentScaler {
        enum ScaleMode {
            ConstantPixelSize = 0,
            ScaleWithScreenSize = 1,
            ConstantPhysicalSize = 2,
        }
    }
}
declare module "FairyGUI" {
    import { Enum } from "System";
    namespace UIContentScaler {
        enum ScreenMatchMode {
            MatchWidthOrHeight = 0,
            MatchWidth = 1,
            MatchHeight = 2,
        }
    }
}
declare module "FairyGUI" {
    import { Object } from "System";
    class EventContext extends Object {
        constructor()
        StopPropagation(): void
        PreventDefault(): void
        CaptureTouch(): void
        readonly sender: EventDispatcher
        readonly initiator: Object
        readonly inputEvent: InputEvent
        readonly isDefaultPrevented: boolean
        type: string
        data: Object
    }
}
declare module "FairyGUI" {
    import { Object } from "System";
    class EventDispatcher extends Object {
        constructor()
        AddEventListener(strType: string, callback: (context: EventContext) => void): void
        AddEventListener(strType: string, callback: () => void): void
        RemoveEventListener(strType: string, callback: (context: EventContext) => void): void
        RemoveEventListener(strType: string, callback: () => void): void
        AddCapture(strType: string, callback: (context: EventContext) => void): void
        RemoveCapture(strType: string, callback: (context: EventContext) => void): void
        RemoveEventListeners(strType: string): void
        RemoveEventListeners(): void
        hasEventListeners(strType: string): boolean
        isDispatching(strType: string): boolean
        DispatchEvent(strType: string, data: Object, initiator: Object): boolean
        DispatchEvent(strType: string, data: Object): boolean
        DispatchEvent(strType: string): boolean
        DispatchEvent(context: EventContext): boolean
        BubbleEvent(strType: string, data: Object): boolean
        BroadcastEvent(strType: string, data: Object): boolean
    }
}
declare module "FairyGUI" {
    import { Object } from "System";
    class EventListener extends Object {
        constructor(owner: EventDispatcher, type: string)
        AddCapture(callback: (context: EventContext) => void): void
        RemoveCapture(callback: (context: EventContext) => void): void
        Add(callback: (context: EventContext) => void): void
        Add(callback: () => void): void
        Remove(callback: (context: EventContext) => void): void
        Remove(callback: () => void): void
        Set(callback: (context: EventContext) => void): void
        Set(callback: () => void): void
        Clear(): void
        Call(data: Object): boolean
        Call(): boolean
        BubbleCall(data: Object): boolean
        BubbleCall(): boolean
        BroadcastCall(data: Object): boolean
        BroadcastCall(): boolean
        readonly type: string
        readonly isEmpty: boolean
        readonly isDispatching: boolean
    }
}
declare module "FairyGUI" {
    class GScrollBar extends GComponent {
        constructor()
        SetScrollPane(target: ScrollPane, vertical: boolean): void
        SetDisplayPerc(value: number): void
        setScrollPerc(value: number): void
        readonly minSize: number
        readonly gripDragging: boolean
    }
}
declare module "FairyGUI" {
    import { Object } from "System";
    import { IEnumerable, List } from "System.Collections.Generic";
    import { Vector3 } from "UnityEngine";
    class GPath extends Object {
        constructor()
        Create(pt1: GPathPoint, pt2: GPathPoint, pt3: GPathPoint, pt4: GPathPoint): void
        Create(pt1: GPathPoint, pt2: GPathPoint, pt3: GPathPoint): void
        Create(pt1: GPathPoint, pt2: GPathPoint): void
        Create(points: IEnumerable<GPathPoint>): void
        Clear(): void
        GetPointAt(t: number): Vector3
        GetSegmentLength(segmentIndex: number): number
        GetPointsInSegment(segmentIndex: number, t0: number, t1: number, points: any, ts: any, pointDensity: number): void
        GetAllPoints(points: any, pointDensity: number): void
        readonly length: number
        readonly segmentCount: number
    }
}
declare module "FairyGUI" {
    import { Object } from "System";
    import { KeyCode, EventModifiers, Vector2 } from "UnityEngine";
    class InputEvent extends Object {
        constructor()
        readonly x: number
        readonly y: number
        readonly keyCode: KeyCode
        readonly character: string
        readonly modifiers: EventModifiers
        readonly mouseWheelDelta: number
        readonly touchId: number
        readonly button: number
        readonly clickCount: number
        readonly holdTime: number
        readonly position: Vector2
        readonly isDoubleClick: boolean
        readonly ctrlOrCmd: boolean
        readonly ctrl: boolean
        readonly shift: boolean
        readonly alt: boolean
        readonly command: boolean
    }
}
declare module "FairyGUI" {
    import * as jsb from "jsb";
    import { GameObject, Transform, Vector2, Vector3, Material, Texture2D, Rect } from "UnityEngine";
    import { ValueType, Object } from "System";
    class DisplayObject extends EventDispatcher {
        constructor()
        SetXY(xv: number, yv: number): void
        SetPosition(xv: number, yv: number, zv: number): void
        SetSize(wv: number, hv: number): void
        EnsureSizeCorrect(): void
        SetScale(xv: number, yv: number): void
        EnterPaintingMode(requestorId: number, extend: jsb.Nullable<Margin>, scale: number): void
        EnterPaintingMode(requestorId: number, extend: jsb.Nullable<Margin>): void
        EnterPaintingMode(): void
        LeavePaintingMode(requestorId: number): void
        GetScreenShot(extend: jsb.Nullable<Margin>, scale: number): Texture2D
        GetBounds(targetSpace: DisplayObject): Rect
        GlobalToLocal(point: Vector2): Vector2
        LocalToGlobal(point: Vector2): Vector2
        WorldToLocal(worldPoint: Vector3, direction: Vector3): Vector3
        LocalToWorld(localPoint: Vector3): Vector3
        TransformPoint(point: Vector2, targetSpace: DisplayObject): Vector2
        TransformRect(rect: Rect, targetSpace: DisplayObject): Rect
        RemoveFromParent(): void
        InvalidateBatchingState(): void
        Update(context: any): void
        Dispose(): void
        readonly parent: Container
        readonly gameObject: GameObject
        readonly cachedTransform: Transform
        readonly graphics: NGraphics
        readonly paintingGraphics: NGraphics
        readonly onClick: EventListener
        readonly onRightClick: EventListener
        readonly onTouchBegin: EventListener
        readonly onTouchMove: EventListener
        readonly onTouchEnd: EventListener
        readonly onRollOver: EventListener
        readonly onRollOut: EventListener
        readonly onMouseWheel: EventListener
        readonly onAddedToStage: EventListener
        readonly onRemovedFromStage: EventListener
        readonly onKeyDown: EventListener
        readonly onClickLink: EventListener
        readonly onFocusIn: EventListener
        readonly onFocusOut: EventListener
        alpha: number
        grayed: boolean
        visible: boolean
        x: number
        y: number
        z: number
        xy: Vector2
        position: Vector3
        pixelPerfect: boolean
        width: number
        height: number
        size: Vector2
        scaleX: number
        scaleY: number
        scale: Vector2
        rotation: number
        rotationX: number
        rotationY: number
        skew: Vector2
        perspective: boolean
        focalLength: number
        pivot: Vector2
        location: Vector3
        material: Material
        shader: string
        renderingOrder: number
        layer: number
        focusable: boolean
        tabStop: boolean
        readonly focused: boolean
        cursor: string
        readonly isDisposed: boolean
        readonly topmost: Container
        readonly stage: Stage
        readonly worldSpaceContainer: Container
        touchable: boolean
        readonly touchDisabled: boolean
        readonly paintingMode: boolean
        cacheAsBitmap: boolean
        filter: IFilter
        blendMode: BlendMode
        home: Transform
        name: string
        gOwner: GObject
        id: number
        onPaint(op: "add" | "remove", fn: () => void): void
    }
}
declare module "FairyGUI" {
    import * as jsb from "jsb";
    import { RenderMode, Camera, Vector4, Rect, GameObject, Vector2 } from "UnityEngine";
    import { ValueType, Array, Object } from "System";
    import { IList } from "System.Collections.Generic";
    class Container extends DisplayObject {
        constructor(gameObjectName: string)
        constructor(attachTarget: GameObject)
        constructor()
        AddChild(child: DisplayObject): DisplayObject
        AddChildAt(child: DisplayObject, index: number): DisplayObject
        Contains(child: DisplayObject): boolean
        GetChildAt(index: number): DisplayObject
        GetChild(name: string): DisplayObject
        GetChildren(): Array<DisplayObject>
        GetChildIndex(child: DisplayObject): number
        RemoveChild(child: DisplayObject, dispose: boolean): DisplayObject
        RemoveChild(child: DisplayObject): DisplayObject
        RemoveChildAt(index: number, dispose: boolean): DisplayObject
        RemoveChildAt(index: number): DisplayObject
        RemoveChildren(beginIndex: number, endIndex: number, dispose: boolean): void
        RemoveChildren(): void
        SetChildIndex(child: DisplayObject, index: number): void
        SwapChildren(child1: DisplayObject, child2: DisplayObject): void
        SwapChildrenAt(index1: number, index2: number): void
        ChangeChildrenOrder(indice: any, objs: any): void
        GetDescendants(backward: boolean): any
        CreateGraphics(): void
        GetBounds(targetSpace: DisplayObject): Rect
        GetRenderCamera(): Camera
        HitTest(stagePoint: Vector2, forTouch: boolean): DisplayObject
        IsAncestorOf(obj: DisplayObject): boolean
        InvalidateBatchingState(childrenChanged: boolean): void
        SetChildrenLayer(value: number): void
        Update(context: any): void
        Dispose(): void
        InvalidateBatchingState()
        readonly numChildren: number
        clipRect: jsb.Nullable<Rect>
        mask: DisplayObject
        fairyBatching: boolean
        tabStopChildren: boolean
        renderMode: RenderMode
        renderCamera: Camera
        opaque: boolean
        clipSoftness: jsb.Nullable<Vector4>
        hitArea: any
        touchChildren: boolean
        reversedMask: boolean
        onUpdate(op: "add" | "remove", fn: () => void): void
    }
}
declare module "FairyGUI" {
    import * as jsb from "jsb";
    import { Vector2, AudioClip, RaycastHit, Texture2D } from "UnityEngine";
    import { Array } from "System";
    class Stage extends Container {
        constructor()
        Dispose(): void
        SetFous(newFocus: DisplayObject, byKey: boolean): void
        DoKeyNavigate(backward: boolean): void
        GetTouchPosition(touchId: number): Vector2
        GetTouchTarget(touchId: number): DisplayObject
        GetAllTouch(result: Array<number>): Array<number>
        ResetInputState(): void
        CancelClick(touchId: number): void
        EnableSound(): void
        DisableSound(): void
        PlayOneShotSound(clip: AudioClip, volumeScale: number): void
        PlayOneShotSound(clip: AudioClip): void
        OpenKeyboard(text: string, autocorrection: boolean, multiline: boolean, secure: boolean, alert: boolean, textPlaceholder: string, keyboardType: number, hideInput: boolean): void
        CloseKeyboard(): void
        InputString(value: string): void
        SetCustomInput(screenPos: Vector2, buttonDown: boolean, buttonUp: boolean): void
        SetCustomInput(hit: jsb.Ref<RaycastHit>, buttonDown: boolean, buttonUp: boolean): void
        SetCustomInput(screenPos: Vector2, buttonDown: boolean): void
        SetCustomInput(hit: jsb.Ref<RaycastHit>, buttonDown: boolean): void
        ForceUpdate(): void
        ApplyPanelOrder(target: Container): void
        SortWorldSpacePanelsByZOrder(panelSortingOrder: number): void
        MonitorTexture(texture: NTexture): void
        AddTouchMonitor(touchId: number, target: EventDispatcher): void
        RemoveTouchMonitor(target: EventDispatcher): void
        IsTouchMonitoring(target: EventDispatcher): boolean
        RegisterCursor(cursorName: string, texture: Texture2D, hotspot: Vector2): void
        static Instantiate(): void
        soundVolume: number
        static readonly inst: Stage
        static touchScreen: boolean
        static keyboardInput: boolean
        static readonly isTouchOnUI: boolean
        static devicePixelRatio: number
        readonly onStageResized: EventListener
        readonly touchTarget: DisplayObject
        focus: DisplayObject
        readonly touchPosition: Vector2
        readonly touchCount: number
        keyboard: IKeyboard
        readonly activeCursor: string
        beforeUpdate(op: "add" | "remove", fn: () => void): void
        afterUpdate(op: "add" | "remove", fn: () => void): void
    }
}
declare module "FairyGUI" {
    import { ByteBuffer } from "FairyGUI.Utils";
    class Controller extends EventDispatcher {
        constructor()
        Dispose(): void
        SetSelectedIndex(value: number): void
        SetSelectedPage(value: string): void
        GetPageName(index: number): string
        GetPageId(index: number): string
        GetPageIdByName(aName: string): string
        AddPage(name: string): void
        AddPageAt(name: string, index: number): void
        RemovePage(name: string): void
        RemovePageAt(index: number): void
        ClearPages(): void
        HasPage(aName: string): boolean
        RunActions(): void
        Setup(buffer: ByteBuffer): void
        readonly onChanged: EventListener
        selectedIndex: number
        selectedPage: string
        readonly previsousIndex: number
        readonly previousPage: string
        readonly pageCount: number
        name: string
    }
}
declare module "FairyGUI" {
    import * as jsb from "jsb";
    import { Object, ValueType } from "System";
    import { Rect, Vector2, Vector3, Camera } from "UnityEngine";
    import { ByteBuffer } from "FairyGUI.Utils";
    class GObject extends EventDispatcher {
        constructor()
        SetXY(xv: number, yv: number, topLeftValue: boolean): void
        SetXY(xv: number, yv: number): void
        SetPosition(xv: number, yv: number, zv: number): void
        Center(restraint: boolean): void
        Center(): void
        MakeFullScreen(): void
        SetSize(wv: number, hv: number, ignorePivot: boolean): void
        SetSize(wv: number, hv: number): void
        SetScale(wv: number, hv: number): void
        SetPivot(xv: number, yv: number, asAnchor: boolean): void
        SetPivot(xv: number, yv: number): void
        RequestFocus(byKey: boolean): void
        RequestFocus(): void
        SetHome(obj: GObject): void
        GetGear(index: number): any
        InvalidateBatchingState(): void
        HandleControllerChanged(c: Controller): void
        AddRelation(target: GObject, relationType: RelationType, usePercent: boolean): void
        AddRelation(target: GObject, relationType: RelationType): void
        RemoveRelation(target: GObject, relationType: RelationType): void
        RemoveFromParent(): void
        StartDrag(touchId: number): void
        StartDrag(): void
        StopDrag(): void
        LocalToGlobal(pt: Vector2): Vector2
        LocalToGlobal(rect: Rect): Rect
        GlobalToLocal(pt: Vector2): Vector2
        GlobalToLocal(rect: Rect): Rect
        LocalToRoot(pt: Vector2, r: GRoot): Vector2
        RootToLocal(pt: Vector2, r: GRoot): Vector2
        WorldToLocal(pt: Vector3, camera: Camera): Vector2
        WorldToLocal(pt: Vector3): Vector2
        TransformPoint(pt: Vector2, targetSpace: GObject): Vector2
        TransformRect(rect: Rect, targetSpace: GObject): Rect
        Dispose(): void
        ConstructFromResource(): void
        Setup_BeforeAdd(buffer: ByteBuffer, beginPos: number): void
        Setup_AfterAdd(buffer: ByteBuffer, beginPos: number): void
        TweenMove(endValue: Vector2, duration: number): GTweener
        TweenMoveX(endValue: number, duration: number): GTweener
        TweenMoveY(endValue: number, duration: number): GTweener
        TweenScale(endValue: Vector2, duration: number): GTweener
        TweenScaleX(endValue: number, duration: number): GTweener
        TweenScaleY(endValue: number, duration: number): GTweener
        TweenResize(endValue: Vector2, duration: number): GTweener
        TweenFade(endValue: number, duration: number): GTweener
        TweenRotate(endValue: number, duration: number): GTweener
        readonly id: string
        readonly relations: Relations
        readonly parent: GComponent
        readonly displayObject: DisplayObject
        static readonly draggingObject: GObject
        readonly onClick: EventListener
        readonly onRightClick: EventListener
        readonly onTouchBegin: EventListener
        readonly onTouchMove: EventListener
        readonly onTouchEnd: EventListener
        readonly onRollOver: EventListener
        readonly onRollOut: EventListener
        readonly onAddedToStage: EventListener
        readonly onRemovedFromStage: EventListener
        readonly onKeyDown: EventListener
        readonly onClickLink: EventListener
        readonly onPositionChanged: EventListener
        readonly onSizeChanged: EventListener
        readonly onDragStart: EventListener
        readonly onDragMove: EventListener
        readonly onDragEnd: EventListener
        readonly onGearStop: EventListener
        readonly onFocusIn: EventListener
        readonly onFocusOut: EventListener
        x: number
        y: number
        z: number
        xy: Vector2
        position: Vector3
        width: number
        height: number
        size: Vector2
        readonly actualWidth: number
        readonly actualHeight: number
        xMin: number
        yMin: number
        scaleX: number
        scaleY: number
        scale: Vector2
        skew: Vector2
        pivotX: number
        pivotY: number
        pivot: Vector2
        pivotAsAnchor: boolean
        touchable: boolean
        grayed: boolean
        enabled: boolean
        rotation: number
        rotationX: number
        rotationY: number
        alpha: number
        visible: boolean
        sortingOrder: number
        focusable: boolean
        tabStop: boolean
        readonly focused: boolean
        tooltips: string
        cursor: string
        filter: IFilter
        blendMode: BlendMode
        gameObjectName: string
        readonly inContainer: boolean
        readonly onStage: boolean
        readonly resourceURL: string
        readonly gearXY: GearXY
        readonly gearSize: GearSize
        readonly gearLook: GearLook
        group: GGroup
        readonly root: GRoot
        text: string
        icon: string
        draggable: boolean
        readonly dragging: boolean
        readonly isDisposed: boolean
        readonly asImage: GImage
        readonly asCom: GComponent
        readonly asButton: GButton
        readonly asLabel: GLabel
        readonly asProgress: GProgressBar
        readonly asSlider: GSlider
        readonly asComboBox: GComboBox
        readonly asTextField: GTextField
        readonly asRichTextField: GRichTextField
        readonly asTextInput: GTextInput
        readonly asLoader: GLoader
        readonly asLoader3D: GLoader3D
        readonly asList: GList
        readonly asGraph: GGraph
        readonly asGroup: GGroup
        readonly asMovieClip: GMovieClip
        readonly asTree: GTree
        readonly treeNode: GTreeNode
        name: string
        data: Object
        sourceWidth: number
        sourceHeight: number
        initWidth: number
        initHeight: number
        minWidth: number
        maxWidth: number
        minHeight: number
        maxHeight: number
        dragBounds: jsb.Nullable<Rect>
        packageItem: PackageItem
    }
}
declare module "FairyGUI" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { GameObject, Component, Renderer, Object as Object1, Rect, Material, Color } from "UnityEngine";
    class NGraphics extends Object {
        constructor(gameObject: GameObject)
        SetShaderAndTexture(shader: string, texture: NTexture): void
        SetMaterial(material: Material): void
        ToggleKeyword(keyword: string, enabled: boolean): void
        Tint(): void
        SetMeshDirty(): void
        UpdateMesh(): boolean
        Dispose(): void
        Update(context: any, alpha: number, grayed: boolean): void
        OnPopulateMesh(vb: any): void
        readonly gameObject: GameObject
        readonly meshFilter: any
        readonly meshRenderer: any
        readonly mesh: any
        meshFactory: any
        contentRect: Rect
        flip: FlipType
        texture: NTexture
        shader: string
        material: Material
        materialKeywords: Array<string>
        enabled: boolean
        sortingOrder: number
        color: Color
        vertexMatrix: any
        readonly materialPropertyBlock: any
        blendMode: BlendMode
        dontClip: boolean
        meshModifier(op: "add" | "remove", fn: () => void): void
    }
}
declare module "FairyGUI" {
    interface IFilter {
        Update(): void
        Dispose(): void
        target: DisplayObject
    }
}
declare module "FairyGUI" {
    interface IKeyboard {
        GetInput(): string
        Open(text: string, autocorrection: boolean, multiline: boolean, secure: boolean, alert: boolean, textPlaceholder: string, keyboardType: number, hideInput: boolean): void
        Close(): void
        readonly done: boolean
        readonly supportsCaret: boolean
    }
}
declare module "FairyGUI" {
    import * as jsb from "jsb";
    import { Color, Vector2 } from "UnityEngine";
    import { Array } from "System";
    import { IList } from "System.Collections.Generic";
    import { ByteBuffer } from "FairyGUI.Utils";
    class GGraph extends GObject {
        constructor()
        ReplaceMe(target: GObject): void
        AddBeforeMe(target: GObject): void
        AddAfterMe(target: GObject): void
        SetNativeObject(obj: DisplayObject): void
        DrawRect(aWidth: number, aHeight: number, lineSize: number, lineColor: Color, fillColor: Color): void
        DrawRoundRect(aWidth: number, aHeight: number, fillColor: Color, corner: Array<number>): void
        DrawEllipse(aWidth: number, aHeight: number, fillColor: Color): void
        DrawPolygon(aWidth: number, aHeight: number, points: any, fillColor: Color, lineSize: number, lineColor: Color): void
        DrawPolygon(aWidth: number, aHeight: number, points: any, fillColor: Color): void
        Setup_BeforeAdd(buffer: ByteBuffer, beginPos: number): void
        color: Color
        readonly shape: Shape
    }
}
declare module "FairyGUI" {
    import * as jsb from "jsb";
    import { Color, Color32, Vector2 } from "UnityEngine";
    import { Array } from "System";
    import { IList } from "System.Collections.Generic";
    class Shape extends DisplayObject {
        constructor()
        DrawRect(lineSize: number, lineColor: Color, fillColor: Color): void
        DrawRect(lineSize: number, colors: Array<Color32>): void
        DrawRoundRect(lineSize: number, lineColor: Color, fillColor: Color, topLeftRadius: number, topRightRadius: number, bottomLeftRadius: number, bottomRightRadius: number): void
        DrawEllipse(lineSize: number, centerColor: Color, lineColor: Color, fillColor: Color, startDegree: number, endDegree: number): void
        DrawEllipse(fillColor: Color): void
        DrawPolygon(points: any, fillColor: Color, lineSize: number, lineColor: Color): void
        DrawPolygon(points: any, fillColor: Color): void
        DrawPolygon(points: any, colors: Array<Color32>): void
        DrawRegularPolygon(sides: number, lineSize: number, centerColor: Color, lineColor: Color, fillColor: Color, rotation: number, distances: Array<number>): void
        Clear(): void
        color: Color
        readonly isEmpty: boolean
    }
}
declare module "FairyGUI" {
    import { ByteBuffer } from "FairyGUI.Utils";
    class GGroup extends GObject {
        constructor()
        SetBoundsChangedFlag(positionChangedOnly: boolean): void
        EnsureBoundsCorrect(): void
        Setup_BeforeAdd(buffer: ByteBuffer, beginPos: number): void
        Setup_AfterAdd(buffer: ByteBuffer, beginPos: number): void
        layout: GroupLayoutType
        lineGap: number
        columnGap: number
        excludeInvisibles: boolean
        autoSizeDisabled: boolean
        mainGridMinSize: number
        mainGridIndex: number
    }
}
declare module "FairyGUI" {
    import { Color, Material } from "UnityEngine";
    import { ByteBuffer } from "FairyGUI.Utils";
    class GImage extends GObject {
        constructor()
        ConstructFromResource(): void
        Setup_BeforeAdd(buffer: ByteBuffer, beginPos: number): void
        color: Color
        flip: FlipType
        fillMethod: FillMethod
        fillOrigin: number
        fillClockwise: boolean
        fillAmount: number
        texture: NTexture
        material: Material
        shader: string
    }
}
declare module "FairyGUI" {
    import { Material, Color } from "UnityEngine";
    import { ByteBuffer } from "FairyGUI.Utils";
    class GLoader extends GObject {
        constructor()
        Dispose(): void
        Advance(time: number): void
        Setup_BeforeAdd(buffer: ByteBuffer, beginPos: number): void
        url: string
        icon: string
        align: AlignType
        verticalAlign: VertAlignType
        fill: FillType
        shrinkOnly: boolean
        autoSize: boolean
        playing: boolean
        frame: number
        timeScale: number
        ignoreEngineTimeScale: boolean
        material: Material
        shader: string
        color: Color
        fillMethod: FillMethod
        fillOrigin: number
        fillClockwise: boolean
        fillAmount: number
        readonly image: Image
        readonly movieClip: MovieClip
        readonly component: GComponent
        texture: NTexture
        filter: IFilter
        blendMode: BlendMode
        showErrorSign: boolean
    }
}
declare module "FairyGUI" {
    import { Color, Material } from "UnityEngine";
    import { ByteBuffer } from "FairyGUI.Utils";
    class GMovieClip extends GObject {
        constructor()
        Rewind(): void
        SyncStatus(anotherMc: GMovieClip): void
        Advance(time: number): void
        SetPlaySettings(start: number, end: number, times: number, endAt: number): void
        ConstructFromResource(): void
        Setup_BeforeAdd(buffer: ByteBuffer, beginPos: number): void
        readonly onPlayEnd: EventListener
        playing: boolean
        frame: number
        color: Color
        flip: FlipType
        material: Material
        shader: string
        timeScale: number
        ignoreEngineTimeScale: boolean
    }
}
declare module "FairyGUI.Utils" {
    import { Object, ValueType } from "System";
    import { List } from "System.Collections.Generic";
    class XMLList extends Object {
        constructor(list: any)
        constructor()
        $GetValue(index: number): XML
        Add(xml: XML): void
        Clear(): void
        GetEnumerator(selector: string): any
        GetEnumerator(): any
        Filter(selector: string): XMLList
        Find(selector: string): XML
        RemoveAll(selector: string): void
        readonly Count: number
        rawList: any
    }
}
declare module "FairyGUI" {
    import * as jsb from "jsb";
    import { Vector2, Color, Rect } from "UnityEngine";
    import { ValueType, Object } from "System";
    class Image extends DisplayObject {
        constructor(texture: NTexture)
        constructor()
        SetNativeSize(): void
        OnPopulateMesh(vb: any): void
        SliceFill(vb: any): void
        texture: NTexture
        textureScale: Vector2
        color: Color
        fillMethod: FillMethod
        fillOrigin: number
        fillClockwise: boolean
        fillAmount: number
        scale9Grid: jsb.Nullable<Rect>
        scaleByTile: boolean
        tileGridIndice: number
    }
}
declare module "FairyGUI" {
    import { Enum } from "System";
    enum BlendMode {
        Normal = 0,
        None = 1,
        Add = 2,
        Multiply = 3,
        Screen = 4,
        Erase = 5,
        Mask = 6,
        Below = 7,
        Off = 8,
        One_OneMinusSrcAlpha = 9,
        Custom1 = 10,
        Custom2 = 11,
        Custom3 = 12,
    }
}
declare module "FairyGUI" {
    import { Object } from "System";
    import { ByteBuffer } from "FairyGUI.Utils";
    class GearXY extends Object {
        constructor(owner: GObject)
        AddExtStatus(pageId: string, buffer: ByteBuffer): void
        Apply(): void
        OnTweenStart(tweener: GTweener): void
        OnTweenUpdate(tweener: GTweener): void
        OnTweenComplete(tweener: GTweener): void
        UpdateState(): void
        UpdateFromRelations(dx: number, dy: number): void
        positionsInPercent: boolean
    }
}
declare module "FairyGUI" {
    import { Object } from "System";
    class GearLook extends Object {
        constructor(owner: GObject)
        Apply(): void
        OnTweenStart(tweener: GTweener): void
        OnTweenUpdate(tweener: GTweener): void
        OnTweenComplete(tweener: GTweener): void
        UpdateState(): void
    }
}
declare module "FairyGUI" {
    import { Object } from "System";
    class GearSize extends Object {
        constructor(owner: GObject)
        Apply(): void
        OnTweenStart(tweener: GTweener): void
        OnTweenUpdate(tweener: GTweener): void
        OnTweenComplete(tweener: GTweener): void
        UpdateState(): void
        UpdateFromRelations(dx: number, dy: number): void
    }
}
declare module "FairyGUI" {
    import { Material, Color, GameObject } from "UnityEngine";
    import { ByteBuffer } from "FairyGUI.Utils";
    class GLoader3D extends GObject {
        constructor()
        Dispose(): void
        Advance(time: number): void
        SetWrapTarget(gameObject: GameObject, cloneMaterial: boolean, width: number, height: number): void
        Setup_BeforeAdd(buffer: ByteBuffer, beginPos: number): void
        url: string
        icon: string
        align: AlignType
        verticalAlign: VertAlignType
        fill: FillType
        shrinkOnly: boolean
        autoSize: boolean
        playing: boolean
        frame: number
        timeScale: number
        ignoreEngineTimeScale: boolean
        loop: boolean
        animationName: string
        skinName: string
        material: Material
        shader: string
        color: Color
        readonly wrapTarget: GameObject
        filter: IFilter
        blendMode: BlendMode
    }
}
declare module "FairyGUI" {
    import { List } from "System.Collections.Generic";
    import { ByteBuffer } from "FairyGUI.Utils";
    class GTree extends GList {
        constructor()
        GetSelectedNode(): GTreeNode
        GetSelectedNodes(result: List<GTreeNode>): List<GTreeNode>
        GetSelectedNodes(): List<GTreeNode>
        SelectNode(node: GTreeNode, scrollItToView: boolean): void
        SelectNode(node: GTreeNode): void
        UnselectNode(node: GTreeNode): void
        ExpandAll(folderNode: GTreeNode): void
        ExpandAll(): void
        CollapseAll(folderNode: GTreeNode): void
        CollapseAll(): void
        Setup_BeforeAdd(buffer: ByteBuffer, beginPos: number): void
        readonly rootNode: GTreeNode
        indent: number
        clickToExpand: number
        treeNodeRender(op: "get"): (node: GTreeNode, obj: GComponent) => void
        treeNodeRender(op: "add" | "remove" | "set", fn?: (node: GTreeNode, obj: GComponent) => void): void
        treeNodeRender(op: "add" | "remove" | "set" | "get", fn?: (node: GTreeNode, obj: GComponent) => void): (node: GTreeNode, obj: GComponent) => void | void
        treeNodeWillExpand(op: "get"): (node: GTreeNode, expand: boolean) => void
        treeNodeWillExpand(op: "add" | "remove" | "set", fn?: (node: GTreeNode, expand: boolean) => void): void
        treeNodeWillExpand(op: "add" | "remove" | "set" | "get", fn?: (node: GTreeNode, expand: boolean) => void): (node: GTreeNode, expand: boolean) => void | void
    }
}
declare module "FairyGUI" {
    import { Object } from "System";
    class GTreeNode extends Object {
        constructor(hasChild: boolean, resURL: string)
        constructor(hasChild: boolean)
        ExpandToRoot(): void
        AddChild(child: GTreeNode): GTreeNode
        AddChildAt(child: GTreeNode, index: number): GTreeNode
        RemoveChild(child: GTreeNode): GTreeNode
        RemoveChildAt(index: number): GTreeNode
        RemoveChildren(beginIndex: number, endIndex: number): void
        GetChildAt(index: number): GTreeNode
        GetChildIndex(child: GTreeNode): number
        GetPrevSibling(): GTreeNode
        GetNextSibling(): GTreeNode
        SetChildIndex(child: GTreeNode, index: number): void
        SwapChildren(child1: GTreeNode, child2: GTreeNode): void
        SwapChildrenAt(index1: number, index2: number): void
        readonly parent: GTreeNode
        readonly tree: GTree
        readonly cell: GComponent
        readonly level: number
        expanded: boolean
        readonly isFolder: boolean
        text: string
        icon: string
        readonly numChildren: number
        data: Object
    }
}
declare module "FairyGUI" {
    import * as jsb from "jsb";
    import { Array } from "System";
    class MovieClip extends Image {
        constructor()
        Rewind(): void
        SyncStatus(anotherMc: MovieClip): void
        Advance(time: number): void
        SetPlaySettings(start: number, end: number, times: number, endAt: number): void
        SetPlaySettings(): void
        readonly onPlayEnd: EventListener
        frames: Array<MovieClip.Frame>
        playing: boolean
        frame: number
        interval: number
        swing: boolean
        repeatDelay: number
        timeScale: number
        ignoreEngineTimeScale: boolean
    }
}
declare module "FairyGUI" {
    import { Object } from "System";
    namespace MovieClip {
        class Frame extends Object {
            constructor()
            texture: NTexture
            addDelay: number
        }
    }
}
declare module "FairyGUI" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Color, Color32, Vector2 } from "UnityEngine";
    class TextFormat extends Object {
        constructor()
        SetColor(value: number): void
        EqualStyle(aFormat: TextFormat): boolean
        CopyFrom(source: TextFormat): void
        FillVertexColors(vertexColors: Array<Color32>): void
        size: number
        font: string
        color: Color
        lineSpacing: number
        letterSpacing: number
        bold: boolean
        underline: boolean
        italic: boolean
        strikethrough: boolean
        gradientColor: Array<Color32>
        align: AlignType
        specialStyle: TextFormat.SpecialStyle
        outline: number
        outlineColor: Color
        shadowOffset: Vector2
        shadowColor: Color
    }
}
declare module "FairyGUI" {
    import { Object } from "System";
    import { Color, Vector2 } from "UnityEngine";
    import { ByteBuffer } from "FairyGUI.Utils";
    class GTextField extends GObject {
        constructor()
        SetVar(name: string, value: string): GTextField
        FlushVars(): void
        HasCharacter(ch: string): boolean
        Setup_BeforeAdd(buffer: ByteBuffer, beginPos: number): void
        Setup_AfterAdd(buffer: ByteBuffer, beginPos: number): void
        text: string
        templateVars: any
        textFormat: TextFormat
        color: Color
        align: AlignType
        verticalAlign: VertAlignType
        singleLine: boolean
        stroke: number
        strokeColor: Color
        shadowOffset: Vector2
        UBBEnabled: boolean
        autoSize: AutoSizeType
        readonly textWidth: number
        readonly textHeight: number
    }
}
declare module "FairyGUI" {
    import { Object } from "System";
    class GRichTextField extends GTextField {
        constructor()
        readonly richTextField: any
        emojies: any
    }
}
declare module "FairyGUI" {
    import { Object } from "System";
    import { Color } from "UnityEngine";
    import { ByteBuffer } from "FairyGUI.Utils";
    class GTextInput extends GTextField {
        constructor()
        SetSelection(start: number, length: number): void
        ReplaceSelection(value: string): void
        Setup_BeforeAdd(buffer: ByteBuffer, beginPos: number): void
        readonly inputTextField: any
        readonly onChanged: EventListener
        readonly onSubmit: EventListener
        editable: boolean
        hideInput: boolean
        maxLength: number
        restrict: string
        displayAsPassword: boolean
        caretPosition: number
        promptText: string
        keyboardInput: boolean
        keyboardType: number
        disableIME: boolean
        emojies: any
        border: number
        corner: number
        borderColor: Color
        backgroundColor: Color
        mouseWheelEnabled: boolean
    }
}
declare module "FairyGUI" {
    import * as jsb from "jsb";
    import { List, IList } from "System.Collections.Generic";
    import { Object, Array } from "System";
    import { Vector2 } from "UnityEngine";
    import { XML, ByteBuffer } from "FairyGUI.Utils";
    class GComponent extends GObject {
        constructor()
        Dispose(): void
        InvalidateBatchingState(childChanged: boolean): void
        AddChild(child: GObject): GObject
        AddChildAt(child: GObject, index: number): GObject
        RemoveChild(child: GObject, dispose: boolean): GObject
        RemoveChild(child: GObject): GObject
        RemoveChildAt(index: number, dispose: boolean): GObject
        RemoveChildAt(index: number): GObject
        RemoveChildren(beginIndex: number, endIndex: number, dispose: boolean): void
        RemoveChildren(): void
        GetChildAt(index: number): GObject
        GetChild(name: string): GObject
        GetChildByPath(path: string): GObject
        GetVisibleChild(name: string): GObject
        GetChildInGroup(group: GGroup, name: string): GObject
        GetChildren(): Array<GObject>
        GetChildIndex(child: GObject): number
        SetChildIndex(child: GObject, index: number): void
        SetChildIndexBefore(child: GObject, index: number): number
        SwapChildren(child1: GObject, child2: GObject): void
        SwapChildrenAt(index1: number, index2: number): void
        IsAncestorOf(obj: GObject): boolean
        ChangeChildrenOrder(objs: IList<GObject>): void
        AddController(controller: Controller): void
        GetControllerAt(index: number): Controller
        GetController(name: string): Controller
        RemoveController(c: Controller): void
        GetTransitionAt(index: number): Transition
        GetTransition(name: string): Transition
        IsChildInView(child: GObject): boolean
        GetFirstChildInView(): number
        HandleControllerChanged(c: Controller): void
        SetBoundsChangedFlag(): void
        EnsureBoundsCorrect(): void
        ConstructFromResource(): void
        ConstructFromXML(xml: XML): void
        Setup_AfterAdd(buffer: ByteBuffer, beginPos: number): void
        InvalidateBatchingState()
        readonly rootContainer: Container
        readonly container: Container
        readonly scrollPane: ScrollPane
        readonly onDrop: EventListener
        fairyBatching: boolean
        opaque: boolean
        margin: Margin
        childrenRenderOrder: ChildrenRenderOrder
        apexIndex: number
        tabStopChildren: boolean
        readonly numChildren: number
        readonly Controllers: any
        clipSoftness: Vector2
        mask: DisplayObject
        reversedMask: boolean
        readonly baseUserData: string
        viewWidth: number
        viewHeight: number
    }
}
declare module "FairyGUI" {
    import { Vector2 } from "UnityEngine";
    import { List } from "System.Collections.Generic";
    import { ByteBuffer } from "FairyGUI.Utils";
    class GList extends GComponent {
        constructor()
        Dispose(): void
        GetFromPool(url: string): GObject
        AddItemFromPool(url: string): GObject
        AddItemFromPool(): GObject
        AddChildAt(child: GObject, index: number): GObject
        RemoveChildAt(index: number, dispose: boolean): GObject
        RemoveChildToPoolAt(index: number): void
        RemoveChildToPool(child: GObject): void
        RemoveChildrenToPool(beginIndex: number, endIndex: number): void
        RemoveChildrenToPool(): void
        GetSelection(result: List<number>): List<number>
        GetSelection(): List<number>
        AddSelection(index: number, scrollItToView: boolean): void
        RemoveSelection(index: number): void
        ClearSelection(): void
        SelectAll(): void
        SelectNone(): void
        SelectReverse(): void
        EnableSelectionFocusEvents(enabled: boolean): void
        EnableArrowKeyNavigation(enabled: boolean): void
        HandleArrowKey(dir: number): number
        ResizeToFit(itemCount: number, minSize: number): void
        ResizeToFit(itemCount: number): void
        ResizeToFit(): void
        HandleControllerChanged(c: Controller): void
        ScrollToView(index: number, ani: boolean, setFirst: boolean): void
        ScrollToView(index: number, ani: boolean): void
        ScrollToView(index: number): void
        GetFirstChildInView(): number
        ChildIndexToItemIndex(index: number): number
        ItemIndexToChildIndex(index: number): number
        SetVirtual(): void
        SetVirtualAndLoop(): void
        RefreshVirtualList(): void
        Setup_BeforeAdd(buffer: ByteBuffer, beginPos: number): void
        Setup_AfterAdd(buffer: ByteBuffer, beginPos: number): void
        RemoveChildAt(index: number): GObject
        readonly onClickItem: EventListener
        readonly onRightClickItem: EventListener
        layout: ListLayoutType
        lineCount: number
        columnCount: number
        lineGap: number
        columnGap: number
        align: AlignType
        verticalAlign: VertAlignType
        autoResizeItem: boolean
        defaultItemSize: Vector2
        readonly itemPool: GObjectPool
        selectedIndex: number
        selectionController: Controller
        readonly touchItem: GObject
        readonly isVirtual: boolean
        numItems: number
        defaultItem: string
        foldInvisibleItems: boolean
        selectionMode: ListSelectionMode
        scrollItemToViewOnClick: boolean
        itemRenderer(op: "get"): (index: number, item: GObject) => void
        itemRenderer(op: "add" | "remove" | "set", fn?: (index: number, item: GObject) => void): void
        itemRenderer(op: "add" | "remove" | "set" | "get", fn?: (index: number, item: GObject) => void): (index: number, item: GObject) => void | void
        itemProvider(op: "get"): (index: number) => string
        itemProvider(op: "add" | "remove" | "set", fn?: (index: number) => string): void
        itemProvider(op: "add" | "remove" | "set" | "get", fn?: (index: number) => string): (index: number) => string | void
    }
}
declare module "FairyGUI" {
    import { Vector2, AudioClip } from "UnityEngine";
    class GRoot extends GComponent {
        constructor()
        Dispose(): void
        SetContentScaleFactor(designResolutionX: number, designResolutionY: number, screenMatchMode: UIContentScaler.ScreenMatchMode): void
        SetContentScaleFactor(designResolutionX: number, designResolutionY: number): void
        SetContentScaleFactor(constantScaleFactor: number): void
        ApplyContentScaleFactor(): void
        ShowWindow(win: Window): void
        HideWindow(win: Window): void
        HideWindowImmediately(win: Window, dispose: boolean): void
        HideWindowImmediately(win: Window): void
        BringToFront(win: Window): void
        ShowModalWait(): void
        CloseModalWait(): void
        CloseAllExceptModals(): void
        CloseAllWindows(): void
        GetTopWindow(): Window
        DisplayObjectToGObject(obj: DisplayObject): GObject
        ShowPopup(popup: GObject, target: GObject, dir: PopupDirection, closeUntilUpEvent: boolean): void
        ShowPopup(popup: GObject, target: GObject, dir: PopupDirection): void
        ShowPopup(popup: GObject, target: GObject): void
        ShowPopup(popup: GObject): void
        GetPoupPosition(popup: GObject, target: GObject, dir: PopupDirection): Vector2
        TogglePopup(popup: GObject, target: GObject, dir: PopupDirection, closeUntilUpEvent: boolean): void
        TogglePopup(popup: GObject, target: GObject, dir: PopupDirection): void
        TogglePopup(popup: GObject, target: GObject): void
        TogglePopup(popup: GObject): void
        HidePopup(popup: GObject): void
        HidePopup(): void
        ShowTooltips(msg: string, delay: number): void
        ShowTooltips(msg: string): void
        ShowTooltipsWin(tooltipWin: GObject, delay: number): void
        ShowTooltipsWin(tooltipWin: GObject): void
        HideTooltips(): void
        EnableSound(): void
        DisableSound(): void
        PlayOneShotSound(clip: AudioClip, volumeScale: number): void
        PlayOneShotSound(clip: AudioClip): void
        static readonly contentScaleFactor: number
        static readonly contentScaleLevel: number
        static readonly inst: GRoot
        readonly modalLayer: GGraph
        readonly hasModalWindow: boolean
        readonly modalWaiting: boolean
        readonly touchTarget: GObject
        readonly hasAnyPopup: boolean
        focus: GObject
        soundVolume: number
    }
}
declare module "FairyGUI" {
    import { Color } from "UnityEngine";
    import { ByteBuffer } from "FairyGUI.Utils";
    class GLabel extends GComponent {
        constructor()
        GetTextField(): GTextField
        Setup_AfterAdd(buffer: ByteBuffer, beginPos: number): void
        icon: string
        title: string
        text: string
        editable: boolean
        titleColor: Color
        titleFontSize: number
        color: Color
    }
}
declare module "FairyGUI" {
    import { Color } from "UnityEngine";
    import { ByteBuffer } from "FairyGUI.Utils";
    class GButton extends GComponent {
        constructor()
        FireClick(downEffect: boolean, clickCall: boolean): void
        GetTextField(): GTextField
        HandleControllerChanged(c: Controller): void
        Setup_AfterAdd(buffer: ByteBuffer, beginPos: number): void
        readonly onChanged: EventListener
        icon: string
        title: string
        text: string
        selectedIcon: string
        selectedTitle: string
        titleColor: Color
        color: Color
        titleFontSize: number
        selected: boolean
        mode: ButtonMode
        relatedController: Controller
        relatedPageId: string
        sound: NAudioClip
        soundVolumeScale: number
        changeStateOnClick: boolean
        linkedPopup: GObject
        static readonly UP: string
        static readonly DOWN: string
        static readonly OVER: string
        static readonly SELECTED_OVER: string
        static readonly DISABLED: string
        static readonly SELECTED_DISABLED: string
    }
}
declare module "FairyGUI" {
    import * as jsb from "jsb";
    import { Color } from "UnityEngine";
    import { Array } from "System";
    import { List } from "System.Collections.Generic";
    import { ByteBuffer } from "FairyGUI.Utils";
    class GComboBox extends GComponent {
        constructor()
        ApplyListChange(): void
        GetTextField(): GTextField
        HandleControllerChanged(c: Controller): void
        Dispose(): void
        Setup_AfterAdd(buffer: ByteBuffer, beginPos: number): void
        UpdateDropdownList(): void
        readonly onChanged: EventListener
        icon: string
        title: string
        text: string
        titleColor: Color
        titleFontSize: number
        items: Array<string>
        icons: Array<string>
        values: Array<string>
        readonly itemList: List<string>
        readonly valueList: List<string>
        readonly iconList: List<string>
        selectedIndex: number
        selectionController: Controller
        value: string
        popupDirection: PopupDirection
        visibleItemCount: number
        dropdown: GComponent
    }
}
declare module "FairyGUI" {
    import { ByteBuffer } from "FairyGUI.Utils";
    class GProgressBar extends GComponent {
        constructor()
        TweenValue(value: number, duration: number): GTweener
        Update(newValue: number): void
        Setup_AfterAdd(buffer: ByteBuffer, beginPos: number): void
        titleType: ProgressTitleType
        min: number
        max: number
        value: number
        reverse: boolean
    }
}
declare module "FairyGUI" {
    import { ByteBuffer } from "FairyGUI.Utils";
    class GSlider extends GComponent {
        constructor()
        Setup_AfterAdd(buffer: ByteBuffer, beginPos: number): void
        readonly onChanged: EventListener
        readonly onGripTouchEnd: EventListener
        titleType: ProgressTitleType
        min: number
        max: number
        value: number
        wholeNumbers: boolean
        changeOnClick: boolean
        canDrag: boolean
    }
}
declare module "FairyGUI" {
    class PopupMenu extends EventDispatcher {
        constructor(resourceURL: string)
        constructor()
        AddItem(caption: string, callback: () => void): GButton
        AddItem(caption: string, callback: (context: EventContext) => void): GButton
        AddItemAt(caption: string, index: number, callback: (context: EventContext) => void): GButton
        AddItemAt(caption: string, index: number, callback: () => void): GButton
        AddSeperator(index: number): void
        AddSeperator(): void
        GetItemName(index: number): string
        SetItemText(name: string, caption: string): void
        SetItemVisible(name: string, visible: boolean): void
        SetItemGrayed(name: string, grayed: boolean): void
        SetItemCheckable(name: string, checkable: boolean): void
        SetItemChecked(name: string, check: boolean): void
        IsItemChecked(name: string): boolean
        RemoveItem(name: string): void
        ClearItems(): void
        Dispose(): void
        Show(target: GObject, dir: PopupDirection, parentMenu: PopupMenu): void
        Show(target: GObject, dir: PopupDirection): void
        Show(target: GObject): void
        Show(): void
        Hide(): void
        readonly onPopup: EventListener
        readonly onClose: EventListener
        readonly itemCount: number
        readonly contentPane: GComponent
        readonly list: GList
        visibleItemCount: number
        hideOnClickItem: boolean
        autoSize: boolean
    }
}
declare module "FairyGUI" {
    import { ByteBuffer } from "FairyGUI.Utils";
    import { Rect } from "UnityEngine";
    class ScrollPane extends EventDispatcher {
        constructor(owner: GComponent)
        Setup(buffer: ByteBuffer): void
        Dispose(): void
        SetPercX(value: number, ani: boolean): void
        SetPercY(value: number, ani: boolean): void
        SetPosX(value: number, ani: boolean): void
        SetPosY(value: number, ani: boolean): void
        SetCurrentPageX(value: number, ani: boolean): void
        SetCurrentPageY(value: number, ani: boolean): void
        ScrollTop(ani: boolean): void
        ScrollTop(): void
        ScrollBottom(ani: boolean): void
        ScrollBottom(): void
        ScrollUp(ratio: number, ani: boolean): void
        ScrollUp(): void
        ScrollDown(ratio: number, ani: boolean): void
        ScrollDown(): void
        ScrollLeft(ratio: number, ani: boolean): void
        ScrollLeft(): void
        ScrollRight(ratio: number, ani: boolean): void
        ScrollRight(): void
        ScrollToView(obj: GObject, ani: boolean, setFirst: boolean): void
        ScrollToView(rect: Rect, ani: boolean, setFirst: boolean): void
        ScrollToView(obj: GObject, ani: boolean): void
        ScrollToView(obj: GObject): void
        IsChildInView(obj: GObject): boolean
        CancelDragging(): void
        LockHeader(size: number): void
        LockFooter(size: number): void
        UpdateScrollBarVisible(): void
        static readonly draggingPane: ScrollPane
        readonly onScroll: EventListener
        readonly onScrollEnd: EventListener
        readonly onPullDownRelease: EventListener
        readonly onPullUpRelease: EventListener
        readonly owner: GComponent
        readonly hzScrollBar: GScrollBar
        readonly vtScrollBar: GScrollBar
        readonly header: GComponent
        readonly footer: GComponent
        bouncebackEffect: boolean
        touchEffect: boolean
        inertiaDisabled: boolean
        softnessOnTopOrLeftSide: boolean
        scrollStep: number
        snapToItem: boolean
        pageMode: boolean
        pageController: Controller
        mouseWheelEnabled: boolean
        decelerationRate: number
        readonly isDragged: boolean
        percX: number
        percY: number
        posX: number
        posY: number
        readonly isBottomMost: boolean
        readonly isRightMost: boolean
        currentPageX: number
        currentPageY: number
        readonly scrollingPosX: number
        readonly scrollingPosY: number
        readonly contentWidth: number
        readonly contentHeight: number
        viewWidth: number
        viewHeight: number
        static TWEEN_TIME_GO: number
        static TWEEN_TIME_DEFAULT: number
        static PULL_RATIO: number
    }
}
declare module "FairyGUI" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { ByteBuffer } from "FairyGUI.Utils";
    class Transition extends Object {
        constructor(owner: GComponent)
        Play(times: number, delay: number, startTime: number, endTime: number, onComplete: () => void): void
        Play(times: number, delay: number, onComplete: () => void): void
        Play(onComplete: () => void): void
        Play(): void
        PlayReverse(times: number, delay: number, onComplete: () => void): void
        PlayReverse(onComplete: () => void): void
        PlayReverse(): void
        ChangePlayTimes(value: number): void
        SetAutoPlay(autoPlay: boolean, times: number, delay: number): void
        Stop(setToComplete: boolean, processCallback: boolean): void
        Stop(): void
        SetPaused(paused: boolean): void
        Dispose(): void
        SetValue(label: string, ...aParams: Object[]): void
        SetHook(label: string, callback: () => void): void
        ClearHooks(): void
        SetTarget(label: string, newTarget: GObject): void
        SetDuration(label: string, value: number): void
        GetLabelTime(label: string): number
        OnTweenStart(tweener: GTweener): void
        OnTweenUpdate(tweener: GTweener): void
        OnTweenComplete(tweener: GTweener): void
        Setup(buffer: ByteBuffer): void
        readonly name: string
        readonly playing: boolean
        timeScale: number
        ignoreEngineTimeScale: boolean
        invalidateBatchingEveryFrame: boolean
    }
}
declare module "FairyGUI" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { AssetBundle } from "UnityEngine";
    import { List } from "System.Collections.Generic";
    import { XML } from "FairyGUI.Utils";
    class UIPackage extends Object {
        constructor()
        LoadAllAssets(): void
        UnloadAssets(): void
        ReloadAssets(resBundle: AssetBundle): void
        ReloadAssets(): void
        CreateObject(resName: string, userClass: any): GObject
        CreateObject(resName: string): GObject
        CreateObjectAsync(resName: string, callback: (result: GObject) => void): void
        GetItemAsset(resName: string): Object
        GetItemAsset(item: PackageItem): Object
        GetItems(): List<PackageItem>
        GetItem(itemId: string): PackageItem
        GetItemByName(itemName: string): PackageItem
        SetItemAsset(item: PackageItem, asset: Object, destroyMethod: DestroyMethod): void
        static GetVar(key: string): string
        static SetVar(key: string, value: string): void
        static GetById(id: string): UIPackage
        static GetByName(name: string): UIPackage
        static AddPackage(desc: AssetBundle, res: AssetBundle, mainAssetName: string): UIPackage
        static AddPackage(descData: Array<jsb.byte>, assetNamePrefix: string, loadFunc: (name: string, extension: string, type: any, destroyMethod: jsb.Out<DestroyMethod>) => Object): UIPackage
        static AddPackage(descData: Array<jsb.byte>, assetNamePrefix: string, loadFunc: (name: string, extension: string, type: any, item: PackageItem) => void): UIPackage
        static AddPackage(desc: AssetBundle, res: AssetBundle): UIPackage
        static AddPackage(assetPath: string, loadFunc: (name: string, extension: string, type: any, destroyMethod: jsb.Out<DestroyMethod>) => Object): UIPackage
        static AddPackage(bundle: AssetBundle): UIPackage
        static AddPackage(descFilePath: string): UIPackage
        static RemovePackage(packageIdOrName: string): void
        static RemoveAllPackages(): void
        static GetPackages(): List<UIPackage>
        static CreateObject(pkgName: string, resName: string, userClass: any): GObject
        static CreateObject(pkgName: string, resName: string): GObject
        static CreateObjectFromURL(url: string, userClass: any): GObject
        static CreateObjectFromURL(url: string, callback: (result: GObject) => void): void
        static CreateObjectFromURL(url: string): GObject
        static CreateObjectAsync(pkgName: string, resName: string, callback: (result: GObject) => void): void
        static GetItemAsset(pkgName: string, resName: string): Object
        static GetItemAssetByURL(url: string): Object
        static GetItemURL(pkgName: string, resName: string): string
        static GetItemByURL(url: string): PackageItem
        static NormalizeURL(url: string): string
        static SetStringsSource(source: XML): void
        readonly id: string
        readonly name: string
        static branch: string
        readonly assetPath: string
        customId: string
        readonly resBundle: AssetBundle
        readonly dependencies: Array<any>
        static unloadBundleByFGUI: boolean
        static readonly URL_PREFIX: string
        static onReleaseResource(op: "add" | "remove", fn: (obj: PackageItem) => void): void
    }
}
declare module "FairyGUI" {
    class Window extends GComponent {
        constructor()
        AddUISource(source: any): void
        Show(): void
        ShowOn(r: GRoot): void
        Hide(): void
        HideImmediately(): void
        CenterOn(r: GRoot, restraint: boolean): void
        ToggleStatus(): void
        BringToFront(): void
        ShowModalWait(requestingCmd: number): void
        ShowModalWait(): void
        CloseModalWait(requestingCmd: number): boolean
        CloseModalWait(): boolean
        Init(): void
        Dispose(): void
        contentPane: GComponent
        readonly frame: GComponent
        closeButton: GObject
        dragArea: GObject
        contentArea: GObject
        readonly modalWaitingPane: GObject
        readonly isShowing: boolean
        readonly isTop: boolean
        modal: boolean
        readonly modalWaiting: boolean
        bringToFontOnClick: boolean
    }
}
declare module "FairyGUI" {
    import { Object } from "System";
    import { Transform } from "UnityEngine";
    class GObjectPool extends Object {
        constructor(manager: Transform)
        Clear(): void
        GetObject(url: string): GObject
        ReturnObject(obj: GObject): void
        readonly count: number
        initCallback(op: "get"): (result: GObject) => void
        initCallback(op: "add" | "remove" | "set", fn?: (result: GObject) => void): void
        initCallback(op: "add" | "remove" | "set" | "get", fn?: (result: GObject) => void): (result: GObject) => void | void
    }
}
declare module "FairyGUI" {
    import { Object } from "System";
    import { ByteBuffer } from "FairyGUI.Utils";
    class Relations extends Object {
        constructor(owner: GObject)
        Add(target: GObject, relationType: RelationType, usePercent: boolean): void
        Add(target: GObject, relationType: RelationType): void
        Remove(target: GObject, relationType: RelationType): void
        Contains(target: GObject): boolean
        ClearFor(target: GObject): void
        ClearAll(): void
        CopyFrom(source: Relations): void
        Dispose(): void
        OnOwnerSizeChanged(dWidth: number, dHeight: number, applyPivot: boolean): void
        Setup(buffer: ByteBuffer, parentToChild: boolean): void
        readonly isEmpty: boolean
        handling: GObject
    }
}
declare module "FairyGUI" {
    import { Object } from "System";
    import { IEnumerator } from "System.Collections";
    class Timers extends Object {
        constructor()
        Add(interval: number, repeat: number, callback: (param: Object) => void, callbackParam: Object): void
        Add(interval: number, repeat: number, callback: (param: Object) => void): void
        CallLater(callback: (param: Object) => void, callbackParam: Object): void
        CallLater(callback: (param: Object) => void): void
        AddUpdate(callback: (param: Object) => void, callbackParam: Object): void
        AddUpdate(callback: (param: Object) => void): void
        StartCoroutine(routine: IEnumerator): void
        Exists(callback: (param: Object) => void): boolean
        Remove(callback: (param: Object) => void): void
        Update(): void
        static readonly inst: Timers
        static repeat: number
        static time: number
        static catchCallbackExceptions: boolean
    }
}
declare module "FairyGUI" {
    import { Object } from "System";
    import { Vector2, Vector3, Vector4, Color } from "UnityEngine";
    class GTween extends Object {
        constructor()
        static To(startValue: number, endValue: number, duration: number): GTweener
        static To(startValue: Vector2, endValue: Vector2, duration: number): GTweener
        static To(startValue: Vector3, endValue: Vector3, duration: number): GTweener
        static To(startValue: Vector4, endValue: Vector4, duration: number): GTweener
        static To(startValue: Color, endValue: Color, duration: number): GTweener
        static ToDouble(startValue: number, endValue: number, duration: number): GTweener
        static DelayedCall(delay: number): GTweener
        static Shake(startValue: Vector3, amplitude: number, duration: number): GTweener
        static IsTweening(target: Object, propType: TweenPropType): boolean
        static IsTweening(target: Object): boolean
        static Kill(target: Object, propType: TweenPropType, complete: boolean): void
        static Kill(target: Object, complete: boolean): void
        static Kill(target: Object): void
        static GetTween(target: Object, propType: TweenPropType): GTweener
        static GetTween(target: Object): GTweener
        static Clean(): void
        static catchCallbackExceptions: boolean
    }
}
declare module "FairyGUI" {
    import { Object } from "System";
    class GTweener extends Object {
        constructor()
        SetDelay(value: number): GTweener
        SetDuration(value: number): GTweener
        SetBreakpoint(value: number): GTweener
        SetEase(value: EaseType, customEase: CustomEase): GTweener
        SetEase(value: EaseType): GTweener
        SetEasePeriod(value: number): GTweener
        SetEaseOvershootOrAmplitude(value: number): GTweener
        SetRepeat(times: number, yoyo: boolean): GTweener
        SetTimeScale(value: number): GTweener
        SetIgnoreEngineTimeScale(value: boolean): GTweener
        SetSnapping(value: boolean): GTweener
        SetPath(value: GPath): GTweener
        SetTarget(value: Object, propType: TweenPropType): GTweener
        SetTarget(value: Object): GTweener
        SetUserData(value: Object): GTweener
        OnUpdate(callback: () => void): GTweener
        OnUpdate(callback: (tweener: GTweener) => void): GTweener
        OnStart(callback: () => void): GTweener
        OnStart(callback: (tweener: GTweener) => void): GTweener
        OnComplete(callback: () => void): GTweener
        OnComplete(callback: (tweener: GTweener) => void): GTweener
        SetListener(value: any): GTweener
        SetPaused(paused: boolean): GTweener
        Seek(time: number): void
        Kill(complete: boolean): void
        readonly delay: number
        readonly duration: number
        readonly repeat: number
        readonly target: Object
        readonly userData: Object
        readonly startValue: TweenValue
        readonly endValue: TweenValue
        readonly value: TweenValue
        readonly deltaValue: TweenValue
        readonly normalizedTime: number
        readonly completed: boolean
        readonly allCompleted: boolean
    }
}
declare module "FairyGUI" {
    import { Enum } from "System";
    enum EaseType {
        Linear = 0,
        SineIn = 1,
        SineOut = 2,
        SineInOut = 3,
        QuadIn = 4,
        QuadOut = 5,
        QuadInOut = 6,
        CubicIn = 7,
        CubicOut = 8,
        CubicInOut = 9,
        QuartIn = 10,
        QuartOut = 11,
        QuartInOut = 12,
        QuintIn = 13,
        QuintOut = 14,
        QuintInOut = 15,
        ExpoIn = 16,
        ExpoOut = 17,
        ExpoInOut = 18,
        CircIn = 19,
        CircOut = 20,
        CircInOut = 21,
        ElasticIn = 22,
        ElasticOut = 23,
        ElasticInOut = 24,
        BackIn = 25,
        BackOut = 26,
        BackInOut = 27,
        BounceIn = 28,
        BounceOut = 29,
        BounceInOut = 30,
        Custom = 31,
    }
}
declare module "FairyGUI" {
    import { Object } from "System";
    import { Vector2, Vector3, Vector4, Color } from "UnityEngine";
    class TweenValue extends Object {
        constructor()
        $GetValue(index: number): number
        $SetValue(index: number, value: number): void
        SetZero(): void
        vec2: Vector2
        vec3: Vector3
        vec4: Vector4
        color: Color
        x: number
        y: number
        z: number
        w: number
        d: number
    }
}
declare module "FairyGUI" {
    import * as jsb from "jsb";
    import { Object, Array, ValueType } from "System";
    import { ByteBuffer } from "FairyGUI.Utils";
    import { Rect, Vector2 } from "UnityEngine";
    class PackageItem extends Object {
        constructor()
        Load(): Object
        getBranch(): PackageItem
        getHighResolution(): PackageItem
        owner: UIPackage
        type: PackageItemType
        objectType: ObjectType
        id: string
        name: string
        width: number
        height: number
        file: string
        exported: boolean
        texture: NTexture
        rawData: ByteBuffer
        branches: Array<string>
        highResolution: Array<string>
        scale9Grid: jsb.Nullable<Rect>
        scaleByTile: boolean
        tileGridIndice: number
        pixelHitTestData: PixelHitTestData
        interval: number
        repeatDelay: number
        swing: boolean
        frames: Array<MovieClip.Frame>
        translated: boolean
        bitmapFont: BitmapFont
        audioClip: NAudioClip
        skeletonAnchor: Vector2
        skeletonAsset: Object
        extensionCreator(op: "get"): () => GComponent
        extensionCreator(op: "add" | "remove" | "set", fn?: () => GComponent): void
        extensionCreator(op: "add" | "remove" | "set" | "get", fn?: () => GComponent): () => GComponent | void
    }
}
declare module "FairyGUI" {
    import { Object } from "System";
    class UIObjectFactory extends Object {
        constructor()
        static SetPackageItemExtension(url: string, type: any): void
        static SetPackageItemExtension(url: string, creator: () => GComponent): void
        static SetLoaderExtension(type: any): void
        static SetLoaderExtension(creator: () => GLoader): void
        static Clear(): void
        static NewObject(pi: PackageItem, userClass: any): GObject
        static NewObject(type: ObjectType): GObject
    }
}
declare module "FairyGUI" {
    import { Object } from "System";
    import { Material } from "UnityEngine";
    import { IList } from "System.Collections.Generic";
    class MaterialManager extends Object {
        GetFlagsByKeywords(keywords: any): number
        GetMaterial(flags: number, blendMode: BlendMode, group: number): Material
        DestroyMaterials(): void
        RefreshMaterials(): void
        protected constructor()
        firstMaterialInFrame: boolean
        onCreateNewMaterial(op: "add" | "remove", fn: (obj: Material) => void): void
    }
}
declare module "FairyGUI" {
    import { ValueType } from "System";
    class Margin extends ValueType {
        constructor()
        left: number
        right: number
        top: number
        bottom: number
    }
}
declare module "FairyGUI.Utils" {
    import * as jsb from "jsb";
    import { Object, Array, ValueType } from "System";
    import { Color, Vector2 } from "UnityEngine";
    class XML extends Object {
        constructor(XmlString: string)
        HasAttribute(attrName: string): boolean
        GetAttribute(attrName: string, defValue: string): string
        GetAttribute(attrName: string): string
        GetAttributeInt(attrName: string, defValue: number): number
        GetAttributeInt(attrName: string): number
        GetAttributeFloat(attrName: string, defValue: number): number
        GetAttributeFloat(attrName: string): number
        GetAttributeBool(attrName: string, defValue: boolean): boolean
        GetAttributeBool(attrName: string): boolean
        GetAttributeArray(attrName: string, seperator: string): Array<string>
        GetAttributeArray(attrName: string): Array<string>
        GetAttributeColor(attrName: string, defValue: Color): Color
        GetAttributeVector(attrName: string): Vector2
        SetAttribute(attrName: string, attrValue: string): void
        SetAttribute(attrName: string, attrValue: boolean): void
        SetAttribute(attrName: string, attrValue: number): void
        SetAttribute(attrName: string, attrValue: number): void
        RemoveAttribute(attrName: string): void
        GetNode(selector: string): XML
        Elements(selector: string): XMLList
        Elements(): XMLList
        GetEnumerator(selector: string): any
        GetEnumerator(): any
        AppendChild(child: XML): void
        RemoveChild(child: XML): void
        RemoveChildren(selector: string): void
        Parse(aSource: string): void
        Reset(): void
        ToXMLString(includeHeader: boolean): string
        static Create(tag: string): XML
        readonly attributes: any
        readonly elements: XMLList
        name: string
        text: string
    }
}
declare module "FairyGUI" {
    import { Enum } from "System";
    namespace TextFormat {
        enum SpecialStyle {
            None = 0,
            Superscript = 1,
            Subscript = 2,
        }
    }
}
declare module "UnityEngine" {
    import { Enum } from "System";
    /** Determines how the audio clip is loaded in.
     */
    enum AudioClipLoadType {
        /** The audio data is decompressed when the audio clip is loaded.
         */
        DecompressOnLoad = 0,
        /** The audio data of the clip will be kept in memory in compressed form.
         */
        CompressedInMemory = 1,
        /** Streams audio data from disk.
         */
        Streaming = 2,
    }
}
declare module "UnityEngine" {
    import { Enum } from "System";
    /** Value describing the current load state of the audio data associated with an AudioClip.
     */
    enum AudioDataLoadState {
        /** Value returned by AudioClip.loadState for an AudioClip that has no audio data loaded and where loading has not been initiated yet.
         */
        Unloaded = 0,
        /** Value returned by AudioClip.loadState for an AudioClip that is currently loading audio data.
         */
        Loading = 1,
        /** Value returned by AudioClip.loadState for an AudioClip that has succeeded loading its audio data.
         */
        Loaded = 2,
        /** Value returned by AudioClip.loadState for an AudioClip that has failed loading its audio data.
         */
        Failed = 3,
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { IEnumerable } from "System.Collections.Generic";
    import { Array, Object as Object1, ValueType, Enum } from "System";
    /** AssetBundles let you stream additional assets via the UnityWebRequest class and instantiate them at runtime. AssetBundles are created via BuildPipeline.BuildAssetBundle.
     */
    class AssetBundle extends Object {
        /** Check if an AssetBundle contains a specific object.
         */
        Contains(name: string): boolean
        /** Loads asset with name of a given type from the bundle.
         */
        LoadAsset(name: string, type: any): Object
        /** Loads asset with name of type T from the bundle.
         */
        LoadAsset(name: string): Object
        /** Asynchronously loads asset with name of a given type from the bundle.
         */
        LoadAssetAsync(name: string, type: any): any
        /** Asynchronously loads asset with name of a given T from the bundle.
         */
        LoadAssetAsync(name: string): any
        /** Loads asset and sub assets with name of a given type from the bundle.
         */
        LoadAssetWithSubAssets(name: string, type: any): Array<Object>
        /** Loads asset and sub assets with name of type T from the bundle.
         */
        LoadAssetWithSubAssets(name: string): Array<Object>
        /** Loads asset with sub assets with name of a given type from the bundle asynchronously.
         */
        LoadAssetWithSubAssetsAsync(name: string, type: any): any
        /** Loads asset with sub assets with name of type T from the bundle asynchronously.
         */
        LoadAssetWithSubAssetsAsync(name: string): any
        /** Loads all assets contained in the asset bundle that inherit from type.
         */
        LoadAllAssets(type: any): Array<Object>
        LoadAllAssets(): Array<Object>
        /** Loads all assets contained in the asset bundle that inherit from type asynchronously.
         */
        LoadAllAssetsAsync(type: any): any
        LoadAllAssetsAsync(): any
        /** Unloads an AssetBundle freeing its data.
         * @param unloadAllLoadedObjects Determines whether the current instances of objects loaded from the AssetBundle will also be unloaded.
         */
        Unload(unloadAllLoadedObjects: boolean): void
        GetAllAssetNames(): Array<string>
        GetAllScenePaths(): Array<string>
        /** Unloads all currently loaded AssetBundles.
         * @param unloadAllObjects Determines whether the current instances of objects loaded from AssetBundles will also be unloaded.
         */
        static UnloadAllAssetBundles(unloadAllObjects: boolean): void
        static GetAllLoadedAssetBundles(): any
        /** Asynchronously loads an AssetBundle from a file on disk.
         * @param path Path of the file on disk.
         * @param crc An optional CRC-32 checksum of the uncompressed content. If this is non-zero, then the content will be compared against the checksum before loading it, and give an error if it does not match.
         * @param offset An optional byte offset. This value specifies where to start reading the AssetBundle from.
         * @returns Asynchronous create request for an AssetBundle. Use AssetBundleCreateRequest.assetBundle property to get an AssetBundle once it is loaded. 
         */
        static LoadFromFileAsync(path: string, crc: number, offset: number): any
        static LoadFromFileAsync(path: string, crc: number): any
        static LoadFromFileAsync(path: string): any
        /** Synchronously loads an AssetBundle from a file on disk.
         * @param path Path of the file on disk.
         * @param crc An optional CRC-32 checksum of the uncompressed content. If this is non-zero, then the content will be compared against the checksum before loading it, and give an error if it does not match.
         * @param offset An optional byte offset. This value specifies where to start reading the AssetBundle from.
         * @returns Loaded AssetBundle object or null if failed. 
         */
        static LoadFromFile(path: string, crc: number, offset: number): AssetBundle
        static LoadFromFile(path: string, crc: number): AssetBundle
        static LoadFromFile(path: string): AssetBundle
        /** Asynchronously create an AssetBundle from a memory region.
         * @param binary Array of bytes with the AssetBundle data.
         * @param crc An optional CRC-32 checksum of the uncompressed content. If this is non-zero, then the content will be compared against the checksum before loading it, and give an error if it does not match.
         * @returns Asynchronous create request for an AssetBundle. Use AssetBundleCreateRequest.assetBundle property to get an AssetBundle once it is loaded. 
         */
        static LoadFromMemoryAsync(binary: Array<jsb.byte>, crc: number): any
        static LoadFromMemoryAsync(binary: Array<jsb.byte>): any
        /** Synchronously create an AssetBundle from a memory region.
         * @param binary Array of bytes with the AssetBundle data.
         * @param crc An optional CRC-32 checksum of the uncompressed content. If this is non-zero, then the content will be compared against the checksum before loading it, and give an error if it does not match.
         * @returns Loaded AssetBundle object or null if failed. 
         */
        static LoadFromMemory(binary: Array<jsb.byte>, crc: number): AssetBundle
        static LoadFromMemory(binary: Array<jsb.byte>): AssetBundle
        /** Asynchronously loads an AssetBundle from a managed Stream.
         * @param stream The managed Stream object. Unity calls Read(), Seek() and the Length property on this object to load the AssetBundle data.
         * @param crc An optional CRC-32 checksum of the uncompressed content.
         * @param managedReadBufferSize You can use this to override the size of the read buffer Unity uses while loading data. The default size is 32KB.
         * @returns Asynchronous create request for an AssetBundle. Use AssetBundleCreateRequest.assetBundle property to get an AssetBundle once it is loaded. 
         */
        static LoadFromStreamAsync(stream: any, crc: number, managedReadBufferSize: number): any
        static LoadFromStreamAsync(stream: any, crc: number): any
        static LoadFromStreamAsync(stream: any): any
        /** Synchronously loads an AssetBundle from a managed Stream.
         * @param stream The managed Stream object. Unity calls Read(), Seek() and the Length property on this object to load the AssetBundle data.
         * @param crc An optional CRC-32 checksum of the uncompressed content.
         * @param managedReadBufferSize You can use this to override the size of the read buffer Unity uses while loading data. The default size is 32KB.
         * @returns The loaded AssetBundle object or null when the object fails to load. 
         */
        static LoadFromStream(stream: any, crc: number, managedReadBufferSize: number): AssetBundle
        static LoadFromStream(stream: any, crc: number): AssetBundle
        static LoadFromStream(stream: any): AssetBundle
        static SetAssetBundleDecryptKey(password: string): void
        /** Asynchronously recompress a downloaded/stored AssetBundle from one BuildCompression to another.
         * @param inputPath Path to the AssetBundle to recompress.
         * @param outputPath Path to the recompressed AssetBundle to be generated. Can be the same as inputPath.
         * @param method The compression method, level and blocksize to use during recompression. Only some BuildCompression types are supported (see note).
         * @param expectedCRC CRC of the AssetBundle to test against. Testing this requires additional file reading and computation. Pass in 0 to skip this check. Unity does not compute a CRC when the source and destination BuildCompression are the same, so no CRC verification takes place (see note).
         * @param priority The priority at which the recompression operation should run. This sets thread priority during the operation and does not effect the order in which operations are performed. Recompression operations run on a background worker thread.
         */
        static RecompressAssetBundleAsync(inputPath: string, outputPath: string, method: any, expectedCRC: number, priority: any): any
        protected constructor()
        /** Return true if the AssetBundle is a streamed Scene AssetBundle.
         */
        readonly isStreamedSceneAssetBundle: boolean
    }
}
declare module "UnityEngine" {
    import { Enum } from "System";
    /** Base class for texture handling.
     */
    class Texture extends Object {
        GetNativeTexturePtr(): any
        IncrementUpdateCount(): void
        /** Sets Anisotropic limits.
         */
        static SetGlobalAnisotropicFilteringLimits(forcedMin: number, globalMax: number): void
        static SetStreamingTextureMaterialDebugProperties(): void
        protected constructor()
        static masterTextureLimit: number
        /** How many mipmap levels are in this texture (Read Only).
         */
        readonly mipmapCount: number
        static anisotropicFiltering: any
        /** Returns the GraphicsFormat format or color format of a texture object.
         */
        readonly graphicsFormat: any
        /** Width of the texture in pixels. (Read Only)
         */
        width: number
        /** Height of the texture in pixels. (Read Only)
         */
        height: number
        /** Dimensionality (type) of the texture (Read Only).
         */
        dimension: any
        /** Returns true if the Read/Write Enabled checkbox was checked when the texture was imported; otherwise returns false. For a dynamic Texture created from script, always returns true. For additional information, see TextureImporter.isReadable.
         */
        readonly isReadable: boolean
        /** Texture coordinate wrapping mode.
         */
        wrapMode: any
        /** Texture U coordinate wrapping mode.
         */
        wrapModeU: any
        /** Texture V coordinate wrapping mode.
         */
        wrapModeV: any
        /** Texture W coordinate wrapping mode for Texture3D.
         */
        wrapModeW: any
        /** Filtering mode of the texture.
         */
        filterMode: any
        /** Anisotropic filtering level of the texture.
         */
        anisoLevel: number
        /** Mip map bias of the texture.
         */
        mipMapBias: number
        readonly texelSize: Vector2
        /** This counter is incremented when the texture is updated.
         */
        readonly updateCount: number
        /** The total amount of memory that would be used by all textures at mipmap level 0.
         */
        static readonly totalTextureMemory: number
        /** This amount of texture memory would be used before the texture streaming budget is applied.
         */
        static readonly desiredTextureMemory: number
        /** The amount of memory used by textures after the mipmap streaming and budget are applied and loading is complete.
         */
        static readonly targetTextureMemory: number
        /** The amount of memory currently being used by textures.
         */
        static readonly currentTextureMemory: number
        /** Total amount of memory being used by non-streaming textures.
         */
        static readonly nonStreamingTextureMemory: number
        /** How many times has a texture been uploaded due to texture mipmap streaming.
         */
        static readonly streamingMipmapUploadCount: number
        /** Number of renderers registered with the texture streaming system.
         */
        static readonly streamingRendererCount: number
        /** Number of streaming textures.
         */
        static readonly streamingTextureCount: number
        /** Number of non-streaming textures.
         */
        static readonly nonStreamingTextureCount: number
        /** Number of streaming textures with outstanding mipmaps to be loaded.
         */
        static readonly streamingTexturePendingLoadCount: number
        /** Number of streaming textures with mipmaps currently loading.
         */
        static readonly streamingTextureLoadingCount: number
        /** Force streaming textures to load all mipmap levels.
         */
        static streamingTextureForceLoadAll: boolean
        /** Force the streaming texture system to discard all unused mipmaps immediately, rather than caching them until the texture memory budget is exceeded.
         */
        static streamingTextureDiscardUnusedMips: boolean
        /** Allow texture creation to occur on any thread (rather than the dedicated render thread).
         */
        static allowThreadedTextureCreation: boolean
        /** Can be used with texture constructors that take a mip count to indicate that all mips should be generated.  The value of this field is -1.
         */
        static readonly GenerateAllMips: number
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Enum, Array, Object as Object1 } from "System";
    import { List } from "System.Collections.Generic";
    /** Class that represents textures in C# code.
     */
    class Texture2D extends Texture {
        constructor(width: number, height: number, format: any, mipCount: number, flags: any)
        constructor(width: number, height: number, textureFormat: any, mipCount: number, linear: boolean)
        constructor(width: number, height: number, textureFormat: any, mipChain: boolean, linear: boolean)
        constructor(width: number, height: number, format: any, flags: any)
        constructor(width: number, height: number, format: any, flags: any)
        constructor(width: number, height: number, textureFormat: any, mipChain: boolean)
        constructor(width: number, height: number)
        /** Compress texture into DXT format.
         */
        Compress(highQuality: boolean): void
        ClearRequestedMipmapLevel(): void
        IsRequestedMipmapLevelLoaded(): boolean
        ClearMinimumMipmapLevel(): void
        /** Updates Unity texture to use different native texture object.
         * @param nativeTex Native 2D texture object.
         */
        UpdateExternalTexture(nativeTex: any): void
        GetRawTextureData(): Array<jsb.byte>
        /** Get a block of pixel colors.
         * @param x The x position of the pixel array to fetch.
         * @param y The y position of the pixel array to fetch.
         * @param blockWidth The width length of the pixel array to fetch.
         * @param blockHeight The height length of the pixel array to fetch.
         * @param miplevel The mipmap level to fetch the pixels. Defaults to zero, and is
        optional.
         * @returns The array of pixels in the texture that have been selected. 
         */
        GetPixels(x: number, y: number, blockWidth: number, blockHeight: number, miplevel: number): Array<Color>
        GetPixels(x: number, y: number, blockWidth: number, blockHeight: number): Array<Color>
        /** Get the pixel colors from the texture.
         * @param miplevel The mipmap level to fetch the pixels from. Defaults to zero.
         * @returns The array of all pixels in the mipmap level of the texture. 
         */
        GetPixels(miplevel: number): Array<Color>
        GetPixels(): Array<Color>
        /** Get a block of pixel colors in Color32 format.
         */
        GetPixels32(miplevel: number): Array<Color32>
        GetPixels32(): Array<Color32>
        /** Packs multiple Textures into a texture atlas.
         * @param textures Array of textures to pack into the atlas.
         * @param padding Padding in pixels between the packed textures.
         * @param maximumAtlasSize Maximum size of the resulting texture.
         * @param makeNoLongerReadable Should the texture be marked as no longer readable?
         * @returns An array of rectangles containing the UV coordinates in the atlas for each input texture, or null if packing fails. 
         */
        PackTextures(textures: Array<Texture2D>, padding: number, maximumAtlasSize: number, makeNoLongerReadable: boolean): Array<Rect>
        PackTextures(textures: Array<Texture2D>, padding: number, maximumAtlasSize: number): Array<Rect>
        PackTextures(textures: Array<Texture2D>, padding: number): Array<Rect>
        SetPixel(x: number, y: number, color: Color, mipLevel: number): void
        /** Sets pixel color at coordinates (x,y).
         */
        SetPixel(x: number, y: number, color: Color): void
        /** Set a block of pixel colors.
         */
        SetPixels(x: number, y: number, blockWidth: number, blockHeight: number, colors: Array<Color>, miplevel: number): void
        SetPixels(x: number, y: number, blockWidth: number, blockHeight: number, colors: Array<Color>): void
        /** Set a block of pixel colors.
         * @param colors The array of pixel colours to assign (a 2D image flattened to a 1D array).
         * @param miplevel The mip level of the texture to write to.
         */
        SetPixels(colors: Array<Color>, miplevel: number): void
        SetPixels(colors: Array<Color>): void
        GetPixel(x: number, y: number, mipLevel: number): Color
        /** Returns pixel color at coordinates (x, y).
         */
        GetPixel(x: number, y: number): Color
        GetPixelBilinear(u: number, v: number, mipLevel: number): Color
        /** Returns filtered pixel color at normalized coordinates (u, v).
         */
        GetPixelBilinear(u: number, v: number): Color
        /** Fills texture pixels with raw preformatted data.
         * @param data Raw data array to initialize texture pixels with.
         * @param size Size of data in bytes.
         */
        LoadRawTextureData(data: any, size: number): void
        /** Fills texture pixels with raw preformatted data.
         * @param data Raw data array to initialize texture pixels with.
         * @param size Size of data in bytes.
         */
        LoadRawTextureData(data: Array<jsb.byte>): void
        /** Actually apply all previous SetPixel and SetPixels changes.
         * @param updateMipmaps When set to true, mipmap levels are recalculated.
         * @param makeNoLongerReadable When set to true, system memory copy of a texture is released.
         */
        Apply(updateMipmaps: boolean, makeNoLongerReadable: boolean): void
        Apply(updateMipmaps: boolean): void
        Apply(): void
        /** Resizes the texture.
         */
        Resize(width: number, height: number, format: any, hasMipMap: boolean): boolean
        /** Resizes the texture.
         */
        Resize(width: number, height: number): boolean
        /** Read pixels from screen into the saved texture data.
         * @param source Rectangular region of the view to read from. Pixels are read from current render target.
         * @param destX Horizontal pixel position in the texture to place the pixels that are read.
         * @param destY Vertical pixel position in the texture to place the pixels that are read.
         * @param recalculateMipMaps Should the texture's mipmaps be recalculated after reading?
         */
        ReadPixels(source: Rect, destX: number, destY: number, recalculateMipMaps: boolean): void
        ReadPixels(source: Rect, destX: number, destY: number): void
        /** Set a block of pixel colors.
         */
        SetPixels32(x: number, y: number, blockWidth: number, blockHeight: number, colors: Array<Color32>, miplevel: number): void
        SetPixels32(x: number, y: number, blockWidth: number, blockHeight: number, colors: Array<Color32>): void
        /** Set a block of pixel colors.
         */
        SetPixels32(colors: Array<Color32>, miplevel: number): void
        SetPixels32(colors: Array<Color32>): void
        /** Encodes the specified texture in TGA format.
         * @param tex The texture to encode.
         */
        EncodeToTGA(): Array<jsb.byte>
        /** Encodes this texture into PNG format.
         * @param tex The texture to convert.
         */
        EncodeToPNG(): Array<jsb.byte>
        /** Encodes this texture into JPG format.
         * @param tex Text texture to convert.
         * @param quality JPG quality to encode with, 1..100 (default 75).
         */
        EncodeToJPG(quality: number): Array<jsb.byte>
        /** Encodes this texture into JPG format.
         * @param tex Text texture to convert.
         * @param quality JPG quality to encode with, 1..100 (default 75).
         */
        EncodeToJPG(): Array<jsb.byte>
        EncodeToEXR(flags: any): Array<jsb.byte>
        EncodeToEXR(): Array<jsb.byte>
        /** Loads PNG/JPG (or supported format) image byte array into a texture.
         * @param data The byte array containing the image data to load.
         * @param markNonReadable Set to false by default, pass true to optionally mark the texture as non-readable.
         * @param tex The texture to load the image into.
         * @returns Returns true if the data can be loaded, false otherwise. 
         */
        LoadImage(data: Array<jsb.byte>, markNonReadable: boolean): boolean
        LoadImage(data: Array<jsb.byte>): boolean
        /** Creates Unity Texture out of externally created native texture object.
         * @param nativeTex Native 2D texture object.
         * @param width Width of texture in pixels.
         * @param height Height of texture in pixels.
         * @param format Format of underlying texture object.
         * @param mipmap Does the texture have mipmaps?
         * @param linear Is texture using linear color space?
         */
        static CreateExternalTexture(width: number, height: number, format: any, mipChain: boolean, linear: boolean, nativeTex: any): Texture2D
        static GenerateAtlas(sizes: Array<Vector2>, padding: number, atlasSize: number, results: any): boolean
        /** The format of the pixel data in the texture (Read Only).
         */
        readonly format: any
        /** Gets a small Texture with all white pixels.
         */
        static readonly whiteTexture: Texture2D
        /** Gets a small Texture with all black pixels.
         */
        static readonly blackTexture: Texture2D
        /** Gets a small Texture with all red pixels.
         */
        static readonly redTexture: Texture2D
        /** Gets a small Texture with all gray pixels.
         */
        static readonly grayTexture: Texture2D
        /** Gets a small Texture with all gray pixels.
         */
        static readonly linearGrayTexture: Texture2D
        /** Gets a small Texture with pixels that represent surface normal vectors at a neutral position.
         */
        static readonly normalTexture: Texture2D
        /** Returns true if the Read/Write Enabled checkbox was checked when the texture was imported; otherwise returns false. For a dynamic Texture created from script, always returns true. For additional information, see TextureImporter.isReadable.
         */
        readonly isReadable: boolean
        /** Determines whether mipmap streaming is enabled for this Texture.
         */
        readonly streamingMipmaps: boolean
        /** Sets the relative priority for this Texture when reducing memory size to fit within the memory budget.
         */
        readonly streamingMipmapsPriority: number
        /** The mipmap level to load.
         */
        requestedMipmapLevel: number
        /** Restricts the mipmap streaming system to a minimum mip level for this Texture.
         */
        minimumMipmapLevel: number
        /** The mipmap level calculated by the streaming system, which takes into account the streaming Cameras and the location of the objects containing this Texture. This is unaffected by requestedMipmapLevel or minimumMipmapLevel.
         */
        readonly calculatedMipmapLevel: number
        /** The mipmap level that the streaming system would load before memory budgets are applied.
         */
        readonly desiredMipmapLevel: number
        /** The mipmap level that the mipmap streaming system is in the process of loading.
         */
        readonly loadingMipmapLevel: number
        /** The mipmap level that is currently loaded by the streaming system.
         */
        readonly loadedMipmapLevel: number
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Enum, Array, Object as Object1 } from "System";
    import { List } from "System.Collections.Generic";
    /** The material class.
     */
    class Material extends Object {
        constructor(shader: any)
        constructor(source: Material)
        /** Checks if material's shader has a property of a given name.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        HasProperty(nameID: number): boolean
        /** Checks if material's shader has a property of a given name.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        HasProperty(name: string): boolean
        /** Sets a shader keyword that is enabled by this material.
         */
        EnableKeyword(keyword: string): void
        /** Unset a shader keyword.
         */
        DisableKeyword(keyword: string): void
        /** Is the shader keyword enabled on this material?
         */
        IsKeywordEnabled(keyword: string): boolean
        /** Enables or disables a Shader pass on a per-Material level.
         * @param passName Shader pass name (case insensitive).
         * @param enabled Flag indicating whether this Shader pass should be enabled.
         */
        SetShaderPassEnabled(passName: string, enabled: boolean): void
        /** Checks whether a given Shader pass is enabled on this Material.
         * @param passName Shader pass name (case insensitive).
         * @returns True if the Shader pass is enabled. 
         */
        GetShaderPassEnabled(passName: string): boolean
        /** Returns the name of the shader pass at index pass.
         */
        GetPassName(pass: number): string
        /** Returns the index of the pass passName.
         */
        FindPass(passName: string): number
        /** Sets an override tag/value on the material.
         * @param tag Name of the tag to set.
         * @param val Name of the value to set. Empty string to clear the override flag.
         */
        SetOverrideTag(tag: string, val: string): void
        /** Get the value of material's shader tag.
         */
        GetTag(tag: string, searchFallbacks: boolean, defaultValue: string): string
        /** Get the value of material's shader tag.
         */
        GetTag(tag: string, searchFallbacks: boolean): string
        /** Interpolate properties between two materials.
         */
        Lerp(start: Material, end: Material, t: number): void
        /** Activate the given pass for rendering.
         * @param pass Shader pass number to setup.
         * @returns If false is returned, no rendering should be done. 
         */
        SetPass(pass: number): boolean
        /** Copy properties from other material into this material.
         */
        CopyPropertiesFromMaterial(mat: Material): void
        ComputeCRC(): number
        GetTexturePropertyNames(outNames: List<string>): void
        GetTexturePropertyNames(): Array<string>
        GetTexturePropertyNameIDs(outNames: List<number>): void
        GetTexturePropertyNameIDs(): Array<number>
        /** Sets a named float value.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param value Float value to set.
         * @param name Property name, e.g. "_Glossiness".
         */
        SetFloat(name: string, value: number): void
        /** Sets a named float value.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param value Float value to set.
         * @param name Property name, e.g. "_Glossiness".
         */
        SetFloat(nameID: number, value: number): void
        /** Sets a named integer value.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param value Integer value to set.
         * @param name Property name, e.g. "_SrcBlend".
         */
        SetInt(name: string, value: number): void
        /** Sets a named integer value.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param value Integer value to set.
         * @param name Property name, e.g. "_SrcBlend".
         */
        SetInt(nameID: number, value: number): void
        /** Sets a named color value.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, e.g. "_Color".
         * @param value Color value to set.
         */
        SetColor(name: string, value: Color): void
        /** Sets a named color value.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, e.g. "_Color".
         * @param value Color value to set.
         */
        SetColor(nameID: number, value: Color): void
        /** Sets a named vector value.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, e.g. "_WaveAndDistance".
         * @param value Vector value to set.
         */
        SetVector(name: string, value: Vector4): void
        /** Sets a named vector value.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, e.g. "_WaveAndDistance".
         * @param value Vector value to set.
         */
        SetVector(nameID: number, value: Vector4): void
        /** Sets a named matrix for the shader.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, e.g. "_CubemapRotation".
         * @param value Matrix value to set.
         */
        SetMatrix(name: string, value: Matrix4x4): void
        /** Sets a named matrix for the shader.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, e.g. "_CubemapRotation".
         * @param value Matrix value to set.
         */
        SetMatrix(nameID: number, value: Matrix4x4): void
        /** Sets a named texture.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, e.g. "_MainTex".
         * @param value Texture to set.
         * @param element Optional parameter that specifies the type of data from the render texture to set.
         */
        SetTexture(name: string, value: any, element: any): void
        /** Sets a named texture.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, e.g. "_MainTex".
         * @param value Texture to set.
         * @param element Optional parameter that specifies the type of data from the render texture to set.
         */
        SetTexture(nameID: number, value: any, element: any): void
        /** Sets a named texture.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, e.g. "_MainTex".
         * @param value Texture to set.
         * @param element Optional parameter that specifies the type of data from the render texture to set.
         */
        SetTexture(name: string, value: Texture): void
        /** Sets a named texture.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, e.g. "_MainTex".
         * @param value Texture to set.
         * @param element Optional parameter that specifies the type of data from the render texture to set.
         */
        SetTexture(nameID: number, value: Texture): void
        /** Sets a named ComputeBuffer value.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name.
         * @param value The ComputeBuffer value to set.
         */
        SetBuffer(name: string, value: any): void
        /** Sets a named ComputeBuffer value.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name.
         * @param value The ComputeBuffer value to set.
         */
        SetBuffer(nameID: number, value: any): void
        /** Sets a ComputeBuffer as a named constant buffer for the material.
         * @param name The name of the constant buffer to override.
         * @param value The ComputeBuffer to override the constant buffer values with, or null to remove binding.
         * @param offset Offset in bytes from the beginning of the ComputeBuffer to bind. Must be a multiple of SystemInfo.MinConstantBufferAlignment, or 0 if that value is 0.
         * @param size The number of bytes to bind.
         * @param nameID The shader property ID of the constant buffer to override.
         */
        SetConstantBuffer(name: string, value: any, offset: number, size: number): void
        /** Sets a ComputeBuffer as a named constant buffer for the material.
         * @param name The name of the constant buffer to override.
         * @param value The ComputeBuffer to override the constant buffer values with, or null to remove binding.
         * @param offset Offset in bytes from the beginning of the ComputeBuffer to bind. Must be a multiple of SystemInfo.MinConstantBufferAlignment, or 0 if that value is 0.
         * @param size The number of bytes to bind.
         * @param nameID The shader property ID of the constant buffer to override.
         */
        SetConstantBuffer(nameID: number, value: any, offset: number, size: number): void
        SetFloatArray(name: string, values: any): void
        SetFloatArray(nameID: number, values: any): void
        /** Sets a float array property.
         * @param name Property name.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param values Array of values to set.
         */
        SetFloatArray(name: string, values: Array<number>): void
        /** Sets a float array property.
         * @param name Property name.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param values Array of values to set.
         */
        SetFloatArray(nameID: number, values: Array<number>): void
        SetColorArray(name: string, values: any): void
        SetColorArray(nameID: number, values: any): void
        /** Sets a color array property.
         * @param name Property name.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param values Array of values to set.
         */
        SetColorArray(name: string, values: Array<Color>): void
        /** Sets a color array property.
         * @param name Property name.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param values Array of values to set.
         */
        SetColorArray(nameID: number, values: Array<Color>): void
        SetVectorArray(name: string, values: any): void
        SetVectorArray(nameID: number, values: any): void
        /** Sets a vector array property.
         * @param name Property name.
         * @param values Array of values to set.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         */
        SetVectorArray(name: string, values: Array<Vector4>): void
        /** Sets a vector array property.
         * @param name Property name.
         * @param values Array of values to set.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         */
        SetVectorArray(nameID: number, values: Array<Vector4>): void
        SetMatrixArray(name: string, values: any): void
        SetMatrixArray(nameID: number, values: any): void
        /** Sets a matrix array property.
         * @param name Property name.
         * @param values Array of values to set.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         */
        SetMatrixArray(name: string, values: Array<Matrix4x4>): void
        /** Sets a matrix array property.
         * @param name Property name.
         * @param values Array of values to set.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         */
        SetMatrixArray(nameID: number, values: Array<Matrix4x4>): void
        /** Get a named float value.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetFloat(name: string): number
        /** Get a named float value.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetFloat(nameID: number): number
        /** Get a named integer value.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetInt(name: string): number
        /** Get a named integer value.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetInt(nameID: number): number
        /** Get a named color value.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetColor(name: string): Color
        /** Get a named color value.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetColor(nameID: number): Color
        /** Get a named vector value.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetVector(name: string): Vector4
        /** Get a named vector value.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetVector(nameID: number): Vector4
        /** Get a named matrix value from the shader.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetMatrix(name: string): Matrix4x4
        /** Get a named matrix value from the shader.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetMatrix(nameID: number): Matrix4x4
        /** Get a named texture.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetTexture(name: string): Texture
        /** Get a named texture.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetTexture(nameID: number): Texture
        GetFloatArray(name: string, values: any): void
        GetFloatArray(nameID: number, values: any): void
        /** Get a named float array.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         */
        GetFloatArray(name: string): Array<number>
        /** Get a named float array.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         */
        GetFloatArray(nameID: number): Array<number>
        GetColorArray(name: string, values: any): void
        GetColorArray(nameID: number, values: any): void
        /** Get a named color array.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetColorArray(name: string): Array<Color>
        /** Get a named color array.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetColorArray(nameID: number): Array<Color>
        GetVectorArray(name: string, values: any): void
        GetVectorArray(nameID: number, values: any): void
        /** Get a named vector array.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         */
        GetVectorArray(name: string): Array<Vector4>
        /** Get a named vector array.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         */
        GetVectorArray(nameID: number): Array<Vector4>
        GetMatrixArray(name: string, values: any): void
        GetMatrixArray(nameID: number, values: any): void
        /** Get a named matrix array.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         */
        GetMatrixArray(name: string): Array<Matrix4x4>
        /** Get a named matrix array.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         */
        GetMatrixArray(nameID: number): Array<Matrix4x4>
        /** Sets the placement offset of texture propertyName.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, for example: "_MainTex".
         * @param value Texture placement offset.
         */
        SetTextureOffset(name: string, value: Vector2): void
        /** Sets the placement offset of texture propertyName.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, for example: "_MainTex".
         * @param value Texture placement offset.
         */
        SetTextureOffset(nameID: number, value: Vector2): void
        /** Sets the placement scale of texture propertyName.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, e.g. "_MainTex".
         * @param value Texture placement scale.
         */
        SetTextureScale(name: string, value: Vector2): void
        /** Sets the placement scale of texture propertyName.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, e.g. "_MainTex".
         * @param value Texture placement scale.
         */
        SetTextureScale(nameID: number, value: Vector2): void
        /** Gets the placement offset of texture propertyName.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetTextureOffset(name: string): Vector2
        /** Gets the placement offset of texture propertyName.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetTextureOffset(nameID: number): Vector2
        /** Gets the placement scale of texture propertyName.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetTextureScale(name: string): Vector2
        /** Gets the placement scale of texture propertyName.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetTextureScale(nameID: number): Vector2
        /** The shader used by the material.
         */
        shader: any
        /** The main color of the Material.
         */
        color: Color
        /** The main texture.
         */
        mainTexture: Texture
        /** The offset of the main texture.
         */
        mainTextureOffset: Vector2
        /** The scale of the main texture.
         */
        mainTextureScale: Vector2
        /** Render queue of this material.
         */
        renderQueue: number
        /** Defines how the material should interact with lightmaps and lightprobes.
         */
        globalIlluminationFlags: any
        /** Gets and sets whether the Double Sided Global Illumination setting is enabled for this material.
         */
        doubleSidedGI: boolean
        /** Gets and sets whether GPU instancing is enabled for this material.
         */
        enableInstancing: boolean
        /** How many passes are in this material (Read Only).
         */
        readonly passCount: number
        /** Additional shader keywords set by this material.
         */
        shaderKeywords: Array<string>
    }
}
declare module "UnityEngine" {
    import { Enum } from "System";
    /** RenderMode for the Canvas.
     */
    enum RenderMode {
        /** Render at the end of the Scene using a 2D Canvas.
         */
        ScreenSpaceOverlay = 0,
        /** Render using the Camera configured on the Canvas.
         */
        ScreenSpaceCamera = 1,
        /** Render using any Camera in the Scene that can render the layer.
         */
        WorldSpace = 2,
    }
}
declare module "UnityEngine" {
    import { Enum } from "System";
    /** Types of modifier key that can be active during a keystroke event.
     */
    enum EventModifiers {
        /** No modifier key pressed during a keystroke event.
         */
        None = 0,
        /** Shift key.
         */
        Shift = 1,
        /** Control key.
         */
        Control = 2,
        /** Alt key.
         */
        Alt = 4,
        /** Command key (Mac).
         */
        Command = 8,
        /** Num lock key.
         */
        Numeric = 16,
        /** Caps lock key.
         */
        CapsLock = 32,
        /** Function key.
         */
        FunctionKey = 64,
    }
}
declare module "UnityEngine" {
    import { Enum } from "System";
    /** Key codes returned by Event.keyCode. These map directly to a physical key on the keyboard.
     */
    enum KeyCode {
        /** Not assigned (never returned as the result of a keystroke).
         */
        None = 0,
        /** The backspace key.
         */
        Backspace = 8,
        /** The tab key.
         */
        Tab = 9,
        /** The Clear key.
         */
        Clear = 12,
        /** Return key.
         */
        Return = 13,
        /** Pause on PC machines.
         */
        Pause = 19,
        /** Escape key.
         */
        Escape = 27,
        /** Space key.
         */
        Space = 32,
        /** Exclamation mark key '!'.
         */
        Exclaim = 33,
        /** Double quote key '"'.
         */
        DoubleQuote = 34,
        /** Hash key '#'.
         */
        Hash = 35,
        /** Dollar sign key '$'.
         */
        Dollar = 36,
        /** Percent '%' key.
         */
        Percent = 37,
        /** Ampersand key '&'.
         */
        Ampersand = 38,
        /** Quote key '.
         */
        Quote = 39,
        /** Left Parenthesis key '('.
         */
        LeftParen = 40,
        /** Right Parenthesis key ')'.
         */
        RightParen = 41,
        /** Asterisk key '*'.
         */
        Asterisk = 42,
        /** Plus key '+'.
         */
        Plus = 43,
        /** Comma ',' key.
         */
        Comma = 44,
        /** Minus '-' key.
         */
        Minus = 45,
        /** Period '.' key.
         */
        Period = 46,
        /** Slash '/' key.
         */
        Slash = 47,
        /** The '0' key on the top of the alphanumeric keyboard.
         */
        Alpha0 = 48,
        /** The '1' key on the top of the alphanumeric keyboard.
         */
        Alpha1 = 49,
        /** The '2' key on the top of the alphanumeric keyboard.
         */
        Alpha2 = 50,
        /** The '3' key on the top of the alphanumeric keyboard.
         */
        Alpha3 = 51,
        /** The '4' key on the top of the alphanumeric keyboard.
         */
        Alpha4 = 52,
        /** The '5' key on the top of the alphanumeric keyboard.
         */
        Alpha5 = 53,
        /** The '6' key on the top of the alphanumeric keyboard.
         */
        Alpha6 = 54,
        /** The '7' key on the top of the alphanumeric keyboard.
         */
        Alpha7 = 55,
        /** The '8' key on the top of the alphanumeric keyboard.
         */
        Alpha8 = 56,
        /** The '9' key on the top of the alphanumeric keyboard.
         */
        Alpha9 = 57,
        /** Colon ':' key.
         */
        Colon = 58,
        /** Semicolon ';' key.
         */
        Semicolon = 59,
        /** Less than '<' key.
         */
        Less = 60,
        /** Equals '=' key.
         */
        Equals = 61,
        /** Greater than '>' key.
         */
        Greater = 62,
        /** Question mark '?' key.
         */
        Question = 63,
        /** At key '@'.
         */
        At = 64,
        /** Left square bracket key '['.
         */
        LeftBracket = 91,
        /** Backslash key '\'.
         */
        Backslash = 92,
        /** Right square bracket key ']'.
         */
        RightBracket = 93,
        /** Caret key '^'.
         */
        Caret = 94,
        /** Underscore '_' key.
         */
        Underscore = 95,
        /** Back quote key '`'.
         */
        BackQuote = 96,
        /** 'a' key.
         */
        A = 97,
        /** 'b' key.
         */
        B = 98,
        /** 'c' key.
         */
        C = 99,
        /** 'd' key.
         */
        D = 100,
        /** 'e' key.
         */
        E = 101,
        /** 'f' key.
         */
        F = 102,
        /** 'g' key.
         */
        G = 103,
        /** 'h' key.
         */
        H = 104,
        /** 'i' key.
         */
        I = 105,
        /** 'j' key.
         */
        J = 106,
        /** 'k' key.
         */
        K = 107,
        /** 'l' key.
         */
        L = 108,
        /** 'm' key.
         */
        M = 109,
        /** 'n' key.
         */
        N = 110,
        /** 'o' key.
         */
        O = 111,
        /** 'p' key.
         */
        P = 112,
        /** 'q' key.
         */
        Q = 113,
        /** 'r' key.
         */
        R = 114,
        /** 's' key.
         */
        S = 115,
        /** 't' key.
         */
        T = 116,
        /** 'u' key.
         */
        U = 117,
        /** 'v' key.
         */
        V = 118,
        /** 'w' key.
         */
        W = 119,
        /** 'x' key.
         */
        X = 120,
        /** 'y' key.
         */
        Y = 121,
        /** 'z' key.
         */
        Z = 122,
        /** Left curly bracket key '{'.
         */
        LeftCurlyBracket = 123,
        /** Pipe '|' key.
         */
        Pipe = 124,
        /** Right curly bracket key '}'.
         */
        RightCurlyBracket = 125,
        /** Tilde '~' key.
         */
        Tilde = 126,
        /** The forward delete key.
         */
        Delete = 127,
        /** Numeric keypad 0.
         */
        Keypad0 = 256,
        /** Numeric keypad 1.
         */
        Keypad1 = 257,
        /** Numeric keypad 2.
         */
        Keypad2 = 258,
        /** Numeric keypad 3.
         */
        Keypad3 = 259,
        /** Numeric keypad 4.
         */
        Keypad4 = 260,
        /** Numeric keypad 5.
         */
        Keypad5 = 261,
        /** Numeric keypad 6.
         */
        Keypad6 = 262,
        /** Numeric keypad 7.
         */
        Keypad7 = 263,
        /** Numeric keypad 8.
         */
        Keypad8 = 264,
        /** Numeric keypad 9.
         */
        Keypad9 = 265,
        /** Numeric keypad '.'.
         */
        KeypadPeriod = 266,
        /** Numeric keypad '/'.
         */
        KeypadDivide = 267,
        /** Numeric keypad '*'.
         */
        KeypadMultiply = 268,
        /** Numeric keypad '-'.
         */
        KeypadMinus = 269,
        /** Numeric keypad '+'.
         */
        KeypadPlus = 270,
        /** Numeric keypad Enter.
         */
        KeypadEnter = 271,
        /** Numeric keypad '='.
         */
        KeypadEquals = 272,
        /** Up arrow key.
         */
        UpArrow = 273,
        /** Down arrow key.
         */
        DownArrow = 274,
        /** Right arrow key.
         */
        RightArrow = 275,
        /** Left arrow key.
         */
        LeftArrow = 276,
        /** Insert key key.
         */
        Insert = 277,
        /** Home key.
         */
        Home = 278,
        /** End key.
         */
        End = 279,
        /** Page up.
         */
        PageUp = 280,
        /** Page down.
         */
        PageDown = 281,
        /** F1 function key.
         */
        F1 = 282,
        /** F2 function key.
         */
        F2 = 283,
        /** F3 function key.
         */
        F3 = 284,
        /** F4 function key.
         */
        F4 = 285,
        /** F5 function key.
         */
        F5 = 286,
        /** F6 function key.
         */
        F6 = 287,
        /** F7 function key.
         */
        F7 = 288,
        /** F8 function key.
         */
        F8 = 289,
        /** F9 function key.
         */
        F9 = 290,
        /** F10 function key.
         */
        F10 = 291,
        /** F11 function key.
         */
        F11 = 292,
        /** F12 function key.
         */
        F12 = 293,
        /** F13 function key.
         */
        F13 = 294,
        /** F14 function key.
         */
        F14 = 295,
        /** F15 function key.
         */
        F15 = 296,
        /** Numlock key.
         */
        Numlock = 300,
        /** Capslock key.
         */
        CapsLock = 301,
        /** Scroll lock key.
         */
        ScrollLock = 302,
        /** Right shift key.
         */
        RightShift = 303,
        /** Left shift key.
         */
        LeftShift = 304,
        /** Right Control key.
         */
        RightControl = 305,
        /** Left Control key.
         */
        LeftControl = 306,
        /** Right Alt key.
         */
        RightAlt = 307,
        /** Left Alt key.
         */
        LeftAlt = 308,
        /** Right Command key.
         */
        RightCommand = 309,
        /** Right Command key.
         */
        RightApple = 309,
        /** Left Command key.
         */
        LeftCommand = 310,
        /** Left Command key.
         */
        LeftApple = 310,
        /** Left Windows key.
         */
        LeftWindows = 311,
        /** Right Windows key.
         */
        RightWindows = 312,
        /** Alt Gr key.
         */
        AltGr = 313,
        /** Help key.
         */
        Help = 315,
        /** Print key.
         */
        Print = 316,
        /** Sys Req key.
         */
        SysReq = 317,
        /** Break key.
         */
        Break = 318,
        /** Menu key.
         */
        Menu = 319,
        /** The Left (or primary) mouse button.
         */
        Mouse0 = 323,
        /** Right mouse button (or secondary mouse button).
         */
        Mouse1 = 324,
        /** Middle mouse button (or third button).
         */
        Mouse2 = 325,
        /** Additional (fourth) mouse button.
         */
        Mouse3 = 326,
        /** Additional (fifth) mouse button.
         */
        Mouse4 = 327,
        /** Additional (or sixth) mouse button.
         */
        Mouse5 = 328,
        /** Additional (or seventh) mouse button.
         */
        Mouse6 = 329,
        /** Button 0 on any joystick.
         */
        JoystickButton0 = 330,
        /** Button 1 on any joystick.
         */
        JoystickButton1 = 331,
        /** Button 2 on any joystick.
         */
        JoystickButton2 = 332,
        /** Button 3 on any joystick.
         */
        JoystickButton3 = 333,
        /** Button 4 on any joystick.
         */
        JoystickButton4 = 334,
        /** Button 5 on any joystick.
         */
        JoystickButton5 = 335,
        /** Button 6 on any joystick.
         */
        JoystickButton6 = 336,
        /** Button 7 on any joystick.
         */
        JoystickButton7 = 337,
        /** Button 8 on any joystick.
         */
        JoystickButton8 = 338,
        /** Button 9 on any joystick.
         */
        JoystickButton9 = 339,
        /** Button 10 on any joystick.
         */
        JoystickButton10 = 340,
        /** Button 11 on any joystick.
         */
        JoystickButton11 = 341,
        /** Button 12 on any joystick.
         */
        JoystickButton12 = 342,
        /** Button 13 on any joystick.
         */
        JoystickButton13 = 343,
        /** Button 14 on any joystick.
         */
        JoystickButton14 = 344,
        /** Button 15 on any joystick.
         */
        JoystickButton15 = 345,
        /** Button 16 on any joystick.
         */
        JoystickButton16 = 346,
        /** Button 17 on any joystick.
         */
        JoystickButton17 = 347,
        /** Button 18 on any joystick.
         */
        JoystickButton18 = 348,
        /** Button 19 on any joystick.
         */
        JoystickButton19 = 349,
        /** Button 0 on first joystick.
         */
        Joystick1Button0 = 350,
        /** Button 1 on first joystick.
         */
        Joystick1Button1 = 351,
        /** Button 2 on first joystick.
         */
        Joystick1Button2 = 352,
        /** Button 3 on first joystick.
         */
        Joystick1Button3 = 353,
        /** Button 4 on first joystick.
         */
        Joystick1Button4 = 354,
        /** Button 5 on first joystick.
         */
        Joystick1Button5 = 355,
        /** Button 6 on first joystick.
         */
        Joystick1Button6 = 356,
        /** Button 7 on first joystick.
         */
        Joystick1Button7 = 357,
        /** Button 8 on first joystick.
         */
        Joystick1Button8 = 358,
        /** Button 9 on first joystick.
         */
        Joystick1Button9 = 359,
        /** Button 10 on first joystick.
         */
        Joystick1Button10 = 360,
        /** Button 11 on first joystick.
         */
        Joystick1Button11 = 361,
        /** Button 12 on first joystick.
         */
        Joystick1Button12 = 362,
        /** Button 13 on first joystick.
         */
        Joystick1Button13 = 363,
        /** Button 14 on first joystick.
         */
        Joystick1Button14 = 364,
        /** Button 15 on first joystick.
         */
        Joystick1Button15 = 365,
        /** Button 16 on first joystick.
         */
        Joystick1Button16 = 366,
        /** Button 17 on first joystick.
         */
        Joystick1Button17 = 367,
        /** Button 18 on first joystick.
         */
        Joystick1Button18 = 368,
        /** Button 19 on first joystick.
         */
        Joystick1Button19 = 369,
        /** Button 0 on second joystick.
         */
        Joystick2Button0 = 370,
        /** Button 1 on second joystick.
         */
        Joystick2Button1 = 371,
        /** Button 2 on second joystick.
         */
        Joystick2Button2 = 372,
        /** Button 3 on second joystick.
         */
        Joystick2Button3 = 373,
        /** Button 4 on second joystick.
         */
        Joystick2Button4 = 374,
        /** Button 5 on second joystick.
         */
        Joystick2Button5 = 375,
        /** Button 6 on second joystick.
         */
        Joystick2Button6 = 376,
        /** Button 7 on second joystick.
         */
        Joystick2Button7 = 377,
        /** Button 8 on second joystick.
         */
        Joystick2Button8 = 378,
        /** Button 9 on second joystick.
         */
        Joystick2Button9 = 379,
        /** Button 10 on second joystick.
         */
        Joystick2Button10 = 380,
        /** Button 11 on second joystick.
         */
        Joystick2Button11 = 381,
        /** Button 12 on second joystick.
         */
        Joystick2Button12 = 382,
        /** Button 13 on second joystick.
         */
        Joystick2Button13 = 383,
        /** Button 14 on second joystick.
         */
        Joystick2Button14 = 384,
        /** Button 15 on second joystick.
         */
        Joystick2Button15 = 385,
        /** Button 16 on second joystick.
         */
        Joystick2Button16 = 386,
        /** Button 17 on second joystick.
         */
        Joystick2Button17 = 387,
        /** Button 18 on second joystick.
         */
        Joystick2Button18 = 388,
        /** Button 19 on second joystick.
         */
        Joystick2Button19 = 389,
        /** Button 0 on third joystick.
         */
        Joystick3Button0 = 390,
        /** Button 1 on third joystick.
         */
        Joystick3Button1 = 391,
        /** Button 2 on third joystick.
         */
        Joystick3Button2 = 392,
        /** Button 3 on third joystick.
         */
        Joystick3Button3 = 393,
        /** Button 4 on third joystick.
         */
        Joystick3Button4 = 394,
        /** Button 5 on third joystick.
         */
        Joystick3Button5 = 395,
        /** Button 6 on third joystick.
         */
        Joystick3Button6 = 396,
        /** Button 7 on third joystick.
         */
        Joystick3Button7 = 397,
        /** Button 8 on third joystick.
         */
        Joystick3Button8 = 398,
        /** Button 9 on third joystick.
         */
        Joystick3Button9 = 399,
        /** Button 10 on third joystick.
         */
        Joystick3Button10 = 400,
        /** Button 11 on third joystick.
         */
        Joystick3Button11 = 401,
        /** Button 12 on third joystick.
         */
        Joystick3Button12 = 402,
        /** Button 13 on third joystick.
         */
        Joystick3Button13 = 403,
        /** Button 14 on third joystick.
         */
        Joystick3Button14 = 404,
        /** Button 15 on third joystick.
         */
        Joystick3Button15 = 405,
        /** Button 16 on third joystick.
         */
        Joystick3Button16 = 406,
        /** Button 17 on third joystick.
         */
        Joystick3Button17 = 407,
        /** Button 18 on third joystick.
         */
        Joystick3Button18 = 408,
        /** Button 19 on third joystick.
         */
        Joystick3Button19 = 409,
        /** Button 0 on forth joystick.
         */
        Joystick4Button0 = 410,
        /** Button 1 on forth joystick.
         */
        Joystick4Button1 = 411,
        /** Button 2 on forth joystick.
         */
        Joystick4Button2 = 412,
        /** Button 3 on forth joystick.
         */
        Joystick4Button3 = 413,
        /** Button 4 on forth joystick.
         */
        Joystick4Button4 = 414,
        /** Button 5 on forth joystick.
         */
        Joystick4Button5 = 415,
        /** Button 6 on forth joystick.
         */
        Joystick4Button6 = 416,
        /** Button 7 on forth joystick.
         */
        Joystick4Button7 = 417,
        /** Button 8 on forth joystick.
         */
        Joystick4Button8 = 418,
        /** Button 9 on forth joystick.
         */
        Joystick4Button9 = 419,
        /** Button 10 on forth joystick.
         */
        Joystick4Button10 = 420,
        /** Button 11 on forth joystick.
         */
        Joystick4Button11 = 421,
        /** Button 12 on forth joystick.
         */
        Joystick4Button12 = 422,
        /** Button 13 on forth joystick.
         */
        Joystick4Button13 = 423,
        /** Button 14 on forth joystick.
         */
        Joystick4Button14 = 424,
        /** Button 15 on forth joystick.
         */
        Joystick4Button15 = 425,
        /** Button 16 on forth joystick.
         */
        Joystick4Button16 = 426,
        /** Button 17 on forth joystick.
         */
        Joystick4Button17 = 427,
        /** Button 18 on forth joystick.
         */
        Joystick4Button18 = 428,
        /** Button 19 on forth joystick.
         */
        Joystick4Button19 = 429,
        /** Button 0 on fifth joystick.
         */
        Joystick5Button0 = 430,
        /** Button 1 on fifth joystick.
         */
        Joystick5Button1 = 431,
        /** Button 2 on fifth joystick.
         */
        Joystick5Button2 = 432,
        /** Button 3 on fifth joystick.
         */
        Joystick5Button3 = 433,
        /** Button 4 on fifth joystick.
         */
        Joystick5Button4 = 434,
        /** Button 5 on fifth joystick.
         */
        Joystick5Button5 = 435,
        /** Button 6 on fifth joystick.
         */
        Joystick5Button6 = 436,
        /** Button 7 on fifth joystick.
         */
        Joystick5Button7 = 437,
        /** Button 8 on fifth joystick.
         */
        Joystick5Button8 = 438,
        /** Button 9 on fifth joystick.
         */
        Joystick5Button9 = 439,
        /** Button 10 on fifth joystick.
         */
        Joystick5Button10 = 440,
        /** Button 11 on fifth joystick.
         */
        Joystick5Button11 = 441,
        /** Button 12 on fifth joystick.
         */
        Joystick5Button12 = 442,
        /** Button 13 on fifth joystick.
         */
        Joystick5Button13 = 443,
        /** Button 14 on fifth joystick.
         */
        Joystick5Button14 = 444,
        /** Button 15 on fifth joystick.
         */
        Joystick5Button15 = 445,
        /** Button 16 on fifth joystick.
         */
        Joystick5Button16 = 446,
        /** Button 17 on fifth joystick.
         */
        Joystick5Button17 = 447,
        /** Button 18 on fifth joystick.
         */
        Joystick5Button18 = 448,
        /** Button 19 on fifth joystick.
         */
        Joystick5Button19 = 449,
        /** Button 0 on sixth joystick.
         */
        Joystick6Button0 = 450,
        /** Button 1 on sixth joystick.
         */
        Joystick6Button1 = 451,
        /** Button 2 on sixth joystick.
         */
        Joystick6Button2 = 452,
        /** Button 3 on sixth joystick.
         */
        Joystick6Button3 = 453,
        /** Button 4 on sixth joystick.
         */
        Joystick6Button4 = 454,
        /** Button 5 on sixth joystick.
         */
        Joystick6Button5 = 455,
        /** Button 6 on sixth joystick.
         */
        Joystick6Button6 = 456,
        /** Button 7 on sixth joystick.
         */
        Joystick6Button7 = 457,
        /** Button 8 on sixth joystick.
         */
        Joystick6Button8 = 458,
        /** Button 9 on sixth joystick.
         */
        Joystick6Button9 = 459,
        /** Button 10 on sixth joystick.
         */
        Joystick6Button10 = 460,
        /** Button 11 on sixth joystick.
         */
        Joystick6Button11 = 461,
        /** Button 12 on sixth joystick.
         */
        Joystick6Button12 = 462,
        /** Button 13 on sixth joystick.
         */
        Joystick6Button13 = 463,
        /** Button 14 on sixth joystick.
         */
        Joystick6Button14 = 464,
        /** Button 15 on sixth joystick.
         */
        Joystick6Button15 = 465,
        /** Button 16 on sixth joystick.
         */
        Joystick6Button16 = 466,
        /** Button 17 on sixth joystick.
         */
        Joystick6Button17 = 467,
        /** Button 18 on sixth joystick.
         */
        Joystick6Button18 = 468,
        /** Button 19 on sixth joystick.
         */
        Joystick6Button19 = 469,
        /** Button 0 on seventh joystick.
         */
        Joystick7Button0 = 470,
        /** Button 1 on seventh joystick.
         */
        Joystick7Button1 = 471,
        /** Button 2 on seventh joystick.
         */
        Joystick7Button2 = 472,
        /** Button 3 on seventh joystick.
         */
        Joystick7Button3 = 473,
        /** Button 4 on seventh joystick.
         */
        Joystick7Button4 = 474,
        /** Button 5 on seventh joystick.
         */
        Joystick7Button5 = 475,
        /** Button 6 on seventh joystick.
         */
        Joystick7Button6 = 476,
        /** Button 7 on seventh joystick.
         */
        Joystick7Button7 = 477,
        /** Button 8 on seventh joystick.
         */
        Joystick7Button8 = 478,
        /** Button 9 on seventh joystick.
         */
        Joystick7Button9 = 479,
        /** Button 10 on seventh joystick.
         */
        Joystick7Button10 = 480,
        /** Button 11 on seventh joystick.
         */
        Joystick7Button11 = 481,
        /** Button 12 on seventh joystick.
         */
        Joystick7Button12 = 482,
        /** Button 13 on seventh joystick.
         */
        Joystick7Button13 = 483,
        /** Button 14 on seventh joystick.
         */
        Joystick7Button14 = 484,
        /** Button 15 on seventh joystick.
         */
        Joystick7Button15 = 485,
        /** Button 16 on seventh joystick.
         */
        Joystick7Button16 = 486,
        /** Button 17 on seventh joystick.
         */
        Joystick7Button17 = 487,
        /** Button 18 on seventh joystick.
         */
        Joystick7Button18 = 488,
        /** Button 19 on seventh joystick.
         */
        Joystick7Button19 = 489,
        /** Button 0 on eighth joystick.
         */
        Joystick8Button0 = 490,
        /** Button 1 on eighth joystick.
         */
        Joystick8Button1 = 491,
        /** Button 2 on eighth joystick.
         */
        Joystick8Button2 = 492,
        /** Button 3 on eighth joystick.
         */
        Joystick8Button3 = 493,
        /** Button 4 on eighth joystick.
         */
        Joystick8Button4 = 494,
        /** Button 5 on eighth joystick.
         */
        Joystick8Button5 = 495,
        /** Button 6 on eighth joystick.
         */
        Joystick8Button6 = 496,
        /** Button 7 on eighth joystick.
         */
        Joystick8Button7 = 497,
        /** Button 8 on eighth joystick.
         */
        Joystick8Button8 = 498,
        /** Button 9 on eighth joystick.
         */
        Joystick8Button9 = 499,
        /** Button 10 on eighth joystick.
         */
        Joystick8Button10 = 500,
        /** Button 11 on eighth joystick.
         */
        Joystick8Button11 = 501,
        /** Button 12 on eighth joystick.
         */
        Joystick8Button12 = 502,
        /** Button 13 on eighth joystick.
         */
        Joystick8Button13 = 503,
        /** Button 14 on eighth joystick.
         */
        Joystick8Button14 = 504,
        /** Button 15 on eighth joystick.
         */
        Joystick8Button15 = 505,
        /** Button 16 on eighth joystick.
         */
        Joystick8Button16 = 506,
        /** Button 17 on eighth joystick.
         */
        Joystick8Button17 = 507,
        /** Button 18 on eighth joystick.
         */
        Joystick8Button18 = 508,
        /** Button 19 on eighth joystick.
         */
        Joystick8Button19 = 509,
    }
}
declare module "System.Collections.Generic" {
    import { GObject } from "FairyGUI";
    interface IList_GObject extends IList<GObject> {
        $GetValue(index: number): GObject
        $SetValue(index: number, value: GObject): void
        IndexOf(item: GObject): number
        Insert(index: number, item: GObject): void
        RemoveAt(index: number): void
    }
}
declare module "System.Collections.Generic" {
    import { Object } from "System";
    interface IList<T> {
        $GetValue(index: number): T
        $SetValue(index: number, value: T): void
        IndexOf(item: T): number
        Insert(index: number, item: T): void
        RemoveAt(index: number): void
    }
}
declare module "System.Collections.Generic" {
    import * as jsb from "jsb";
    import { Object, Array, ValueType } from "System";
    import { PackageItem } from "FairyGUI";
    class List_PackageItem extends Object implements List<PackageItem> {
        constructor(capacity: number)
        constructor(collection: any)
        constructor()
        $GetValue(index: number): PackageItem
        $SetValue(index: number, value: PackageItem): void
        Add(item: PackageItem): void
        AddRange(collection: any): void
        AsReadOnly(): any
        BinarySearch(index: number, count: number, item: PackageItem, comparer: any): number
        BinarySearch(item: PackageItem, comparer: any): number
        BinarySearch(item: PackageItem): number
        Clear(): void
        Contains(item: PackageItem): boolean
        CopyTo(index: number, array: Array<PackageItem>, arrayIndex: number, count: number): void
        CopyTo(array: Array<PackageItem>, arrayIndex: number): void
        CopyTo(array: Array<PackageItem>): void
        Exists(match: (obj: PackageItem) => boolean): boolean
        Find(match: (obj: PackageItem) => boolean): PackageItem
        FindAll(match: (obj: PackageItem) => boolean): List<PackageItem>
        FindIndex(startIndex: number, count: number, match: (obj: PackageItem) => boolean): number
        FindIndex(startIndex: number, match: (obj: PackageItem) => boolean): number
        FindIndex(match: (obj: PackageItem) => boolean): number
        FindLast(match: (obj: PackageItem) => boolean): PackageItem
        FindLastIndex(startIndex: number, count: number, match: (obj: PackageItem) => boolean): number
        FindLastIndex(startIndex: number, match: (obj: PackageItem) => boolean): number
        FindLastIndex(match: (obj: PackageItem) => boolean): number
        ForEach(action: (obj: PackageItem) => void): void
        GetEnumerator(): any
        GetRange(index: number, count: number): List<PackageItem>
        IndexOf(item: PackageItem, index: number, count: number): number
        IndexOf(item: PackageItem, index: number): number
        IndexOf(item: PackageItem): number
        Insert(index: number, item: PackageItem): void
        InsertRange(index: number, collection: any): void
        LastIndexOf(item: PackageItem, index: number, count: number): number
        LastIndexOf(item: PackageItem, index: number): number
        LastIndexOf(item: PackageItem): number
        Remove(item: PackageItem): boolean
        RemoveAll(match: (obj: PackageItem) => boolean): number
        RemoveAt(index: number): void
        RemoveRange(index: number, count: number): void
        Reverse(index: number, count: number): void
        Reverse(): void
        Sort(index: number, count: number, comparer: any): void
        Sort(comparer: any): void
        Sort(comparison: (x: PackageItem, y: PackageItem) => number): void
        Sort(): void
        ToArray(): Array<PackageItem>
        TrimExcess(): void
        TrueForAll(match: (obj: PackageItem) => boolean): boolean
        Capacity: number
        readonly Count: number
    }
}
declare module "System.Collections.Generic" {
    import * as jsb from "jsb";
    import { Object, Array, ValueType } from "System";
    class List<T> extends Object {
        $GetValue(index: number): T
        $SetValue(index: number, value: T): void
        Add(item: T): void
        AddRange(collection: any): void
        AsReadOnly(): any
        BinarySearch(index: number, count: number, item: T, comparer: any): number
        BinarySearch(item: T, comparer: any): number
        BinarySearch(item: T): number
        Clear(): void
        Contains(item: T): boolean
        CopyTo(index: number, array: Array<T>, arrayIndex: number, count: number): void
        CopyTo(array: Array<T>, arrayIndex: number): void
        CopyTo(array: Array<T>): void
        Exists(match: any): boolean
        Find(match: any): T
        FindAll(match: any): List<T>
        FindIndex(startIndex: number, count: number, match: any): number
        FindIndex(startIndex: number, match: any): number
        FindIndex(match: any): number
        FindLast(match: any): T
        FindLastIndex(startIndex: number, count: number, match: any): number
        FindLastIndex(startIndex: number, match: any): number
        FindLastIndex(match: any): number
        ForEach(action: any): void
        GetEnumerator(): any
        GetRange(index: number, count: number): List<T>
        IndexOf(item: T, index: number, count: number): number
        IndexOf(item: T, index: number): number
        IndexOf(item: T): number
        Insert(index: number, item: T): void
        InsertRange(index: number, collection: any): void
        LastIndexOf(item: T, index: number, count: number): number
        LastIndexOf(item: T, index: number): number
        LastIndexOf(item: T): number
        Remove(item: T): boolean
        RemoveAll(match: any): number
        RemoveAt(index: number): void
        RemoveRange(index: number, count: number): void
        Reverse(index: number, count: number): void
        Reverse(): void
        Sort(index: number, count: number, comparer: any): void
        Sort(comparer: any): void
        Sort(comparison: any): void
        Sort(): void
        ToArray(): Array<T>
        TrimExcess(): void
        TrueForAll(match: any): boolean
        Capacity: number
        readonly Count: number
    }
}
declare module "System.Collections.Generic" {
    import * as jsb from "jsb";
    import { Object, Array, ValueType } from "System";
    import { UIPackage } from "FairyGUI";
    class List_UIPackage extends Object implements List<UIPackage> {
        constructor(capacity: number)
        constructor(collection: any)
        constructor()
        $GetValue(index: number): UIPackage
        $SetValue(index: number, value: UIPackage): void
        Add(item: UIPackage): void
        AddRange(collection: any): void
        AsReadOnly(): any
        BinarySearch(index: number, count: number, item: UIPackage, comparer: any): number
        BinarySearch(item: UIPackage, comparer: any): number
        BinarySearch(item: UIPackage): number
        Clear(): void
        Contains(item: UIPackage): boolean
        CopyTo(index: number, array: Array<UIPackage>, arrayIndex: number, count: number): void
        CopyTo(array: Array<UIPackage>, arrayIndex: number): void
        CopyTo(array: Array<UIPackage>): void
        Exists(match: (obj: UIPackage) => boolean): boolean
        Find(match: (obj: UIPackage) => boolean): UIPackage
        FindAll(match: (obj: UIPackage) => boolean): List<UIPackage>
        FindIndex(startIndex: number, count: number, match: (obj: UIPackage) => boolean): number
        FindIndex(startIndex: number, match: (obj: UIPackage) => boolean): number
        FindIndex(match: (obj: UIPackage) => boolean): number
        FindLast(match: (obj: UIPackage) => boolean): UIPackage
        FindLastIndex(startIndex: number, count: number, match: (obj: UIPackage) => boolean): number
        FindLastIndex(startIndex: number, match: (obj: UIPackage) => boolean): number
        FindLastIndex(match: (obj: UIPackage) => boolean): number
        ForEach(action: (obj: UIPackage) => void): void
        GetEnumerator(): any
        GetRange(index: number, count: number): List<UIPackage>
        IndexOf(item: UIPackage, index: number, count: number): number
        IndexOf(item: UIPackage, index: number): number
        IndexOf(item: UIPackage): number
        Insert(index: number, item: UIPackage): void
        InsertRange(index: number, collection: any): void
        LastIndexOf(item: UIPackage, index: number, count: number): number
        LastIndexOf(item: UIPackage, index: number): number
        LastIndexOf(item: UIPackage): number
        Remove(item: UIPackage): boolean
        RemoveAll(match: (obj: UIPackage) => boolean): number
        RemoveAt(index: number): void
        RemoveRange(index: number, count: number): void
        Reverse(index: number, count: number): void
        Reverse(): void
        Sort(index: number, count: number, comparer: any): void
        Sort(comparer: any): void
        Sort(comparison: (x: UIPackage, y: UIPackage) => number): void
        Sort(): void
        ToArray(): Array<UIPackage>
        TrimExcess(): void
        TrueForAll(match: (obj: UIPackage) => boolean): boolean
        Capacity: number
        readonly Count: number
    }
}
declare module "System.Collections.Generic" {
    import * as jsb from "jsb";
    import { Object, Array, ValueType } from "System";
    import { GTreeNode } from "FairyGUI";
    class List_GTreeNode extends Object implements List<GTreeNode> {
        constructor(capacity: number)
        constructor(collection: any)
        constructor()
        $GetValue(index: number): GTreeNode
        $SetValue(index: number, value: GTreeNode): void
        Add(item: GTreeNode): void
        AddRange(collection: any): void
        AsReadOnly(): any
        BinarySearch(index: number, count: number, item: GTreeNode, comparer: any): number
        BinarySearch(item: GTreeNode, comparer: any): number
        BinarySearch(item: GTreeNode): number
        Clear(): void
        Contains(item: GTreeNode): boolean
        CopyTo(index: number, array: Array<GTreeNode>, arrayIndex: number, count: number): void
        CopyTo(array: Array<GTreeNode>, arrayIndex: number): void
        CopyTo(array: Array<GTreeNode>): void
        Exists(match: (obj: GTreeNode) => boolean): boolean
        Find(match: (obj: GTreeNode) => boolean): GTreeNode
        FindAll(match: (obj: GTreeNode) => boolean): List<GTreeNode>
        FindIndex(startIndex: number, count: number, match: (obj: GTreeNode) => boolean): number
        FindIndex(startIndex: number, match: (obj: GTreeNode) => boolean): number
        FindIndex(match: (obj: GTreeNode) => boolean): number
        FindLast(match: (obj: GTreeNode) => boolean): GTreeNode
        FindLastIndex(startIndex: number, count: number, match: (obj: GTreeNode) => boolean): number
        FindLastIndex(startIndex: number, match: (obj: GTreeNode) => boolean): number
        FindLastIndex(match: (obj: GTreeNode) => boolean): number
        ForEach(action: (obj: GTreeNode) => void): void
        GetEnumerator(): any
        GetRange(index: number, count: number): List<GTreeNode>
        IndexOf(item: GTreeNode, index: number, count: number): number
        IndexOf(item: GTreeNode, index: number): number
        IndexOf(item: GTreeNode): number
        Insert(index: number, item: GTreeNode): void
        InsertRange(index: number, collection: any): void
        LastIndexOf(item: GTreeNode, index: number, count: number): number
        LastIndexOf(item: GTreeNode, index: number): number
        LastIndexOf(item: GTreeNode): number
        Remove(item: GTreeNode): boolean
        RemoveAll(match: (obj: GTreeNode) => boolean): number
        RemoveAt(index: number): void
        RemoveRange(index: number, count: number): void
        Reverse(index: number, count: number): void
        Reverse(): void
        Sort(index: number, count: number, comparer: any): void
        Sort(comparer: any): void
        Sort(comparison: (x: GTreeNode, y: GTreeNode) => number): void
        Sort(): void
        ToArray(): Array<GTreeNode>
        TrimExcess(): void
        TrueForAll(match: (obj: GTreeNode) => boolean): boolean
        Capacity: number
        readonly Count: number
    }
}
declare module "System.Collections.Generic" {
    import * as jsb from "jsb";
    import { Object, Array, ValueType } from "System";
    class List_Int32 extends Object implements List<number> {
        constructor(capacity: number)
        constructor(collection: any)
        constructor()
        $GetValue(index: number): number
        $SetValue(index: number, value: number): void
        Add(item: number): void
        AddRange(collection: any): void
        AsReadOnly(): any
        BinarySearch(index: number, count: number, item: number, comparer: any): number
        BinarySearch(item: number, comparer: any): number
        BinarySearch(item: number): number
        Clear(): void
        Contains(item: number): boolean
        CopyTo(index: number, array: Array<number>, arrayIndex: number, count: number): void
        CopyTo(array: Array<number>, arrayIndex: number): void
        CopyTo(array: Array<number>): void
        Exists(match: (arg: number) => boolean): boolean
        Find(match: (arg: number) => boolean): number
        FindAll(match: (arg: number) => boolean): List<number>
        FindIndex(startIndex: number, count: number, match: (arg: number) => boolean): number
        FindIndex(startIndex: number, match: (arg: number) => boolean): number
        FindIndex(match: (arg: number) => boolean): number
        FindLast(match: (arg: number) => boolean): number
        FindLastIndex(startIndex: number, count: number, match: (arg: number) => boolean): number
        FindLastIndex(startIndex: number, match: (arg: number) => boolean): number
        FindLastIndex(match: (arg: number) => boolean): number
        ForEach(action: (id: number) => void): void
        GetEnumerator(): any
        GetRange(index: number, count: number): List<number>
        IndexOf(item: number, index: number, count: number): number
        IndexOf(item: number, index: number): number
        IndexOf(item: number): number
        Insert(index: number, item: number): void
        InsertRange(index: number, collection: any): void
        LastIndexOf(item: number, index: number, count: number): number
        LastIndexOf(item: number, index: number): number
        LastIndexOf(item: number): number
        Remove(item: number): boolean
        RemoveAll(match: (arg: number) => boolean): number
        RemoveAt(index: number): void
        RemoveRange(index: number, count: number): void
        Reverse(index: number, count: number): void
        Reverse(): void
        Sort(index: number, count: number, comparer: any): void
        Sort(comparer: any): void
        Sort(comparison: (x: number, y: number) => number): void
        Sort(): void
        ToArray(): Array<number>
        TrimExcess(): void
        TrueForAll(match: (arg: number) => boolean): boolean
        Capacity: number
        readonly Count: number
    }
}
declare module "System.Collections.Generic" {
    import * as jsb from "jsb";
    import { Object, Array, ValueType } from "System";
    class List_String extends Object implements IEnumerable<string>, List<string> {
        constructor(capacity: number)
        constructor(collection: IEnumerable<string>)
        constructor()
        $GetValue(index: number): string
        $SetValue(index: number, value: string): void
        Add(item: string): void
        AddRange(collection: IEnumerable<string>): void
        AsReadOnly(): any
        BinarySearch(index: number, count: number, item: string, comparer: any): number
        BinarySearch(item: string, comparer: any): number
        BinarySearch(item: string): number
        Clear(): void
        Contains(item: string): boolean
        CopyTo(index: number, array: Array<string>, arrayIndex: number, count: number): void
        CopyTo(array: Array<string>, arrayIndex: number): void
        CopyTo(array: Array<string>): void
        Exists(match: (obj: string) => boolean): boolean
        Find(match: (obj: string) => boolean): string
        FindAll(match: (obj: string) => boolean): List<string>
        FindIndex(startIndex: number, count: number, match: (obj: string) => boolean): number
        FindIndex(startIndex: number, match: (obj: string) => boolean): number
        FindIndex(match: (obj: string) => boolean): number
        FindLast(match: (obj: string) => boolean): string
        FindLastIndex(startIndex: number, count: number, match: (obj: string) => boolean): number
        FindLastIndex(startIndex: number, match: (obj: string) => boolean): number
        FindLastIndex(match: (obj: string) => boolean): number
        ForEach(action: (obj: string) => void): void
        GetEnumerator(): any
        GetRange(index: number, count: number): List<string>
        IndexOf(item: string, index: number, count: number): number
        IndexOf(item: string, index: number): number
        IndexOf(item: string): number
        Insert(index: number, item: string): void
        InsertRange(index: number, collection: IEnumerable<string>): void
        LastIndexOf(item: string, index: number, count: number): number
        LastIndexOf(item: string, index: number): number
        LastIndexOf(item: string): number
        Remove(item: string): boolean
        RemoveAll(match: (obj: string) => boolean): number
        RemoveAt(index: number): void
        RemoveRange(index: number, count: number): void
        Reverse(index: number, count: number): void
        Reverse(): void
        Sort(index: number, count: number, comparer: any): void
        Sort(comparer: any): void
        Sort(comparison: (x: string, y: string) => number): void
        Sort(): void
        ToArray(): Array<string>
        TrimExcess(): void
        TrueForAll(match: (obj: string) => boolean): boolean
        Capacity: number
        readonly Count: number
    }
}
declare module "System.Collections.Generic" {
    import { GPathPoint } from "FairyGUI";
    interface IEnumerable_GPathPoint extends IEnumerable<GPathPoint> {
        GetEnumerator(): any
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { ValueType, Array, Object as Object1, Enum } from "System";
    import { List } from "System.Collections.Generic";
    /** Script interface for ParticleSystem. Unity's powerful and versatile particle system implementation.
     */
    class ParticleSystem extends Component {
        constructor()
        SetParticles(particles: Array<any>, size: number, offset: number): void
        SetParticles(particles: any, size: number, offset: number): void
        SetParticles(particles: Array<any>, size: number): void
        SetParticles(particles: any, size: number): void
        SetParticles(particles: Array<any>): void
        SetParticles(particles: any): void
        GetParticles(particles: Array<any>, size: number, offset: number): number
        GetParticles(particles: any, size: number, offset: number): number
        GetParticles(particles: Array<any>, size: number): number
        GetParticles(particles: any, size: number): number
        GetParticles(particles: Array<any>): number
        GetParticles(particles: any): number
        SetCustomParticleData(customData: any, streamIndex: any): void
        GetCustomParticleData(customData: any, streamIndex: any): number
        GetPlaybackState(): any
        SetPlaybackState(playbackState: any): void
        GetTrails(): any
        SetTrails(trailData: any): void
        /** Fast-forwards the Particle System by simulating particles over the given period of time, then pauses it.
         * @param t Time period in seconds to advance the ParticleSystem simulation by. If restart is true, the ParticleSystem will be reset to 0 time, and then advanced by this value. If restart is false, the ParticleSystem simulation will be advanced in time from its current state by this value.
         * @param withChildren Fast-forward all child Particle Systems as well.
         * @param restart Restart and start from the beginning.
         * @param fixedTimeStep Only update the system at fixed intervals, based on the value in "Fixed Time" in the Time options.
         */
        Simulate(t: number, withChildren: boolean, restart: boolean, fixedTimeStep: boolean): void
        /** Fast-forwards the Particle System by simulating particles over the given period of time, then pauses it.
         * @param t Time period in seconds to advance the ParticleSystem simulation by. If restart is true, the ParticleSystem will be reset to 0 time, and then advanced by this value. If restart is false, the ParticleSystem simulation will be advanced in time from its current state by this value.
         * @param withChildren Fast-forward all child Particle Systems as well.
         * @param restart Restart and start from the beginning.
         * @param fixedTimeStep Only update the system at fixed intervals, based on the value in "Fixed Time" in the Time options.
         */
        Simulate(t: number, withChildren: boolean, restart: boolean): void
        /** Fast-forwards the Particle System by simulating particles over the given period of time, then pauses it.
         * @param t Time period in seconds to advance the ParticleSystem simulation by. If restart is true, the ParticleSystem will be reset to 0 time, and then advanced by this value. If restart is false, the ParticleSystem simulation will be advanced in time from its current state by this value.
         * @param withChildren Fast-forward all child Particle Systems as well.
         * @param restart Restart and start from the beginning.
         * @param fixedTimeStep Only update the system at fixed intervals, based on the value in "Fixed Time" in the Time options.
         */
        Simulate(t: number, withChildren: boolean): void
        /** Fast-forwards the Particle System by simulating particles over the given period of time, then pauses it.
         * @param t Time period in seconds to advance the ParticleSystem simulation by. If restart is true, the ParticleSystem will be reset to 0 time, and then advanced by this value. If restart is false, the ParticleSystem simulation will be advanced in time from its current state by this value.
         * @param withChildren Fast-forward all child Particle Systems as well.
         * @param restart Restart and start from the beginning.
         * @param fixedTimeStep Only update the system at fixed intervals, based on the value in "Fixed Time" in the Time options.
         */
        Simulate(t: number): void
        /** Starts the Particle System.
         * @param withChildren Play all child Particle Systems as well.
         */
        Play(withChildren: boolean): void
        Play(): void
        /** Pauses the system so no new particles are emitted and the existing particles are not updated.
         * @param withChildren Pause all child Particle Systems as well.
         */
        Pause(withChildren: boolean): void
        Pause(): void
        /** Stops playing the Particle System using the supplied stop behaviour.
         * @param withChildren Stop all child Particle Systems as well.
         * @param stopBehavior Stop emitting or stop emitting and clear the system.
         */
        Stop(withChildren: boolean, stopBehavior: any): void
        /** Stops playing the Particle System using the supplied stop behaviour.
         * @param withChildren Stop all child Particle Systems as well.
         * @param stopBehavior Stop emitting or stop emitting and clear the system.
         */
        Stop(withChildren: boolean): void
        Stop(): void
        /** Remove all particles in the Particle System.
         * @param withChildren Clear all child Particle Systems as well.
         */
        Clear(withChildren: boolean): void
        Clear(): void
        /** Does the Particle System contain any live particles, or will it produce more?
         * @param withChildren Check all child Particle Systems as well.
         * @returns True if the Particle System contains live particles or is still creating new particles. False if the Particle System has stopped emitting particles and all particles are dead. 
         */
        IsAlive(withChildren: boolean): boolean
        IsAlive(): boolean
        Emit(emitParams: any, count: number): void
        /** Emit count particles immediately.
         * @param count Number of particles to emit.
         */
        Emit(count: number): void
        TriggerSubEmitter(subEmitterIndex: number, particle: jsb.Ref<any>): void
        TriggerSubEmitter(subEmitterIndex: number, particles: any): void
        /** Triggers the specified sub emitter on all particles of the Particle System.
         * @param subEmitterIndex Index of the sub emitter to trigger.
         */
        TriggerSubEmitter(subEmitterIndex: number): void
        /** Safe array size for use with ParticleSystem.GetCollisionEvents.
         */
        GetSafeCollisionEventSize(): number
        GetCollisionEvents(go: GameObject, collisionEvents: any): number
        /** Safe array size for use with ParticleSystem.GetTriggerParticles.
         * @param ps Particle system.
         * @param type Type of trigger to return size for.
         * @returns Number of particles with this trigger event type. 
         */
        GetSafeTriggerParticlesSize(type: any): number
        GetTriggerParticles(type: any, particles: any): number
        SetTriggerParticles(type: any, particles: any, offset: number, count: number): void
        SetTriggerParticles(type: any, particles: any): void
        static ResetPreMappedBufferMemory(): void
        /** Limits the amount of graphics memory Unity reserves for efficient rendering of Particle Systems.
         * @param vertexBuffersCount The maximum number of cached vertex buffers.
         * @param indexBuffersCount The maximum number of cached index buffers.
         */
        static SetMaximumPreMappedBufferCounts(vertexBuffersCount: number, indexBuffersCount: number): void
        /** Determines whether the Particle System is playing.
         */
        readonly isPlaying: boolean
        /** Determines whether the Particle System is emitting particles. A Particle System may stop emitting when its emission module has finished, it has been paused or if the system has been stopped using ParticleSystem.Stop|Stop with the ParticleSystemStopBehavior.StopEmitting|StopEmitting flag. Resume emitting by calling ParticleSystem.Play|Play.
         */
        readonly isEmitting: boolean
        /** Determines whether the Particle System is in the stopped state.
         */
        readonly isStopped: boolean
        /** Determines whether the Particle System is paused.
         */
        readonly isPaused: boolean
        /** The current number of particles (Read Only).
         */
        readonly particleCount: number
        /** Playback position in seconds.
         */
        time: number
        /** Override the random seed used for the Particle System emission.
         */
        randomSeed: number
        /** Controls whether the Particle System uses an automatically-generated random number to seed the random number generator.
         */
        useAutoRandomSeed: boolean
        /** Does this system support Procedural Simulation?
         */
        readonly proceduralSimulationSupported: boolean
        /** Access the main Particle System settings.
         */
        readonly main: ParticleSystem.MainModule
        /** Script interface for the EmissionModule of a Particle System.
         */
        readonly emission: any
        /** Script interface for the ShapeModule of a Particle System. 
         */
        readonly shape: any
        /** Script interface for the VelocityOverLifetimeModule of a Particle System.
         */
        readonly velocityOverLifetime: any
        /** Script interface for the LimitVelocityOverLifetimeModule of a Particle System. .
         */
        readonly limitVelocityOverLifetime: any
        /** Script interface for the InheritVelocityModule of a Particle System.
         */
        readonly inheritVelocity: any
        /** Script interface for the ForceOverLifetimeModule of a Particle System.
         */
        readonly forceOverLifetime: any
        /** Script interface for the ColorOverLifetimeModule of a Particle System.
         */
        readonly colorOverLifetime: any
        /** Script interface for the ColorByLifetimeModule of a Particle System.
         */
        readonly colorBySpeed: any
        /** Script interface for the SizeOverLifetimeModule of a Particle System. 
         */
        readonly sizeOverLifetime: any
        /** Script interface for the SizeBySpeedModule of a Particle System.
         */
        readonly sizeBySpeed: any
        /** Script interface for the RotationOverLifetimeModule of a Particle System.
         */
        readonly rotationOverLifetime: any
        /** Script interface for the RotationBySpeedModule of a Particle System.
         */
        readonly rotationBySpeed: any
        /** Script interface for the ExternalForcesModule of a Particle System.
         */
        readonly externalForces: any
        /** Script interface for the NoiseModule of a Particle System.
         */
        readonly noise: any
        /** Script interface for the CollisionModule of a Particle System.
         */
        readonly collision: any
        /** Script interface for the TriggerModule of a Particle System.
         */
        readonly trigger: any
        /** Script interface for the SubEmittersModule of a Particle System.
         */
        readonly subEmitters: any
        /** Script interface for the TextureSheetAnimationModule of a Particle System.
         */
        readonly textureSheetAnimation: any
        /** Script interface for the LightsModule of a Particle System.
         */
        readonly lights: any
        /** Script interface for the TrailsModule of a Particle System.
         */
        readonly trails: any
        /** Script interface for the CustomDataModule of a Particle System.
         */
        readonly customData: any
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Enum, Array, Object as Object1 } from "System";
    import { List } from "System.Collections.Generic";
    /** Use this class to render particles on to the screen.
     */
    class ParticleSystemRenderer extends Renderer {
        constructor()
        /** Get the array of Meshes to be used as particles.
         * @param meshes This array is populated with the list of Meshes being used for particle rendering.
         * @returns The number of Meshes actually written to the destination array. 
         */
        GetMeshes(meshes: Array<any>): number
        /** Set an array of Meshes to use as particles when the ParticleSystemRenderer.renderMode is set to ParticleSystemRenderMode.Mesh.
         * @param meshes Array of Meshes to use.
         * @param size Number of elements from the Mesh array to apply.
         */
        SetMeshes(meshes: Array<any>, size: number): void
        /** Set an array of Meshes to use as particles when the ParticleSystemRenderer.renderMode is set to ParticleSystemRenderMode.Mesh.
         * @param meshes Array of Meshes to use.
         * @param size Number of elements from the Mesh array to apply.
         */
        SetMeshes(meshes: Array<any>): void
        /** Creates a snapshot of ParticleSystemRenderer and stores it in mesh.
         * @param mesh A static Mesh to receive the snapshot of the particles.
         * @param camera The Camera used to determine which way camera-space particles face.
         * @param useTransform Specifies whether to include the rotation and scale of the Transform in the baked Mesh.
         */
        BakeMesh(mesh: any, camera: Camera, useTransform: boolean): void
        /** Creates a snapshot of ParticleSystemRenderer and stores it in mesh.
         * @param mesh A static Mesh to receive the snapshot of the particles.
         * @param camera The Camera used to determine which way camera-space particles face.
         * @param useTransform Specifies whether to include the rotation and scale of the Transform in the baked Mesh.
         */
        BakeMesh(mesh: any, useTransform: boolean): void
        /** Creates a snapshot of ParticleSystem Trails and stores them in mesh.
         * @param mesh A static Mesh to receive the snapshot of the particle trails.
         * @param camera The Camera used to determine which way camera-space trails face.
         * @param useTransform Specifies whether to include the rotation and scale of the Transform in the baked Mesh.
         */
        BakeTrailsMesh(mesh: any, camera: Camera, useTransform: boolean): void
        /** Creates a snapshot of ParticleSystem Trails and stores them in mesh.
         * @param mesh A static Mesh to receive the snapshot of the particle trails.
         * @param camera The Camera used to determine which way camera-space trails face.
         * @param useTransform Specifies whether to include the rotation and scale of the Transform in the baked Mesh.
         */
        BakeTrailsMesh(mesh: any, useTransform: boolean): void
        SetActiveVertexStreams(streams: any): void
        GetActiveVertexStreams(streams: any): void
        /** Control the direction that particles face.
         */
        alignment: any
        /** Specifies how the system draws particles.
         */
        renderMode: any
        /** Specifies how to sort particles within a system.
         */
        sortMode: any
        /** How much are the particles stretched in their direction of motion.
         */
        lengthScale: number
        /** Specifies how much particles stretch depending on their velocity.
         */
        velocityScale: number
        /** How much do the particles stretch depending on the Camera's speed.
         */
        cameraVelocityScale: number
        /** Specifies how much a billboard particle orients its normals towards the Camera.
         */
        normalDirection: number
        /** Apply a shadow bias to prevent self-shadowing artifacts. The specified value is the proportion of the particle size.
         */
        shadowBias: number
        /** Biases Particle System sorting amongst other transparencies.
         */
        sortingFudge: number
        /** Clamp the minimum particle size.
         */
        minParticleSize: number
        /** Clamp the maximum particle size.
         */
        maxParticleSize: number
        /** Modify the pivot point used for rotating particles.
         */
        pivot: Vector3
        /** Flip a percentage of the particles, along each axis.
         */
        flip: Vector3
        /** Specifies how the Particle System Renderer interacts with SpriteMask.
         */
        maskInteraction: any
        /** Set the Material that the TrailModule uses to attach trails to particles.
         */
        trailMaterial: Material
        /** Enables GPU Instancing on platforms that support it.
         */
        enableGPUInstancing: boolean
        /** Allow billboard particles to roll around their z-axis.
         */
        allowRoll: boolean
        /** The Mesh that the particle uses instead of a billboarded Texture.
         */
        mesh: any
        /** The number of Meshes the system uses for particle rendering.
         */
        readonly meshCount: number
        /** The number of currently active custom vertex streams.
         */
        readonly activeVertexStreamsCount: number
        /** Determines whether the Particle System can be rendered using GPU Instancing.
         */
        readonly supportsMeshInstancing: boolean
    }
}
declare module "UnityEngine" {
    import { ValueType, Enum } from "System";
    namespace ParticleSystem {
        class MainModule extends ValueType {
            constructor()
            duration: number
            loop: boolean
            prewarm: boolean
            startDelay: any
            startDelayMultiplier: number
            startLifetime: any
            startLifetimeMultiplier: number
            startSpeed: any
            startSpeedMultiplier: number
            startSize3D: boolean
            startSize: any
            startSizeMultiplier: number
            startSizeX: any
            startSizeXMultiplier: number
            startSizeY: any
            startSizeYMultiplier: number
            startSizeZ: any
            startSizeZMultiplier: number
            startRotation3D: boolean
            startRotation: any
            startRotationMultiplier: number
            startRotationX: any
            startRotationXMultiplier: number
            startRotationY: any
            startRotationYMultiplier: number
            startRotationZ: any
            startRotationZMultiplier: number
            flipRotation: number
            startColor: any
            gravityModifier: any
            gravityModifierMultiplier: number
            simulationSpace: ParticleSystemSimulationSpace
            customSimulationSpace: Transform
            simulationSpeed: number
            useUnscaledTime: boolean
            scalingMode: any
            playOnAwake: boolean
            maxParticles: number
            emitterVelocityMode: any
            stopAction: any
            ringBufferMode: any
            ringBufferLoopRange: Vector2
            cullingMode: any
        }
    }
}
declare module "UnityEngine" {
    import { Enum } from "System";
    /** The space to simulate particles in.
     */
    enum ParticleSystemSimulationSpace {
        /** Simulate particles in local space.
         */
        Local = 0,
        /** Simulate particles in world space.
         */
        World = 1,
        /** Simulate particles relative to a custom transform component, defined by ParticleSystem.MainModule.customSimulationSpace.
         */
        Custom = 2,
    }
}
declare module "System.Net" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    class IPHostEntry extends Object {
        constructor()
        HostName: string
        Aliases: Array<string>
        AddressList: Array<any>
    }
}
declare module "System" {
    import * as jsb from "jsb";
    class DateTime extends ValueType {
        constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, calendar: any, kind: any)
        constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, kind: any)
        constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, calendar: any)
        constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, kind: any)
        constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, calendar: any)
        constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number)
        constructor(year: number, month: number, day: number, hour: number, minute: number, second: number)
        constructor(year: number, month: number, day: number, calendar: any)
        constructor(year: number, month: number, day: number)
        constructor(ticks: number, kind: any)
        constructor(ticks: number)
        Add(value: any): DateTime
        AddDays(value: number): DateTime
        AddHours(value: number): DateTime
        AddMilliseconds(value: number): DateTime
        AddMinutes(value: number): DateTime
        AddMonths(months: number): DateTime
        AddSeconds(value: number): DateTime
        AddTicks(value: number): DateTime
        AddYears(value: number): DateTime
        CompareTo(value: Object): number
        CompareTo(value: DateTime): number
        Equals(value: Object): boolean
        Equals(value: DateTime): boolean
        IsDaylightSavingTime(): boolean
        ToBinary(): number
        GetHashCode(): number
        Subtract(value: DateTime): any
        Subtract(value: any): DateTime
        ToOADate(): number
        ToFileTime(): number
        ToFileTimeUtc(): number
        ToLocalTime(): DateTime
        ToLongDateString(): string
        ToLongTimeString(): string
        ToShortDateString(): string
        ToShortTimeString(): string
        toString(format: string, provider: any): string
        toString(format: string): string
        toString(provider: any): string
        toString(): string
        ToUniversalTime(): DateTime
        GetDateTimeFormats(format: string, provider: any): Array<string>
        GetDateTimeFormats(provider: any): Array<string>
        GetDateTimeFormats(format: string): Array<string>
        GetDateTimeFormats(): Array<string>
        GetTypeCode(): any
        static Compare(t1: DateTime, t2: DateTime): number
        static DaysInMonth(year: number, month: number): number
        static Equals(t1: DateTime, t2: DateTime): boolean
        static FromBinary(dateData: number): DateTime
        static FromFileTime(fileTime: number): DateTime
        static FromFileTimeUtc(fileTime: number): DateTime
        static FromOADate(d: number): DateTime
        static SpecifyKind(value: DateTime, kind: any): DateTime
        static IsLeapYear(year: number): boolean
        static Parse(s: string, provider: any, styles: any): DateTime
        static Parse(s: string, provider: any): DateTime
        static Parse(s: string): DateTime
        static ParseExact(s: string, format: string, provider: any, style: any): DateTime
        static ParseExact(s: string, formats: Array<string>, provider: any, style: any): DateTime
        static ParseExact(s: string, format: string, provider: any): DateTime
        static TryParse(s: string, provider: any, styles: any, result: jsb.Out<DateTime>): boolean
        static TryParse(s: string, result: jsb.Out<DateTime>): boolean
        static TryParseExact(s: string, format: string, provider: any, style: any, result: jsb.Out<DateTime>): boolean
        static TryParseExact(s: string, formats: Array<string>, provider: any, style: any, result: jsb.Out<DateTime>): boolean
        static op_Addition(d: DateTime, t: any): DateTime
        static op_Subtraction(d: DateTime, t: any): DateTime
        static op_Subtraction(d1: DateTime, d2: DateTime): any
        static op_Equality(d1: DateTime, d2: DateTime): boolean
        static op_Inequality(d1: DateTime, d2: DateTime): boolean
        static op_LessThan(t1: DateTime, t2: DateTime): boolean
        static op_LessThanOrEqual(t1: DateTime, t2: DateTime): boolean
        static op_GreaterThan(t1: DateTime, t2: DateTime): boolean
        static op_GreaterThanOrEqual(t1: DateTime, t2: DateTime): boolean
        readonly Date: DateTime
        readonly Day: number
        readonly DayOfWeek: any
        readonly DayOfYear: number
        readonly Hour: number
        readonly Kind: any
        readonly Millisecond: number
        readonly Minute: number
        readonly Month: number
        static readonly Now: DateTime
        static readonly UtcNow: DateTime
        readonly Second: number
        readonly Ticks: number
        readonly TimeOfDay: any
        static readonly Today: DateTime
        readonly Year: number
        static readonly MinValue: DateTime
        static readonly MaxValue: DateTime
    }
}
declare module "System.IO" {
    import { Object, Enum } from "System";
    class FileInfo extends Object {
        constructor(fileName: string)
        OpenText(): any
        CreateText(): any
        AppendText(): any
        CopyTo(destFileName: string, overwrite: boolean): FileInfo
        CopyTo(destFileName: string): FileInfo
        Create(): any
        Delete(): void
        Decrypt(): void
        Encrypt(): void
        Open(mode: any, access: any, share: any): any
        Open(mode: any, access: any): any
        Open(mode: any): any
        OpenRead(): any
        OpenWrite(): any
        MoveTo(destFileName: string): void
        Replace(destinationFileName: string, destinationBackupFileName: string, ignoreMetadataErrors: boolean): FileInfo
        Replace(destinationFileName: string, destinationBackupFileName: string): FileInfo
        toString(): string
        readonly Name: string
        readonly Length: number
        readonly DirectoryName: string
        readonly Directory: any
        IsReadOnly: boolean
        readonly Exists: boolean
    }
}
declare module "System.IO" {
    import * as jsb from "jsb";
    import { Object, Enum, DateTime, Array } from "System";
    import { IEnumerable } from "System.Collections.Generic";
    abstract class File extends Object {
        static AppendAllText(path: string, contents: string, encoding: any): void
        static AppendAllText(path: string, contents: string): void
        static AppendText(path: string): any
        static Copy(sourceFileName: string, destFileName: string, overwrite: boolean): void
        static Copy(sourceFileName: string, destFileName: string): void
        static Create(path: string, bufferSize: number, options: any): any
        static Create(path: string, bufferSize: number): any
        static Create(path: string): any
        static CreateText(path: string): any
        static Delete(path: string): void
        static Exists(path: string): boolean
        static GetAttributes(path: string): any
        static GetCreationTime(path: string): DateTime
        static GetCreationTimeUtc(path: string): DateTime
        static GetLastAccessTime(path: string): DateTime
        static GetLastAccessTimeUtc(path: string): DateTime
        static GetLastWriteTime(path: string): DateTime
        static GetLastWriteTimeUtc(path: string): DateTime
        static Move(sourceFileName: string, destFileName: string): void
        static Open(path: string, mode: any, access: any): any
        static Open(path: string, mode: any): any
        static OpenRead(path: string): any
        static OpenText(path: string): any
        static OpenWrite(path: string): any
        static Replace(sourceFileName: string, destinationFileName: string, destinationBackupFileName: string): void
        static SetAttributes(path: string, fileAttributes: any): void
        static SetCreationTime(path: string, creationTime: DateTime): void
        static SetCreationTimeUtc(path: string, creationTimeUtc: DateTime): void
        static SetLastAccessTime(path: string, lastAccessTime: DateTime): void
        static SetLastAccessTimeUtc(path: string, lastAccessTimeUtc: DateTime): void
        static SetLastWriteTime(path: string, lastWriteTime: DateTime): void
        static SetLastWriteTimeUtc(path: string, lastWriteTimeUtc: DateTime): void
        static ReadAllBytes(path: string): Array<jsb.byte>
        static ReadAllLines(path: string, encoding: any): Array<string>
        static ReadAllLines(path: string): Array<string>
        static ReadAllText(path: string, encoding: any): string
        static ReadAllText(path: string): string
        static WriteAllBytes(path: string, bytes: Array<jsb.byte>): void
        static WriteAllLines(path: string, contents: Array<string>, encoding: any): void
        static WriteAllLines(path: string, contents: IEnumerable<string>, encoding: any): void
        static WriteAllLines(path: string, contents: Array<string>): void
        static WriteAllLines(path: string, contents: IEnumerable<string>): void
        static WriteAllText(path: string, contents: string, encoding: any): void
        static WriteAllText(path: string, contents: string): void
        static Encrypt(path: string): void
        static Decrypt(path: string): void
        static ReadLines(path: string, encoding: any): IEnumerable<string>
        static ReadLines(path: string): IEnumerable<string>
        static AppendAllLines(path: string, contents: IEnumerable<string>, encoding: any): void
        static AppendAllLines(path: string, contents: IEnumerable<string>): void
    }
}
declare module "global" {
    import { Object } from "System";
    class TWrapper_Int32 extends Object implements TWrapper<number> {
        constructor(obj: number)
        GetValue(): number
        SetValue(obj: number): void
        static GetIntWrapper(): TWrapper<number>
    }
}
declare module "global" {
    import { Object } from "System";
    class TWrapper<T> extends Object {
        GetValue(): T
        SetValue(obj: T): void
    }
}
declare module "global" {
    import { Object } from "System";
    import { Vector3 } from "UnityEngine";
    class TWrapper_Vector3 extends Object implements TWrapper<Vector3> {
        constructor(obj: Vector3)
        GetValue(): Vector3
        SetValue(obj: Vector3): void
        static GetIntWrapper(): TWrapper<number>
    }
}
declare module "Example" {
    import { Object } from "System";
    class DisposableObject extends Object {
        constructor()
        Dispose(): void
        static CreateDisposableObject(): DisposableObject
    }
}
declare module "global" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    class HotfixTest2 extends Object {
        constructor()
        CallByRef(v: jsb.Out<number>): void
        Foo(x: number): number
    }
}
declare module "global" {
    interface MyInterface {
        Foo(): void
    }
}
declare module "global" {
    import { Object } from "System";
    class MyClass extends Object implements MyInterface {
        constructor()
        Foo(): void
        static GetMyInterface(): MyInterface
    }
}
declare module "global" {
    import * as jsb from "jsb";
    import { Vector3, Vector2 } from "UnityEngine";
    import { Array, ValueType } from "System";
    class NoNamespaceClass extends NoNamespaceBase {
        constructor()
        static V1(v: Vector3): void
        static V1(v: Vector2): void
        static Moo(): void
        static MakeBytes(): Array<jsb.byte>
        static TestBytes(test: Array<jsb.byte>): Array<jsb.byte>
        static TestOut(x: jsb.Out<number>, y: number, z: jsb.Out<number>): void
        static TestOut(x: jsb.Out<string>, y: number, z: jsb.Out<string>): void
        static TestRefOut(g: jsb.Ref<number>, x: jsb.Out<number>, y: number, z: jsb.Out<number>): void
        static TestNullable(x: jsb.Nullable<number>, y: jsb.Nullable<number>): jsb.Nullable<number>
        static TestNullable(xy: jsb.Nullable<Vector2>, g: jsb.Ref<jsb.Nullable<number>>): jsb.Nullable<number>
        static TestNullable(xy: jsb.Nullable<Vector2>): jsb.Nullable<number>
    }
}
declare module "global" {
    import { Object } from "System";
    class NoNamespaceBase extends Object {
        constructor()
    }
}
declare module "global" {
    import { MonoBehaviour } from "UnityEngine";
    import { Object } from "System";
    class SampleBehaviour extends MonoBehaviour {
        constructor()
        SimpleWait(t: number): Promise<string>
        AnotherWait(t: number): Promise<any>
        PrimitiveCall(a: string, b: number): void
    }
}
declare module "Example" {
    import { Object } from "System";
    class AsyncTaskTest extends Object {
        constructor()
        static GetHostEntryAsync(host: string): any
        static SimpleTest(ms: number): any
    }
}
declare module "Example" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    class DelegateTest extends Object {
        constructor()
        TestComplexCall(): void
        AddAction(): void
        DipatchEvent(v: number): void
        CallAction(): void
        CallActionWithArgs(a1: string, a2: number, a3: number): void
        CallFunc(a1: number): number
        static DipatchStaticEvent(v: number): void
        static GetNotExportedClass(): any
        static CallStaticActionWithArgs(a1: string, a2: number, a3: number): void
        static CallHotfixTest(): void
        static GetArray(): Array<DelegateTest.InnerTest>
        onEvent(op: "add" | "remove", fn: (id: number) => void): void
        static onStaticEvent(op: "add" | "remove", fn: (id: number) => void): void
        complexCall(op: "get"): (b: number, a: jsb.Ref<number>, v: jsb.Out<number>) => number
        complexCall(op: "add" | "remove" | "set", fn?: (b: number, a: jsb.Ref<number>, v: jsb.Out<number>) => number): void
        complexCall(op: "add" | "remove" | "set" | "get", fn?: (b: number, a: jsb.Ref<number>, v: jsb.Out<number>) => number): (b: number, a: jsb.Ref<number>, v: jsb.Out<number>) => number | void
        actionFieldRW(op: "get"): () => void
        actionFieldRW(op: "add" | "remove" | "set", fn?: () => void): void
        actionFieldRW(op: "add" | "remove" | "set" | "get", fn?: () => void): () => void | void
        actionFieldR(op: "get"): () => void
        static actionFieldRW_s(op: "get"): () => void
        static actionFieldRW_s(op: "add" | "remove" | "set", fn?: () => void): void
        static actionFieldRW_s(op: "add" | "remove" | "set" | "get", fn?: () => void): () => void | void
        static actionFieldR_s(op: "get"): () => void
        onAction(op: "get"): () => void
        onAction(op: "add" | "remove" | "set", fn?: () => void): void
        onAction(op: "add" | "remove" | "set" | "get", fn?: () => void): () => void | void
        onActionWithArgs(op: "get"): (arg1: string, arg2: number, arg3: number) => void
        onActionWithArgs(op: "add" | "remove" | "set", fn?: (arg1: string, arg2: number, arg3: number) => void): void
        onActionWithArgs(op: "add" | "remove" | "set" | "get", fn?: (arg1: string, arg2: number, arg3: number) => void): (arg1: string, arg2: number, arg3: number) => void | void
        static onStaticActionWithArgs(op: "get"): (arg1: string, arg2: number, arg3: number) => void
        static onStaticActionWithArgs(op: "add" | "remove" | "set", fn?: (arg1: string, arg2: number, arg3: number) => void): void
        static onStaticActionWithArgs(op: "add" | "remove" | "set" | "get", fn?: (arg1: string, arg2: number, arg3: number) => void): (arg1: string, arg2: number, arg3: number) => void | void
        onFunc(op: "get"): (arg: number) => number
        onFunc(op: "add" | "remove" | "set", fn?: (arg: number) => number): void
        onFunc(op: "add" | "remove" | "set" | "get", fn?: (arg: number) => number): (arg: number) => number | void
        actionPropG(op: "get"): () => void
        actionPropS(op: "set", fn: () => void)
        actionPropGS(op: "get"): () => void
        actionPropGS(op: "add" | "remove" | "set", fn?: () => void): void
        actionPropGS(op: "add" | "remove" | "set" | "get", fn?: () => void): () => void | void
        static actionPropG_s(op: "get"): () => void
        static actionPropS_s(op: "set", fn: () => void)
        static actionPropGS_s(op: "get"): () => void
        static actionPropGS_s(op: "add" | "remove" | "set", fn?: () => void): void
        static actionPropGS_s(op: "add" | "remove" | "set" | "get", fn?: () => void): () => void | void
    }
}
declare module "Example" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    abstract class NativeFileUtil extends Object {
        static ReadAllText(path: string): string
        static ReadAllBytes(path: string): Array<jsb.byte>
    }
}
declare module "Example" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { GameObject } from "UnityEngine";
    class ValueTest extends Object {
        constructor()
        static TakeStringWithCache(v: string): void
        static TakeString(v: string): void
        static Foo(v: string): string
        static CheckArgs(a: number, b: jsb.Out<number>, c: jsb.Ref<string>): boolean
        static CheckArgs(a: number, b: jsb.Out<number>, c: jsb.Ref<GameObject>): boolean
        static MakeTrouble(): void
        static values1: Array<number>
        static values2: Array<number, 2>
    }
}
declare module "Example.New.World" {
    import { Object } from "System";
    class Galaxy extends Object {
        constructor()
        static GetName(): string
    }
}
declare module "Example" {
    import { Object } from "System";
    namespace DelegateTest {
        class InnerTest extends Object {
            constructor()
            static readonly hello: string
        }
    }
}
declare module "Example.New.World" {
    import { Object } from "System";
    namespace Galaxy {
        class Sun extends Object {
            constructor()
            static GetName(): string
        }
    }
}
declare module "Example.New.World" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    namespace Galaxy {
        class Earth extends Object {
            constructor()
            GetSun(): Galaxy.Sun
            GetContinents(): Array<Galaxy.Earth.Continent>
            static GetName(): string
        }
    }
}
declare module "Example.New.World" {
    import { Object } from "System";
    namespace Galaxy.Earth {
        class Ocean extends Object {
            constructor()
            static GetName(): string
        }
    }
}
declare module "Example.New.World" {
    import { Object } from "System";
    namespace Galaxy.Earth {
        class Continent extends Object {
            constructor()
            static GetName(): string
        }
    }
}
declare module "System" {
    import * as jsb from "jsb";
    class Byte extends ValueType {
        CompareTo(value: Object): number
        CompareTo(value: jsb.byte): number
        Equals(obj: Object): boolean
        Equals(obj: jsb.byte): boolean
        GetHashCode(): number
        toString(format: string, provider: any): string
        toString(format: string): string
        toString(provider: any): string
        toString(): string
        GetTypeCode(): any
        static Parse(s: string, style: any, provider: any): jsb.byte
        static Parse(s: string, style: any): jsb.byte
        static Parse(s: string, provider: any): jsb.byte
        static Parse(s: string): jsb.byte
        static TryParse(s: string, style: any, provider: any, result: jsb.Out<jsb.byte>): boolean
        static TryParse(s: string, result: jsb.Out<jsb.byte>): boolean
        protected constructor()
        static readonly MaxValue: jsb.byte
        static readonly MinValue: jsb.byte
    }
}
declare module "System" {
    import * as jsb from "jsb";
    class SByte extends ValueType {
        CompareTo(obj: Object): number
        CompareTo(value: number): number
        Equals(obj: Object): boolean
        Equals(obj: number): boolean
        GetHashCode(): number
        toString(format: string, provider: any): string
        toString(provider: any): string
        toString(format: string): string
        toString(): string
        GetTypeCode(): any
        static Parse(s: string, style: any, provider: any): number
        static Parse(s: string, style: any): number
        static Parse(s: string, provider: any): number
        static Parse(s: string): number
        static TryParse(s: string, style: any, provider: any, result: jsb.Out<number>): boolean
        static TryParse(s: string, result: jsb.Out<number>): boolean
        protected constructor()
        static readonly MaxValue: number
        static readonly MinValue: number
    }
}
declare module "System" {
    import * as jsb from "jsb";
    class Single extends ValueType {
        CompareTo(value: Object): number
        CompareTo(value: number): number
        Equals(obj: Object): boolean
        Equals(obj: number): boolean
        GetHashCode(): number
        toString(format: string, provider: any): string
        toString(provider: any): string
        toString(format: string): string
        toString(): string
        GetTypeCode(): any
        static IsInfinity(f: number): boolean
        static IsPositiveInfinity(f: number): boolean
        static IsNegativeInfinity(f: number): boolean
        static IsNaN(f: number): boolean
        static op_Inequality(left: number, right: number): boolean
        static op_GreaterThan(left: number, right: number): boolean
        static op_LessThanOrEqual(left: number, right: number): boolean
        static op_GreaterThanOrEqual(left: number, right: number): boolean
        static Parse(s: string, style: any, provider: any): number
        static Parse(s: string, style: any): number
        static Parse(s: string, provider: any): number
        static Parse(s: string): number
        static TryParse(s: string, style: any, provider: any, result: jsb.Out<number>): boolean
        static TryParse(s: string, result: jsb.Out<number>): boolean
        // js_op_overloading: static ==(left: number, right: number): boolean
        // js_op_overloading: static <(left: number, right: number): boolean
        protected constructor()
        static readonly MinValue: number
        static readonly Epsilon: number
        static readonly MaxValue: number
        static readonly PositiveInfinity: number
        static readonly NegativeInfinity: number
        static readonly NaN: number
    }
}
declare module "System" {
    import * as jsb from "jsb";
    class Double extends ValueType {
        CompareTo(value: Object): number
        CompareTo(value: number): number
        Equals(obj: Object): boolean
        Equals(obj: number): boolean
        GetHashCode(): number
        toString(format: string, provider: any): string
        toString(format: string): string
        toString(provider: any): string
        toString(): string
        GetTypeCode(): any
        static IsInfinity(d: number): boolean
        static IsPositiveInfinity(d: number): boolean
        static IsNegativeInfinity(d: number): boolean
        static IsNaN(d: number): boolean
        static op_Inequality(left: number, right: number): boolean
        static op_GreaterThan(left: number, right: number): boolean
        static op_LessThanOrEqual(left: number, right: number): boolean
        static op_GreaterThanOrEqual(left: number, right: number): boolean
        static Parse(s: string, style: any, provider: any): number
        static Parse(s: string, style: any): number
        static Parse(s: string, provider: any): number
        static Parse(s: string): number
        static TryParse(s: string, style: any, provider: any, result: jsb.Out<number>): boolean
        static TryParse(s: string, result: jsb.Out<number>): boolean
        // js_op_overloading: static ==(left: number, right: number): boolean
        // js_op_overloading: static <(left: number, right: number): boolean
        protected constructor()
        static readonly MinValue: number
        static readonly MaxValue: number
        static readonly Epsilon: number
        static readonly NegativeInfinity: number
        static readonly PositiveInfinity: number
        static readonly NaN: number
    }
}
declare module "System" {
    import * as jsb from "jsb";
    import { IEnumerable } from "System.Collections.Generic";
    class String extends Object {
        constructor(value: Array<string>, startIndex: number, length: number)
        constructor(c: string, count: number)
        constructor(value: Array<string>)
        Equals(value: string, comparisonType: any): boolean
        Equals(obj: Object): boolean
        Equals(value: string): boolean
        CopyTo(sourceIndex: number, destination: Array<string>, destinationIndex: number, count: number): void
        ToCharArray(startIndex: number, length: number): Array<string>
        ToCharArray(): Array<string>
        GetHashCode(): number
        Split(separator: Array<string>, count: number, options: any): Array<string>
        Split(separator: Array<string>, count: number, options: any): Array<string>
        Split(separator: Array<string>, count: number): Array<string>
        Split(separator: Array<string>, options: any): Array<string>
        Split(separator: Array<string>, options: any): Array<string>
        Split(...separator: string[]): Array<string>
        Substring(startIndex: number, length: number): string
        Substring(startIndex: number): string
        Trim(): string
        Trim(...trimChars: string[]): string
        TrimStart(...trimChars: string[]): string
        TrimEnd(...trimChars: string[]): string
        IsNormalized(normalizationForm: any): boolean
        IsNormalized(): boolean
        Normalize(normalizationForm: any): string
        Normalize(): string
        CompareTo(value: Object): number
        CompareTo(strB: string): number
        Contains(value: string): boolean
        EndsWith(value: string, ignoreCase: boolean, culture: any): boolean
        EndsWith(value: string, comparisonType: any): boolean
        EndsWith(value: string): boolean
        IndexOf(value: string, startIndex: number, count: number, comparisonType: any): number
        IndexOf(value: string, startIndex: number, count: number): number
        IndexOf(value: string, startIndex: number, comparisonType: any): number
        IndexOf(value: string, startIndex: number, count: number): number
        IndexOf(value: string, startIndex: number): number
        IndexOf(value: string, startIndex: number): number
        IndexOf(value: string, comparisonType: any): number
        IndexOf(value: string): number
        IndexOf(value: string): number
        IndexOfAny(anyOf: Array<string>, startIndex: number, count: number): number
        IndexOfAny(anyOf: Array<string>, startIndex: number): number
        IndexOfAny(anyOf: Array<string>): number
        LastIndexOf(value: string, startIndex: number, count: number, comparisonType: any): number
        LastIndexOf(value: string, startIndex: number, count: number): number
        LastIndexOf(value: string, startIndex: number, comparisonType: any): number
        LastIndexOf(value: string, startIndex: number, count: number): number
        LastIndexOf(value: string, startIndex: number): number
        LastIndexOf(value: string, startIndex: number): number
        LastIndexOf(value: string, comparisonType: any): number
        LastIndexOf(value: string): number
        LastIndexOf(value: string): number
        LastIndexOfAny(anyOf: Array<string>, startIndex: number, count: number): number
        LastIndexOfAny(anyOf: Array<string>, startIndex: number): number
        LastIndexOfAny(anyOf: Array<string>): number
        PadLeft(totalWidth: number, paddingChar: string): string
        PadLeft(totalWidth: number): string
        PadRight(totalWidth: number, paddingChar: string): string
        PadRight(totalWidth: number): string
        StartsWith(value: string, ignoreCase: boolean, culture: any): boolean
        StartsWith(value: string, comparisonType: any): boolean
        StartsWith(value: string): boolean
        ToLower(culture: any): string
        ToLower(): string
        ToLowerInvariant(): string
        ToUpper(culture: any): string
        ToUpper(): string
        ToUpperInvariant(): string
        toString(provider: any): string
        toString(): string
        Clone(): Object
        Insert(startIndex: number, value: string): string
        Replace(oldChar: string, newChar: string): string
        Replace(oldValue: string, newValue: string): string
        Remove(startIndex: number, count: number): string
        Remove(startIndex: number): string
        GetTypeCode(): any
        GetEnumerator(): any
        static Join(separator: string, value: Array<string>, startIndex: number, count: number): string
        static Join(separator: string, values: IEnumerable<string>): string
        static Join(separator: string, ...value: string[]): string
        static Join(separator: string, ...values: Object[]): string
        static Equals(a: string | Object, b: string | Object, comparisonType: any): boolean
        static Equals(a: string | Object, b: string | Object): boolean
        static op_Inequality(a: string, b: string): boolean
        static IsNullOrEmpty(value: string): boolean
        static IsNullOrWhiteSpace(value: string): boolean
        static Compare(strA: string, indexA: number, strB: string, indexB: number, length: number, ignoreCase: boolean, culture: any): number
        static Compare(strA: string, indexA: number, strB: string, indexB: number, length: number, culture: any, options: any): number
        static Compare(strA: string, indexA: number, strB: string, indexB: number, length: number, ignoreCase: boolean): number
        static Compare(strA: string, indexA: number, strB: string, indexB: number, length: number, comparisonType: any): number
        static Compare(strA: string, indexA: number, strB: string, indexB: number, length: number): number
        static Compare(strA: string, strB: string, culture: any, options: any): number
        static Compare(strA: string, strB: string, ignoreCase: boolean, culture: any): number
        static Compare(strA: string, strB: string, ignoreCase: boolean): number
        static Compare(strA: string, strB: string, comparisonType: any): number
        static Compare(strA: string, strB: string): number
        static CompareOrdinal(strA: string, indexA: number, strB: string, indexB: number, length: number): number
        static CompareOrdinal(strA: string, strB: string): number
        static Format(provider: any, format: string, arg0: Object, arg1: Object, arg2: Object): string
        static Format(format: string, arg0: Object, arg1: Object, arg2: Object): string
        static Format(provider: any, format: string, arg0: Object, arg1: Object): string
        static Format(format: string, arg0: Object, arg1: Object): string
        static Format(provider: any, format: string, arg0: Object): string
        static Format(format: string, arg0: Object): string
        static Format(provider: any, format: string, ...args: Object[]): string
        static Format(format: string, ...args: Object[]): string
        static Copy(str: string): string
        static Concat(arg0: Object, arg1: Object, arg2: Object, arg3: Object): string
        static Concat(str0: string, str1: string, str2: string, str3: string): string
        static Concat(arg0: Object, arg1: Object, arg2: Object): string
        static Concat(str0: string, str1: string, str2: string): string
        static Concat(arg0: Object, arg1: Object): string
        static Concat(str0: string, str1: string): string
        static Concat(arg0: Object): string
        static Concat(values: IEnumerable<string>): string
        static Concat(...args: Object[]): string
        static Concat(...values: string[]): string
        static Intern(str: string): string
        static IsInterned(str: string): string
        // js_op_overloading: static ==(a: string, b: string): boolean
        readonly Length: number
        static readonly Empty: string
    }
}
declare module "System" {
    import * as jsb from "jsb";
    class Int32 extends ValueType {
        CompareTo(value: Object): number
        CompareTo(value: number): number
        Equals(obj: Object): boolean
        Equals(obj: number): boolean
        GetHashCode(): number
        toString(format: string, provider: any): string
        toString(format: string): string
        toString(provider: any): string
        toString(): string
        GetTypeCode(): any
        static Parse(s: string, style: any, provider: any): number
        static Parse(s: string, style: any): number
        static Parse(s: string, provider: any): number
        static Parse(s: string): number
        static TryParse(s: string, style: any, provider: any, result: jsb.Out<number>): boolean
        static TryParse(s: string, result: jsb.Out<number>): boolean
        protected constructor()
        static readonly MaxValue: number
        static readonly MinValue: number
    }
}
declare module "System" {
    import * as jsb from "jsb";
    class UInt32 extends ValueType {
        CompareTo(value: Object): number
        CompareTo(value: number): number
        Equals(obj: Object): boolean
        Equals(obj: number): boolean
        GetHashCode(): number
        toString(format: string, provider: any): string
        toString(provider: any): string
        toString(format: string): string
        toString(): string
        GetTypeCode(): any
        static Parse(s: string, style: any, provider: any): number
        static Parse(s: string, style: any): number
        static Parse(s: string, provider: any): number
        static Parse(s: string): number
        static TryParse(s: string, style: any, provider: any, result: jsb.Out<number>): boolean
        static TryParse(s: string, result: jsb.Out<number>): boolean
        protected constructor()
        static readonly MaxValue: number
        static readonly MinValue: number
    }
}
declare module "System" {
    import * as jsb from "jsb";
    class Int16 extends ValueType {
        CompareTo(value: Object): number
        CompareTo(value: number): number
        Equals(obj: Object): boolean
        Equals(obj: number): boolean
        GetHashCode(): number
        toString(format: string, provider: any): string
        toString(provider: any): string
        toString(format: string): string
        toString(): string
        GetTypeCode(): any
        static Parse(s: string, style: any, provider: any): number
        static Parse(s: string, style: any): number
        static Parse(s: string, provider: any): number
        static Parse(s: string): number
        static TryParse(s: string, style: any, provider: any, result: jsb.Out<number>): boolean
        static TryParse(s: string, result: jsb.Out<number>): boolean
        protected constructor()
        static readonly MaxValue: number
        static readonly MinValue: number
    }
}
declare module "System" {
    import * as jsb from "jsb";
    class UInt16 extends ValueType {
        CompareTo(value: Object): number
        CompareTo(value: number): number
        Equals(obj: Object): boolean
        Equals(obj: number): boolean
        GetHashCode(): number
        toString(format: string, provider: any): string
        toString(provider: any): string
        toString(format: string): string
        toString(): string
        GetTypeCode(): any
        static Parse(s: string, style: any, provider: any): number
        static Parse(s: string, style: any): number
        static Parse(s: string, provider: any): number
        static Parse(s: string): number
        static TryParse(s: string, style: any, provider: any, result: jsb.Out<number>): boolean
        static TryParse(s: string, result: jsb.Out<number>): boolean
        protected constructor()
        static readonly MaxValue: number
        static readonly MinValue: number
    }
}
declare module "System" {
    import * as jsb from "jsb";
    import { IEnumerator } from "System.Collections";
    abstract class Array<T, RANK = 1> extends Object {
        CopyTo(array: Array<any>, index: number): void
        Clone(): Object
        GetLongLength(dimension: number): number
        GetEnumerator(): IEnumerator
        GetLength(dimension: number): number
        GetLowerBound(dimension: number): number
        GetValue(index1: number, index2: number, index3: number): T
        GetValue(index1: number, index2: number): T
        GetValue(index: number): T
        GetValue(...index: number[]): T
        SetValue(value: T, index1: number, index2: number, index3: number): T
        SetValue(value: T, index1: number, index2: number): T
        SetValue(value: T, index: number): T
        SetValue(value: T, ...index: number[]): T
        GetUpperBound(dimension: number): number
        Initialize(): void
        static BinarySearch<T>(array: Array<T>, index: number, length: number, value: Object, comparer: any): number
        static BinarySearch<T>(array: Array<T>, index: number, length: number, value: Object): number
        static BinarySearch<T>(array: Array<T>, value: Object, comparer: any): number
        static BinarySearch<T>(array: Array<T>, value: Object): number
        static IndexOf<T>(array: Array<T>, value: Object, startIndex: number, count: number): number
        static IndexOf<T>(array: Array<T>, value: Object, startIndex: number): number
        static IndexOf<T>(array: Array<T>, value: Object): number
        static LastIndexOf<T>(array: Array<T>, value: Object, startIndex: number, count: number): number
        static LastIndexOf<T>(array: Array<T>, value: Object, startIndex: number): number
        static LastIndexOf<T>(array: Array<T>, value: Object): number
        static Reverse<T>(array: Array<T>, index: number, length: number): void
        static Reverse<T>(array: Array<T>): void
        static Sort<T>(keys: Array<T>, items: Array<T>, index: number, length: number, comparer: any): void
        static Sort<T>(array: Array<T>, index: number, length: number, comparer: any): void
        static Sort<T>(keys: Array<T>, items: Array<T>, index: number, length: number): void
        static Sort<T>(array: Array<T>, index: number, length: number): void
        static Sort<T>(keys: Array<T>, items: Array<T>, comparer: any): void
        static Sort<T>(array: Array<T>, comparer: any): void
        static Sort<T>(keys: Array<T>, items: Array<T>): void
        static Sort<T>(array: Array<T>): void
        static CreateInstance<T>(elementType: any, length1: number, length2: number, length3: number): Array<T>
        static CreateInstance<T>(elementType: any, length1: number, length2: number): Array<T>
        static CreateInstance<T>(elementType: any, lengths: Array<number>, lowerBounds: Array<number>): Array<T>
        static CreateInstance<T>(elementType: any, length: number): Array<T>
        static CreateInstance<T>(elementType: any, ...lengths: number[]): Array<T>
        static Clear<T>(array: Array<T>, index: number, length: number): void
        static Copy<T>(sourceArray: Array<T>, sourceIndex: number, destinationArray: Array<T>, destinationIndex: number, length: number): void
        static Copy<T>(sourceArray: Array<T>, destinationArray: Array<T>, length: number): void
        static ConstrainedCopy<T>(sourceArray: Array<T>, sourceIndex: number, destinationArray: Array<T>, destinationIndex: number, length: number): void
        readonly LongLength: number
        readonly IsFixedSize: boolean
        readonly IsReadOnly: boolean
        readonly IsSynchronized: boolean
        readonly SyncRoot: Object
        readonly Length: number
        readonly Rank: number
    }
}
declare module "System" {
    import * as jsb from "jsb";
    abstract class Delegate extends Object {
        DynamicInvoke(...args: Object[]): Object
        Clone(): Object
        Equals(obj: Object): boolean
        GetHashCode(): number
        GetObjectData(info: any, context: any): void
        GetInvocationList(): Array<Delegate>
        GetMethodInfo(): any
        static Combine(a: Delegate, b: Delegate): Delegate
        static Combine(...delegates: Delegate[]): Delegate
        static Remove(source: Delegate, value: Delegate): Delegate
        static RemoveAll(source: Delegate, value: Delegate): Delegate
        static op_Inequality(d1: Delegate, d2: Delegate): boolean
        // js_op_overloading: static ==(d1: Delegate, d2: Delegate): boolean
        readonly Method: any
        readonly Target: Object
    }
}
declare module "QuickJS.IO" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    class ByteBuffer extends Object {
        constructor(initialCapacity: number, maxCapacity: number, allocator: any)
        constructor(data: Array<jsb.byte>, maxCapacity: number)
        constructor(data: Array<jsb.byte>)
        toString(): string
        Release(): void
        Retain(): ByteBuffer
        CheckReadalbe(size: number): void
        ReadBytes(dst: Array<jsb.byte>, dstOffset: number, size: number): number
        ReadBytes(pointer: any, size: number): number
        ReadBytes(count: number): void
        ReadUByte(): jsb.byte
        ReadSByte(): number
        ReadBoolean(): boolean
        ReadAllBytes(): Array<jsb.byte>
        ReadSingle(): number
        ReadDouble(): number
        ReadString(): string
        ReadInt16(): number
        ReadUInt16(): number
        ReadInt32(): number
        ReadUInt32(): number
        ReadInt64(): number
        ReadUInt64(): number
        EnsureCapacity(value: number): void
        WriteByte(data: jsb.byte): void
        WriteSByte(data: number): void
        WriteBytes(src: Array<jsb.byte>, srcOffset: number, count: number): void
        WriteBytes(memoryStream: any, size: number): void
        WriteBytes(other: ByteBuffer): void
        WriteBytes(byteCount: number): void
        WriteBytes(data: Array<jsb.byte>): void
        WriteBoolean(value: boolean): void
        WriteInt16(value: number): void
        WriteUInt16(value: number): void
        WriteInt32(value: number): void
        WriteUInt32(value: number): void
        WriteInt64(value: number): void
        WriteUInt64(value: number): void
        WriteSingle(value: number): void
        WriteDouble(value: number): void
        WriteString(value: string): void
        readonly data: Array<jsb.byte>
        readonly capacity: number
        writerIndex: number
        readonly readableBytes: number
        readerIndex: number
        readonly maxCapacity: number
        readonly isWritable: boolean
    }
}
declare module "UnityEngine.UI" {
    import { Object } from "System";
    class AnimationTriggers extends Object {
        constructor()
        normalTrigger: string
        highlightedTrigger: string
        pressedTrigger: string
        selectedTrigger: string
        disabledTrigger: string
    }
}
declare module "UnityEngine.UI" {
    import { IEventSystemHandler, IPointerEnterHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IPointerUpHandler, IMoveHandler, ISubmitHandler, IPointerClickHandler, PointerEventData, BaseEventData } from "UnityEngine.EventSystems";
    class Button extends Selectable implements IEventSystemHandler, IPointerEnterHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IPointerUpHandler, IMoveHandler, ISubmitHandler, IPointerClickHandler {
        OnPointerClick(eventData: PointerEventData): void
        OnSubmit(eventData: BaseEventData): void
        /*protected*/ constructor()
        onClick: Button.ButtonClickedEvent
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { UIBehaviour, IEventSystemHandler, IPointerEnterHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IPointerUpHandler, IMoveHandler, AxisEventData, PointerEventData, BaseEventData } from "UnityEngine.EventSystems";
    import { Array } from "System";
    import { Animator, Vector3 } from "UnityEngine";
    class Selectable extends UIBehaviour implements IEventSystemHandler, IPointerEnterHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IPointerUpHandler, IMoveHandler {
        IsInteractable(): boolean
        FindSelectable(dir: Vector3): Selectable
        FindSelectableOnLeft(): Selectable
        FindSelectableOnRight(): Selectable
        FindSelectableOnUp(): Selectable
        FindSelectableOnDown(): Selectable
        OnMove(eventData: AxisEventData): void
        OnPointerDown(eventData: PointerEventData): void
        OnPointerUp(eventData: PointerEventData): void
        OnPointerEnter(eventData: PointerEventData): void
        OnPointerExit(eventData: PointerEventData): void
        OnSelect(eventData: BaseEventData): void
        OnDeselect(eventData: BaseEventData): void
        Select(): void
        static AllSelectablesNoAlloc(selectables: Array<Selectable>): number
        /*protected*/ constructor()
        static readonly allSelectablesArray: Array<Selectable>
        static readonly allSelectableCount: number
        navigation: Navigation
        transition: Selectable.Transition
        colors: ColorBlock
        spriteState: SpriteState
        animationTriggers: AnimationTriggers
        targetGraphic: Graphic
        interactable: boolean
        image: Image
        readonly animator: Animator
    }
}
declare module "UnityEngine.EventSystems" {
    import { MonoBehaviour } from "UnityEngine";
    abstract class UIBehaviour extends MonoBehaviour {
        IsActive(): boolean
        IsDestroyed(): boolean
    }
}
declare module "UnityEngine.UI" {
    import { Enum } from "System";
    enum CanvasUpdate {
        Prelayout = 0,
        Layout = 1,
        PostLayout = 2,
        PreRender = 3,
        LatePreRender = 4,
        MaxUpdateValue = 5,
    }
}
declare module "UnityEngine.UI" {
    import { Transform } from "UnityEngine";
    interface ICanvasElement {
        Rebuild(executing: CanvasUpdate): void
        LayoutComplete(): void
        GraphicUpdateComplete(): void
        IsDestroyed(): boolean
        readonly transform: Transform
    }
}
declare module "UnityEngine.UI" {
    import { Object } from "System";
    class CanvasUpdateRegistry extends Object {
        static RegisterCanvasElementForLayoutRebuild(element: ICanvasElement): void
        static TryRegisterCanvasElementForLayoutRebuild(element: ICanvasElement): boolean
        static RegisterCanvasElementForGraphicRebuild(element: ICanvasElement): void
        static TryRegisterCanvasElementForGraphicRebuild(element: ICanvasElement): boolean
        static UnRegisterCanvasElementForRebuild(element: ICanvasElement): void
        static IsRebuildingLayout(): boolean
        static IsRebuildingGraphics(): boolean
        protected constructor()
        static readonly instance: CanvasUpdateRegistry
    }
}
declare module "UnityEngine.UI" {
    import { ValueType, Object } from "System";
    import { Color } from "UnityEngine";
    class ColorBlock extends ValueType {
        constructor()
        Equals(obj: Object): boolean
        Equals(other: ColorBlock): boolean
        GetHashCode(): number
        static op_Inequality(point1: ColorBlock, point2: ColorBlock): boolean
        // js_op_overloading: static ==(point1: ColorBlock, point2: ColorBlock): boolean
        normalColor: Color
        highlightedColor: Color
        pressedColor: Color
        selectedColor: Color
        disabledColor: Color
        colorMultiplier: number
        fadeDuration: number
        static readonly defaultColorBlock: ColorBlock
    }
}
declare module "UnityEngine.UI" {
    import { Object } from "System";
    class ClipperRegistry extends Object {
        Cull(): void
        static Register(c: IClipper): void
        static Unregister(c: IClipper): void
        protected constructor()
        static readonly instance: ClipperRegistry
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Rect } from "UnityEngine";
    import { List } from "System.Collections.Generic";
    abstract class Clipping extends Object {
        static FindCullAndClipWorldRect(rectMaskParents: any, validRect: jsb.Out<boolean>): Rect
    }
}
declare module "UnityEngine.UI" {
    interface IClipper {
        PerformClipping(): void
    }
}
declare module "UnityEngine.UI" {
    import { GameObject, RectTransform, Rect, Vector2 } from "UnityEngine";
    interface IClippable {
        RecalculateClipping(): void
        Cull(clipRect: Rect, validRect: boolean): void
        SetClipRect(value: Rect, validRect: boolean): void
        SetClipSoftness(clipSoftness: Vector2): void
        readonly gameObject: GameObject
        readonly rectTransform: RectTransform
    }
}
declare module "UnityEngine.UI" {
    import { Object } from "System";
    import { GameObject } from "UnityEngine";
    abstract class DefaultControls extends Object {
        static CreatePanel(resources: DefaultControls.Resources): GameObject
        static CreateButton(resources: DefaultControls.Resources): GameObject
        static CreateText(resources: DefaultControls.Resources): GameObject
        static CreateImage(resources: DefaultControls.Resources): GameObject
        static CreateRawImage(resources: DefaultControls.Resources): GameObject
        static CreateSlider(resources: DefaultControls.Resources): GameObject
        static CreateScrollbar(resources: DefaultControls.Resources): GameObject
        static CreateToggle(resources: DefaultControls.Resources): GameObject
        static CreateInputField(resources: DefaultControls.Resources): GameObject
        static CreateDropdown(resources: DefaultControls.Resources): GameObject
        static CreateScrollView(resources: DefaultControls.Resources): GameObject
        static factory: DefaultControls.IFactoryControls
    }
}
declare module "UnityEngine.UI" {
    import { IEventSystemHandler, IPointerEnterHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IPointerUpHandler, IMoveHandler, ISubmitHandler, IPointerClickHandler, ICancelHandler, PointerEventData, BaseEventData } from "UnityEngine.EventSystems";
    import { RectTransform, Sprite } from "UnityEngine";
    import { List } from "System.Collections.Generic";
    import { Object } from "System";
    class Dropdown extends Selectable implements IEventSystemHandler, IPointerEnterHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IPointerUpHandler, IMoveHandler, ISubmitHandler, IPointerClickHandler, ICancelHandler {
        SetValueWithoutNotify(input: number): void
        RefreshShownValue(): void
        AddOptions(options: any): void
        AddOptions(options: List<string>): void
        AddOptions(options: any): void
        ClearOptions(): void
        OnPointerClick(eventData: PointerEventData): void
        OnSubmit(eventData: BaseEventData): void
        OnCancel(eventData: BaseEventData): void
        Show(): void
        Hide(): void
        /*protected*/ constructor()
        template: RectTransform
        captionText: Text
        captionImage: Image
        itemText: Text
        itemImage: Image
        options: any
        onValueChanged: Dropdown.DropdownEvent
        alphaFadeSpeed: number
        value: number
    }
}
declare module "UnityEngine.UI" {
    import { Object, Enum } from "System";
    import { Object as Object1, TextAnchor } from "UnityEngine";
    class FontData extends Object {
        constructor()
        static readonly defaultFontData: FontData
        font: any
        fontSize: number
        fontStyle: any
        bestFit: boolean
        minSize: number
        maxSize: number
        alignment: TextAnchor
        alignByGeometry: boolean
        richText: boolean
        horizontalOverflow: any
        verticalOverflow: any
        lineSpacing: number
    }
}
declare module "UnityEngine.UI" {
    import { Object } from "System";
    abstract class FontUpdateTracker extends Object {
        static TrackText(t: Text): void
        static UntrackText(t: Text): void
    }
}
declare module "UnityEngine.UI" {
    import { UIBehaviour } from "UnityEngine.EventSystems";
    import { Material, Color, RectTransform, Behaviour, Component, Texture, Vector2, Camera, Rect } from "UnityEngine";
    abstract class Graphic extends UIBehaviour implements ICanvasElement {
        SetAllDirty(): void
        SetLayoutDirty(): void
        SetVerticesDirty(): void
        SetMaterialDirty(): void
        OnCullingChanged(): void
        Rebuild(update: CanvasUpdate): void
        LayoutComplete(): void
        GraphicUpdateComplete(): void
        SetNativeSize(): void
        Raycast(sp: Vector2, eventCamera: Camera): boolean
        PixelAdjustPoint(point: Vector2): Vector2
        GetPixelAdjustedRect(): Rect
        CrossFadeColor(targetColor: Color, duration: number, ignoreTimeScale: boolean, useAlpha: boolean, useRGB: boolean): void
        CrossFadeColor(targetColor: Color, duration: number, ignoreTimeScale: boolean, useAlpha: boolean): void
        CrossFadeAlpha(alpha: number, duration: number, ignoreTimeScale: boolean): void
        RegisterDirtyLayoutCallback(action: () => void): void
        UnregisterDirtyLayoutCallback(action: () => void): void
        RegisterDirtyVerticesCallback(action: () => void): void
        UnregisterDirtyVerticesCallback(action: () => void): void
        RegisterDirtyMaterialCallback(action: () => void): void
        UnregisterDirtyMaterialCallback(action: () => void): void
        static readonly defaultGraphicMaterial: Material
        color: Color
        raycastTarget: boolean
        readonly depth: number
        readonly rectTransform: RectTransform
        readonly canvas: any
        readonly canvasRenderer: any
        readonly defaultMaterial: Material
        material: Material
        readonly materialForRendering: Material
        readonly mainTexture: Texture
    }
}
declare module "UnityEngine.UI" {
    import { BaseRaycaster, PointerEventData, RaycastResult } from "UnityEngine.EventSystems";
    import { Camera } from "UnityEngine";
    import { List } from "System.Collections.Generic";
    import { Object } from "System";
    class GraphicRaycaster extends BaseRaycaster {
        Raycast(eventData: PointerEventData, resultAppendList: any): void
        /*protected*/ constructor()
        readonly sortOrderPriority: number
        readonly renderOrderPriority: number
        ignoreReversedGraphics: boolean
        blockingObjects: GraphicRaycaster.BlockingObjects
        readonly eventCamera: Camera
    }
}
declare module "UnityEngine.EventSystems" {
    import { Camera } from "UnityEngine";
    import { List } from "System.Collections.Generic";
    import { Object } from "System";
    abstract class BaseRaycaster extends UIBehaviour {
        Raycast(eventData: PointerEventData, resultAppendList: any): void
        toString(): string
        readonly eventCamera: Camera
        readonly sortOrderPriority: number
        readonly renderOrderPriority: number
        readonly rootRaycaster: BaseRaycaster
    }
}
declare module "UnityEngine.UI" {
    import { Object } from "System";
    import { Behaviour } from "UnityEngine";
    import { IList } from "System.Collections.Generic";
    class GraphicRegistry extends Object {
        static RegisterGraphicForCanvas(c: any, graphic: Graphic): void
        static UnregisterGraphicForCanvas(c: any, graphic: Graphic): void
        static GetGraphicsForCanvas(canvas: any): any
        protected constructor()
        static readonly instance: GraphicRegistry
    }
}
declare module "UnityEngine.UI" {
    interface IMaskable {
        RecalculateMasking(): void
    }
}
declare module "UnityEngine.UI" {
    import { Sprite, Material, Texture, Vector2, Camera } from "UnityEngine";
    class Image extends MaskableGraphic implements IMaterialModifier, IMaskable, ICanvasElement, ILayoutElement, IClippable {
        DisableSpriteOptimizations(): void
        OnBeforeSerialize(): void
        OnAfterDeserialize(): void
        SetNativeSize(): void
        CalculateLayoutInputHorizontal(): void
        CalculateLayoutInputVertical(): void
        IsRaycastLocationValid(screenPoint: Vector2, eventCamera: Camera): boolean
        /*protected*/ constructor()
        sprite: Sprite
        overrideSprite: Sprite
        type: Image.Type
        preserveAspect: boolean
        fillCenter: boolean
        fillMethod: Image.FillMethod
        fillAmount: number
        fillClockwise: boolean
        fillOrigin: number
        alphaHitTestMinimumThreshold: number
        useSpriteMesh: boolean
        static readonly defaultETC1GraphicMaterial: Material
        readonly mainTexture: Texture
        readonly hasBorder: boolean
        pixelsPerUnitMultiplier: number
        readonly pixelsPerUnit: number
        material: Material
        readonly minWidth: number
        readonly preferredWidth: number
        readonly flexibleWidth: number
        readonly minHeight: number
        readonly preferredHeight: number
        readonly flexibleHeight: number
        readonly layoutPriority: number
    }
}
declare module "UnityEngine.UI" {
    import { Material, Rect, Vector2 } from "UnityEngine";
    abstract class MaskableGraphic extends Graphic implements IMaterialModifier, IMaskable, ICanvasElement, IClippable {
        GetModifiedMaterial(baseMaterial: Material): Material
        Cull(clipRect: Rect, validRect: boolean): void
        SetClipRect(clipRect: Rect, validRect: boolean): void
        SetClipSoftness(clipSoftness: Vector2): void
        RecalculateClipping(): void
        RecalculateMasking(): void
        onCullStateChanged: MaskableGraphic.CullStateChangedEvent
        maskable: boolean
        isMaskingGraphic: boolean
    }
}
declare module "UnityEngine.UI" {
    import { IDragHandler, IEndDragHandler, IEventSystemHandler, IPointerEnterHandler, IUpdateSelectedHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IPointerUpHandler, IMoveHandler, ISubmitHandler, IPointerClickHandler, IBeginDragHandler, PointerEventData, BaseEventData } from "UnityEngine.EventSystems";
    import { Color, Event } from "UnityEngine";
    import { Object, Enum } from "System";
    class InputField extends Selectable implements IDragHandler, IEndDragHandler, ICanvasElement, IEventSystemHandler, IPointerEnterHandler, IUpdateSelectedHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IPointerUpHandler, IMoveHandler, ILayoutElement, ISubmitHandler, IPointerClickHandler, IBeginDragHandler {
        SetTextWithoutNotify(input: string): void
        MoveTextEnd(shift: boolean): void
        MoveTextStart(shift: boolean): void
        OnBeginDrag(eventData: PointerEventData): void
        OnDrag(eventData: PointerEventData): void
        OnEndDrag(eventData: PointerEventData): void
        OnPointerDown(eventData: PointerEventData): void
        ProcessEvent(e: Event): void
        OnUpdateSelected(eventData: BaseEventData): void
        ForceLabelUpdate(): void
        Rebuild(update: CanvasUpdate): void
        LayoutComplete(): void
        GraphicUpdateComplete(): void
        ActivateInputField(): void
        OnSelect(eventData: BaseEventData): void
        OnPointerClick(eventData: PointerEventData): void
        DeactivateInputField(): void
        OnDeselect(eventData: BaseEventData): void
        OnSubmit(eventData: BaseEventData): void
        CalculateLayoutInputHorizontal(): void
        CalculateLayoutInputVertical(): void
        /*protected*/ constructor()
        shouldHideMobileInput: boolean
        shouldActivateOnSelect: boolean
        text: string
        readonly isFocused: boolean
        caretBlinkRate: number
        caretWidth: number
        textComponent: Text
        placeholder: Graphic
        caretColor: Color
        customCaretColor: boolean
        selectionColor: Color
        onEndEdit: InputField.SubmitEvent
        onValueChanged: InputField.OnChangeEvent
        characterLimit: number
        contentType: InputField.ContentType
        lineType: InputField.LineType
        inputType: InputField.InputType
        readonly touchScreenKeyboard: any
        keyboardType: any
        characterValidation: InputField.CharacterValidation
        readOnly: boolean
        readonly multiLine: boolean
        asteriskChar: string
        readonly wasCanceled: boolean
        caretPosition: number
        selectionAnchorPosition: number
        selectionFocusPosition: number
        readonly minWidth: number
        readonly preferredWidth: number
        readonly flexibleWidth: number
        readonly minHeight: number
        readonly preferredHeight: number
        readonly flexibleHeight: number
        readonly layoutPriority: number
        onValidateInput(op: "get"): (text: string, charIndex: number, addedChar: string) => string
        onValidateInput(op: "add" | "remove" | "set", fn?: (text: string, charIndex: number, addedChar: string) => string): void
        onValidateInput(op: "add" | "remove" | "set" | "get", fn?: (text: string, charIndex: number, addedChar: string) => string): (text: string, charIndex: number, addedChar: string) => string | void
    }
}
declare module "UnityEngine.UI" {
    import { UIBehaviour } from "UnityEngine.EventSystems";
    class AspectRatioFitter extends UIBehaviour implements ILayoutController {
        SetLayoutHorizontal(): void
        SetLayoutVertical(): void
        /*protected*/ constructor()
        aspectMode: AspectRatioFitter.AspectMode
        aspectRatio: number
    }
}
declare module "UnityEngine.UI" {
    import { UIBehaviour } from "UnityEngine.EventSystems";
    import { Vector2 } from "UnityEngine";
    class CanvasScaler extends UIBehaviour {
        /*protected*/ constructor()
        uiScaleMode: CanvasScaler.ScaleMode
        referencePixelsPerUnit: number
        scaleFactor: number
        referenceResolution: Vector2
        screenMatchMode: CanvasScaler.ScreenMatchMode
        matchWidthOrHeight: number
        physicalUnit: CanvasScaler.Unit
        fallbackScreenDPI: number
        defaultSpriteDPI: number
        dynamicPixelsPerUnit: number
    }
}
declare module "UnityEngine.UI" {
    import { UIBehaviour } from "UnityEngine.EventSystems";
    class ContentSizeFitter extends UIBehaviour implements ILayoutController {
        SetLayoutHorizontal(): void
        SetLayoutVertical(): void
        /*protected*/ constructor()
        horizontalFit: ContentSizeFitter.FitMode
        verticalFit: ContentSizeFitter.FitMode
    }
}
declare module "UnityEngine.UI" {
    import { Vector2 } from "UnityEngine";
    class GridLayoutGroup extends LayoutGroup implements ILayoutElement, ILayoutController {
        CalculateLayoutInputHorizontal(): void
        CalculateLayoutInputVertical(): void
        SetLayoutHorizontal(): void
        SetLayoutVertical(): void
        /*protected*/ constructor()
        startCorner: GridLayoutGroup.Corner
        startAxis: GridLayoutGroup.Axis
        cellSize: Vector2
        spacing: Vector2
        constraint: GridLayoutGroup.Constraint
        constraintCount: number
    }
}
declare module "UnityEngine.UI" {
    import { UIBehaviour } from "UnityEngine.EventSystems";
    import { Object } from "System";
    import { TextAnchor } from "UnityEngine";
    abstract class LayoutGroup extends UIBehaviour implements ILayoutElement, ILayoutController {
        CalculateLayoutInputHorizontal(): void
        CalculateLayoutInputVertical(): void
        SetLayoutHorizontal(): void
        SetLayoutVertical(): void
        padding: any
        childAlignment: TextAnchor
        readonly minWidth: number
        readonly preferredWidth: number
        readonly flexibleWidth: number
        readonly minHeight: number
        readonly preferredHeight: number
        readonly flexibleHeight: number
        readonly layoutPriority: number
    }
}
declare module "UnityEngine.UI" {
    class HorizontalLayoutGroup extends HorizontalOrVerticalLayoutGroup implements ILayoutElement, ILayoutController {
        CalculateLayoutInputHorizontal(): void
        CalculateLayoutInputVertical(): void
        SetLayoutHorizontal(): void
        SetLayoutVertical(): void
        /*protected*/ constructor()
    }
}
declare module "UnityEngine.UI" {
    abstract class HorizontalOrVerticalLayoutGroup extends LayoutGroup implements ILayoutElement, ILayoutController {
        spacing: number
        childForceExpandWidth: boolean
        childForceExpandHeight: boolean
        childControlWidth: boolean
        childControlHeight: boolean
        childScaleWidth: boolean
        childScaleHeight: boolean
    }
}
declare module "UnityEngine.UI" {
    interface ILayoutElement {
        CalculateLayoutInputHorizontal(): void
        CalculateLayoutInputVertical(): void
        readonly minWidth: number
        readonly preferredWidth: number
        readonly flexibleWidth: number
        readonly minHeight: number
        readonly preferredHeight: number
        readonly flexibleHeight: number
        readonly layoutPriority: number
    }
}
declare module "UnityEngine.UI" {
    interface ILayoutController {
        SetLayoutHorizontal(): void
        SetLayoutVertical(): void
    }
}
declare module "UnityEngine.UI" {
    interface ILayoutIgnorer {
        readonly ignoreLayout: boolean
    }
}
declare module "UnityEngine.UI" {
    import { UIBehaviour } from "UnityEngine.EventSystems";
    class LayoutElement extends UIBehaviour implements ILayoutIgnorer, ILayoutElement {
        CalculateLayoutInputHorizontal(): void
        CalculateLayoutInputVertical(): void
        /*protected*/ constructor()
        ignoreLayout: boolean
        minWidth: number
        minHeight: number
        preferredWidth: number
        preferredHeight: number
        flexibleWidth: number
        flexibleHeight: number
        layoutPriority: number
    }
}
declare module "UnityEngine.UI" {
    import { Object } from "System";
    import { Transform, RectTransform } from "UnityEngine";
    class LayoutRebuilder extends Object implements ICanvasElement {
        constructor()
        IsDestroyed(): boolean
        Rebuild(executing: CanvasUpdate): void
        LayoutComplete(): void
        GraphicUpdateComplete(): void
        GetHashCode(): number
        Equals(obj: Object): boolean
        toString(): string
        static ForceRebuildLayoutImmediate(layoutRoot: RectTransform): void
        static MarkLayoutForRebuild(rect: RectTransform): void
        readonly transform: Transform
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { RectTransform } from "UnityEngine";
    abstract class LayoutUtility extends Object {
        static GetMinSize(rect: RectTransform, axis: number): number
        static GetPreferredSize(rect: RectTransform, axis: number): number
        static GetFlexibleSize(rect: RectTransform, axis: number): number
        static GetMinWidth(rect: RectTransform): number
        static GetPreferredWidth(rect: RectTransform): number
        static GetFlexibleWidth(rect: RectTransform): number
        static GetMinHeight(rect: RectTransform): number
        static GetPreferredHeight(rect: RectTransform): number
        static GetFlexibleHeight(rect: RectTransform): number
        static GetLayoutProperty(rect: RectTransform, property: (arg: ILayoutElement) => number, defaultValue: number, source: jsb.Out<ILayoutElement>): number
        static GetLayoutProperty(rect: RectTransform, property: (arg: ILayoutElement) => number, defaultValue: number): number
    }
}
declare module "UnityEngine.UI" {
    class VerticalLayoutGroup extends HorizontalOrVerticalLayoutGroup implements ILayoutElement, ILayoutController {
        CalculateLayoutInputHorizontal(): void
        CalculateLayoutInputVertical(): void
        SetLayoutHorizontal(): void
        SetLayoutVertical(): void
        /*protected*/ constructor()
    }
}
declare module "UnityEngine.UI" {
    import { UIBehaviour } from "UnityEngine.EventSystems";
    import { RectTransform, Vector2, Camera, Material } from "UnityEngine";
    class Mask extends UIBehaviour implements IMaterialModifier {
        MaskEnabled(): boolean
        IsRaycastLocationValid(sp: Vector2, eventCamera: Camera): boolean
        GetModifiedMaterial(baseMaterial: Material): Material
        /*protected*/ constructor()
        readonly rectTransform: RectTransform
        showMaskGraphic: boolean
        readonly graphic: Graphic
    }
}
declare module "UnityEngine.UI" {
    import { Object } from "System";
    import { Component, Transform } from "UnityEngine";
    import { List } from "System.Collections.Generic";
    class MaskUtilities extends Object {
        constructor()
        static Notify2DMaskStateChanged(mask: Component): void
        static NotifyStencilStateChanged(mask: Component): void
        static FindRootSortOverrideCanvas(start: Transform): Transform
        static GetStencilDepth(transform: Transform, stopAfter: Transform): number
        static IsDescendantOrSelf(father: Transform, child: Transform): boolean
        static GetRectMaskForClippable(clippable: IClippable): RectMask2D
        static GetRectMasksForClip(clipper: RectMask2D, masks: any): void
    }
}
declare module "UnityEngine.UI" {
    import { Material } from "UnityEngine";
    interface IMaterialModifier {
        GetModifiedMaterial(baseMaterial: Material): Material
    }
}
declare module "UnityEngine.UI" {
    import { ValueType } from "System";
    class Navigation extends ValueType {
        constructor()
        Equals(other: Navigation): boolean
        mode: Navigation.Mode
        selectOnUp: Selectable
        selectOnDown: Selectable
        selectOnLeft: Selectable
        selectOnRight: Selectable
        static readonly defaultNavigation: Navigation
    }
}
declare module "UnityEngine.UI" {
    import { Texture, Rect } from "UnityEngine";
    class RawImage extends MaskableGraphic implements IMaterialModifier, IMaskable, ICanvasElement, IClippable {
        SetNativeSize(): void
        /*protected*/ constructor()
        readonly mainTexture: Texture
        texture: Texture
        uvRect: Rect
    }
}
declare module "UnityEngine.UI" {
    import { UIBehaviour } from "UnityEngine.EventSystems";
    import { Vector4, Vector2Int, Rect, RectTransform, Vector2, Camera } from "UnityEngine";
    class RectMask2D extends UIBehaviour implements IClipper {
        IsRaycastLocationValid(sp: Vector2, eventCamera: Camera): boolean
        PerformClipping(): void
        UpdateClipSoftness(): void
        AddClippable(clippable: IClippable): void
        RemoveClippable(clippable: IClippable): void
        /*protected*/ constructor()
        padding: Vector4
        softness: Vector2Int
        readonly canvasRect: Rect
        readonly rectTransform: RectTransform
    }
}
declare module "UnityEngine.UI" {
    import { UIBehaviour, IInitializePotentialDragHandler, IDragHandler, IEndDragHandler, IScrollHandler, IEventSystemHandler, IBeginDragHandler, PointerEventData } from "UnityEngine.EventSystems";
    import { RectTransform, Vector2 } from "UnityEngine";
    class ScrollRect extends UIBehaviour implements IInitializePotentialDragHandler, IDragHandler, IEndDragHandler, ICanvasElement, IScrollHandler, IEventSystemHandler, ILayoutElement, ILayoutController, IBeginDragHandler {
        Rebuild(executing: CanvasUpdate): void
        LayoutComplete(): void
        GraphicUpdateComplete(): void
        IsActive(): boolean
        StopMovement(): void
        OnScroll(data: PointerEventData): void
        OnInitializePotentialDrag(eventData: PointerEventData): void
        OnBeginDrag(eventData: PointerEventData): void
        OnEndDrag(eventData: PointerEventData): void
        OnDrag(eventData: PointerEventData): void
        CalculateLayoutInputHorizontal(): void
        CalculateLayoutInputVertical(): void
        SetLayoutHorizontal(): void
        SetLayoutVertical(): void
        /*protected*/ constructor()
        content: RectTransform
        horizontal: boolean
        vertical: boolean
        movementType: ScrollRect.MovementType
        elasticity: number
        inertia: boolean
        decelerationRate: number
        scrollSensitivity: number
        viewport: RectTransform
        horizontalScrollbar: Scrollbar
        verticalScrollbar: Scrollbar
        horizontalScrollbarVisibility: ScrollRect.ScrollbarVisibility
        verticalScrollbarVisibility: ScrollRect.ScrollbarVisibility
        horizontalScrollbarSpacing: number
        verticalScrollbarSpacing: number
        onValueChanged: ScrollRect.ScrollRectEvent
        velocity: Vector2
        normalizedPosition: Vector2
        horizontalNormalizedPosition: number
        verticalNormalizedPosition: number
        readonly minWidth: number
        readonly preferredWidth: number
        readonly flexibleWidth: number
        readonly minHeight: number
        readonly preferredHeight: number
        readonly flexibleHeight: number
        readonly layoutPriority: number
    }
}
declare module "UnityEngine.UI" {
    import { IInitializePotentialDragHandler, IDragHandler, IEventSystemHandler, IPointerEnterHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IPointerUpHandler, IMoveHandler, IBeginDragHandler, PointerEventData, AxisEventData } from "UnityEngine.EventSystems";
    import { RectTransform } from "UnityEngine";
    class Scrollbar extends Selectable implements IInitializePotentialDragHandler, IDragHandler, ICanvasElement, IEventSystemHandler, IPointerEnterHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IPointerUpHandler, IMoveHandler, IBeginDragHandler {
        SetValueWithoutNotify(input: number): void
        Rebuild(executing: CanvasUpdate): void
        LayoutComplete(): void
        GraphicUpdateComplete(): void
        OnBeginDrag(eventData: PointerEventData): void
        OnDrag(eventData: PointerEventData): void
        OnPointerDown(eventData: PointerEventData): void
        OnPointerUp(eventData: PointerEventData): void
        OnMove(eventData: AxisEventData): void
        FindSelectableOnLeft(): Selectable
        FindSelectableOnRight(): Selectable
        FindSelectableOnUp(): Selectable
        FindSelectableOnDown(): Selectable
        OnInitializePotentialDrag(eventData: PointerEventData): void
        SetDirection(direction: Scrollbar.Direction, includeRectLayouts: boolean): void
        /*protected*/ constructor()
        handleRect: RectTransform
        direction: Scrollbar.Direction
        value: number
        size: number
        numberOfSteps: number
        onValueChanged: Scrollbar.ScrollEvent
    }
}
declare module "UnityEngine.UI" {
    import { IInitializePotentialDragHandler, IDragHandler, IEventSystemHandler, IPointerEnterHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IPointerUpHandler, IMoveHandler, PointerEventData, AxisEventData } from "UnityEngine.EventSystems";
    import { RectTransform } from "UnityEngine";
    class Slider extends Selectable implements IInitializePotentialDragHandler, IDragHandler, ICanvasElement, IEventSystemHandler, IPointerEnterHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IPointerUpHandler, IMoveHandler {
        SetValueWithoutNotify(input: number): void
        Rebuild(executing: CanvasUpdate): void
        LayoutComplete(): void
        GraphicUpdateComplete(): void
        OnPointerDown(eventData: PointerEventData): void
        OnDrag(eventData: PointerEventData): void
        OnMove(eventData: AxisEventData): void
        FindSelectableOnLeft(): Selectable
        FindSelectableOnRight(): Selectable
        FindSelectableOnUp(): Selectable
        FindSelectableOnDown(): Selectable
        OnInitializePotentialDrag(eventData: PointerEventData): void
        SetDirection(direction: Slider.Direction, includeRectLayouts: boolean): void
        /*protected*/ constructor()
        fillRect: RectTransform
        handleRect: RectTransform
        direction: Slider.Direction
        minValue: number
        maxValue: number
        wholeNumbers: boolean
        value: number
        normalizedValue: number
        onValueChanged: Slider.SliderEvent
    }
}
declare module "UnityEngine.UI" {
    import { ValueType } from "System";
    import { Sprite } from "UnityEngine";
    class SpriteState extends ValueType {
        constructor()
        Equals(other: SpriteState): boolean
        highlightedSprite: Sprite
        pressedSprite: Sprite
        selectedSprite: Sprite
        disabledSprite: Sprite
    }
}
declare module "UnityEngine.UI" {
    import { Object, Enum } from "System";
    import { Material } from "UnityEngine";
    abstract class StencilMaterial extends Object {
        static Add(baseMat: Material, stencilID: number, operation: any, compareFunction: any, colorWriteMask: any, readMask: number, writeMask: number): Material
        static Add(baseMat: Material, stencilID: number, operation: any, compareFunction: any, colorWriteMask: any): Material
        static Remove(customMat: Material): void
        static ClearAll(): void
    }
}
declare module "UnityEngine.UI" {
    import { Object, Enum, ValueType } from "System";
    import { Texture, Object as Object1, TextAnchor, Vector2 } from "UnityEngine";
    class Text extends MaskableGraphic implements IMaterialModifier, IMaskable, ICanvasElement, ILayoutElement, IClippable {
        FontTextureChanged(): void
        GetGenerationSettings(extents: Vector2): any
        CalculateLayoutInputHorizontal(): void
        CalculateLayoutInputVertical(): void
        static GetTextAnchorPivot(anchor: TextAnchor): Vector2
        /*protected*/ constructor()
        readonly cachedTextGenerator: any
        readonly cachedTextGeneratorForLayout: any
        readonly mainTexture: Texture
        font: any
        text: string
        supportRichText: boolean
        resizeTextForBestFit: boolean
        resizeTextMinSize: number
        resizeTextMaxSize: number
        alignment: TextAnchor
        alignByGeometry: boolean
        fontSize: number
        horizontalOverflow: any
        verticalOverflow: any
        lineSpacing: number
        fontStyle: any
        readonly pixelsPerUnit: number
        readonly minWidth: number
        readonly preferredWidth: number
        readonly flexibleWidth: number
        readonly minHeight: number
        readonly preferredHeight: number
        readonly flexibleHeight: number
        readonly layoutPriority: number
    }
}
declare module "UnityEngine.UI" {
    import { IEventSystemHandler, IPointerEnterHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IPointerUpHandler, IMoveHandler, ISubmitHandler, IPointerClickHandler, PointerEventData, BaseEventData } from "UnityEngine.EventSystems";
    class Toggle extends Selectable implements ICanvasElement, IEventSystemHandler, IPointerEnterHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IPointerUpHandler, IMoveHandler, ISubmitHandler, IPointerClickHandler {
        Rebuild(executing: CanvasUpdate): void
        LayoutComplete(): void
        GraphicUpdateComplete(): void
        SetIsOnWithoutNotify(value: boolean): void
        OnPointerClick(eventData: PointerEventData): void
        OnSubmit(eventData: BaseEventData): void
        /*protected*/ constructor()
        group: ToggleGroup
        isOn: boolean
        toggleTransition: Toggle.ToggleTransition
        graphic: Graphic
        onValueChanged: Toggle.ToggleEvent
    }
}
declare module "UnityEngine.UI" {
    import { UIBehaviour } from "UnityEngine.EventSystems";
    import { IEnumerable } from "System.Collections.Generic";
    class ToggleGroup extends UIBehaviour {
        NotifyToggleOn(toggle: Toggle, sendCallback: boolean): void
        UnregisterToggle(toggle: Toggle): void
        RegisterToggle(toggle: Toggle): void
        EnsureValidState(): void
        AnyTogglesOn(): boolean
        ActiveToggles(): any
        SetAllTogglesOff(sendCallback: boolean): void
        /*protected*/ constructor()
        allowSwitchOff: boolean
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { Object, Array, ValueType } from "System";
    import { Object as Object1, Vector3, Color32, Vector2, Vector4 } from "UnityEngine";
    import { List } from "System.Collections.Generic";
    class VertexHelper extends Object {
        constructor(m: any)
        constructor()
        Dispose(): void
        Clear(): void
        PopulateUIVertex(vertex: jsb.Ref<any>, i: number): void
        SetUIVertex(vertex: any, i: number): void
        FillMesh(mesh: any): void
        AddVert(position: Vector3, color: Color32, uv0: Vector2, uv1: Vector2, uv2: Vector2, uv3: Vector2, normal: Vector3, tangent: Vector4): void
        AddVert(position: Vector3, color: Color32, uv0: Vector2, uv1: Vector2, normal: Vector3, tangent: Vector4): void
        AddVert(position: Vector3, color: Color32, uv0: Vector2): void
        AddVert(v: any): void
        AddTriangle(idx0: number, idx1: number, idx2: number): void
        AddUIVertexQuad(verts: Array<any>): void
        AddUIVertexStream(verts: any, indices: List<number>): void
        AddUIVertexTriangleStream(verts: any): void
        GetUIVertexStream(stream: any): void
        readonly currentVertCount: number
        readonly currentIndexCount: number
    }
}
declare module "UnityEngine.UI" {
    import { UIBehaviour } from "UnityEngine.EventSystems";
    import { Object } from "UnityEngine";
    abstract class BaseMeshEffect extends UIBehaviour implements IMeshModifier {
        ModifyMesh(mesh: any): void
        ModifyMesh(vh: VertexHelper): void
    }
}
declare module "UnityEngine.UI" {
    interface IMeshModifier {
        ModifyMesh(verts: VertexHelper): void
    }
}
declare module "UnityEngine.UI" {
    class Outline extends Shadow implements IMeshModifier {
        /*protected*/ constructor()
    }
}
declare module "UnityEngine.UI" {
    import { Color, Vector2 } from "UnityEngine";
    class Shadow extends BaseMeshEffect implements IMeshModifier {
        /*protected*/ constructor()
        effectColor: Color
        effectDistance: Vector2
        useGraphicAlpha: boolean
    }
}
declare module "UnityEngine.UI" {
    class PositionAsUV1 extends BaseMeshEffect implements IMeshModifier {
        /*protected*/ constructor()
    }
}
declare module "UnityEngine.EventSystems" {
    import { Vector2 } from "UnityEngine";
    class AxisEventData extends BaseEventData {
        constructor(eventSystem: EventSystem)
        moveVector: Vector2
        moveDir: MoveDirection
    }
}
declare module "UnityEngine.EventSystems" {
    import { GameObject } from "UnityEngine";
    class BaseEventData extends AbstractEventData {
        constructor(eventSystem: EventSystem)
        readonly currentInputModule: BaseInputModule
        selectedObject: GameObject
    }
}
declare module "UnityEngine.EventSystems" {
    import { Object } from "System";
    abstract class AbstractEventData extends Object {
        Reset(): void
        Use(): void
        readonly used: boolean
    }
}
declare module "UnityEngine.EventSystems" {
    import { GameObject, Vector2, Camera } from "UnityEngine";
    import { List } from "System.Collections.Generic";
    import { Object } from "System";
    class PointerEventData extends BaseEventData {
        constructor(eventSystem: EventSystem)
        IsPointerMoving(): boolean
        IsScrolling(): boolean
        toString(): string
        pointerEnter: GameObject
        readonly lastPress: GameObject
        rawPointerPress: GameObject
        pointerDrag: GameObject
        pointerCurrentRaycast: RaycastResult
        pointerPressRaycast: RaycastResult
        eligibleForClick: boolean
        pointerId: number
        position: Vector2
        delta: Vector2
        pressPosition: Vector2
        clickTime: number
        clickCount: number
        scrollDelta: Vector2
        useDragThreshold: boolean
        dragging: boolean
        button: PointerEventData.InputButton
        readonly enterEventCamera: Camera
        readonly pressEventCamera: Camera
        pointerPress: GameObject
        hovered: any
    }
}
declare module "UnityEngine.EventSystems" {
    import { Enum } from "System";
    enum EventHandle {
        Unused = 0,
        Used = 1,
    }
}
declare module "UnityEngine.EventSystems" {
    interface IEventSystemHandler {
    }
}
declare module "UnityEngine.EventSystems" {
    interface IPointerEnterHandler extends IEventSystemHandler {
        OnPointerEnter(eventData: PointerEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    interface IPointerExitHandler extends IEventSystemHandler {
        OnPointerExit(eventData: PointerEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    interface IPointerDownHandler extends IEventSystemHandler {
        OnPointerDown(eventData: PointerEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    interface IPointerUpHandler extends IEventSystemHandler {
        OnPointerUp(eventData: PointerEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    interface IPointerClickHandler extends IEventSystemHandler {
        OnPointerClick(eventData: PointerEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    interface IBeginDragHandler extends IEventSystemHandler {
        OnBeginDrag(eventData: PointerEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    interface IInitializePotentialDragHandler extends IEventSystemHandler {
        OnInitializePotentialDrag(eventData: PointerEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    interface IDragHandler extends IEventSystemHandler {
        OnDrag(eventData: PointerEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    interface IEndDragHandler extends IEventSystemHandler {
        OnEndDrag(eventData: PointerEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    interface IDropHandler extends IEventSystemHandler {
        OnDrop(eventData: PointerEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    interface IScrollHandler extends IEventSystemHandler {
        OnScroll(eventData: PointerEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    interface IUpdateSelectedHandler extends IEventSystemHandler {
        OnUpdateSelected(eventData: BaseEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    interface ISelectHandler extends IEventSystemHandler {
        OnSelect(eventData: BaseEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    interface IDeselectHandler extends IEventSystemHandler {
        OnDeselect(eventData: BaseEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    interface IMoveHandler extends IEventSystemHandler {
        OnMove(eventData: AxisEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    interface ISubmitHandler extends IEventSystemHandler {
        OnSubmit(eventData: BaseEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    interface ICancelHandler extends IEventSystemHandler {
        OnCancel(eventData: BaseEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    import { GameObject } from "UnityEngine";
    import { List } from "System.Collections.Generic";
    import { Object } from "System";
    class EventSystem extends UIBehaviour {
        UpdateModules(): void
        SetSelectedGameObject(selected: GameObject, pointer: BaseEventData): void
        SetSelectedGameObject(selected: GameObject): void
        RaycastAll(eventData: PointerEventData, raycastResults: any): void
        IsPointerOverGameObject(pointerId: number): boolean
        IsPointerOverGameObject(): boolean
        toString(): string
        /*protected*/ constructor()
        static current: EventSystem
        sendNavigationEvents: boolean
        pixelDragThreshold: number
        readonly currentInputModule: BaseInputModule
        firstSelectedGameObject: GameObject
        readonly currentSelectedGameObject: GameObject
        readonly isFocused: boolean
        readonly alreadySelecting: boolean
    }
}
declare module "UnityEngine.EventSystems" {
    import { MonoBehaviour } from "UnityEngine";
    import { List } from "System.Collections.Generic";
    import { Object } from "System";
    class EventTrigger extends MonoBehaviour implements IInitializePotentialDragHandler, IDragHandler, IEndDragHandler, IDropHandler, IScrollHandler, IEventSystemHandler, IUpdateSelectedHandler, IPointerEnterHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IMoveHandler, IPointerUpHandler, ISubmitHandler, IPointerClickHandler, ICancelHandler, IBeginDragHandler {
        OnPointerEnter(eventData: PointerEventData): void
        OnPointerExit(eventData: PointerEventData): void
        OnDrag(eventData: PointerEventData): void
        OnDrop(eventData: PointerEventData): void
        OnPointerDown(eventData: PointerEventData): void
        OnPointerUp(eventData: PointerEventData): void
        OnPointerClick(eventData: PointerEventData): void
        OnSelect(eventData: BaseEventData): void
        OnDeselect(eventData: BaseEventData): void
        OnScroll(eventData: PointerEventData): void
        OnMove(eventData: AxisEventData): void
        OnUpdateSelected(eventData: BaseEventData): void
        OnInitializePotentialDrag(eventData: PointerEventData): void
        OnBeginDrag(eventData: PointerEventData): void
        OnEndDrag(eventData: PointerEventData): void
        OnSubmit(eventData: BaseEventData): void
        OnCancel(eventData: BaseEventData): void
        /*protected*/ constructor()
        triggers: any
    }
}
declare module "UnityEngine.EventSystems" {
    import { Enum } from "System";
    enum EventTriggerType {
        PointerEnter = 0,
        PointerExit = 1,
        PointerDown = 2,
        PointerUp = 3,
        PointerClick = 4,
        Drag = 5,
        Drop = 6,
        Scroll = 7,
        UpdateSelected = 8,
        Select = 9,
        Deselect = 10,
        Move = 11,
        InitializePotentialDrag = 12,
        BeginDrag = 13,
        EndDrag = 14,
        Submit = 15,
        Cancel = 16,
    }
}
declare module "UnityEngine.EventSystems" {
    import { Object } from "System";
    abstract class ExecuteEvents extends Object {
        static pointerEnterHandler(op: "get"): (handler: IPointerEnterHandler, eventData: BaseEventData) => void
        static pointerExitHandler(op: "get"): (handler: IPointerExitHandler, eventData: BaseEventData) => void
        static pointerDownHandler(op: "get"): (handler: IPointerDownHandler, eventData: BaseEventData) => void
        static pointerUpHandler(op: "get"): (handler: IPointerUpHandler, eventData: BaseEventData) => void
        static pointerClickHandler(op: "get"): (handler: IPointerClickHandler, eventData: BaseEventData) => void
        static initializePotentialDrag(op: "get"): (handler: IInitializePotentialDragHandler, eventData: BaseEventData) => void
        static beginDragHandler(op: "get"): (handler: IBeginDragHandler, eventData: BaseEventData) => void
        static dragHandler(op: "get"): (handler: IDragHandler, eventData: BaseEventData) => void
        static endDragHandler(op: "get"): (handler: IEndDragHandler, eventData: BaseEventData) => void
        static dropHandler(op: "get"): (handler: IDropHandler, eventData: BaseEventData) => void
        static scrollHandler(op: "get"): (handler: IScrollHandler, eventData: BaseEventData) => void
        static updateSelectedHandler(op: "get"): (handler: IUpdateSelectedHandler, eventData: BaseEventData) => void
        static selectHandler(op: "get"): (handler: ISelectHandler, eventData: BaseEventData) => void
        static deselectHandler(op: "get"): (handler: IDeselectHandler, eventData: BaseEventData) => void
        static moveHandler(op: "get"): (handler: IMoveHandler, eventData: BaseEventData) => void
        static submitHandler(op: "get"): (handler: ISubmitHandler, eventData: BaseEventData) => void
        static cancelHandler(op: "get"): (handler: ICancelHandler, eventData: BaseEventData) => void
    }
}
declare module "UnityEngine.EventSystems" {
    import { Enum, ValueType } from "System";
    import { Vector2 } from "UnityEngine";
    class BaseInput extends UIBehaviour {
        constructor()
        GetMouseButtonDown(button: number): boolean
        GetMouseButtonUp(button: number): boolean
        GetMouseButton(button: number): boolean
        GetTouch(index: number): any
        GetAxisRaw(axisName: string): number
        GetButtonDown(buttonName: string): boolean
        readonly compositionString: string
        imeCompositionMode: any
        compositionCursorPos: Vector2
        readonly mousePresent: boolean
        readonly mousePosition: Vector2
        readonly mouseScrollDelta: Vector2
        readonly touchSupported: boolean
        readonly touchCount: number
    }
}
declare module "UnityEngine.EventSystems" {
    abstract class BaseInputModule extends UIBehaviour {
        Process(): void
        IsPointerOverGameObject(pointerId: number): boolean
        ShouldActivateModule(): boolean
        DeactivateModule(): void
        ActivateModule(): void
        UpdateModule(): void
        IsModuleSupported(): boolean
        readonly input: BaseInput
        inputOverride: BaseInput
    }
}
declare module "UnityEngine.EventSystems" {
    abstract class PointerInputModule extends BaseInputModule {
        IsPointerOverGameObject(pointerId: number): boolean
        toString(): string
        static readonly kMouseLeftId: number
        static readonly kMouseRightId: number
        static readonly kMouseMiddleId: number
        static readonly kFakeTouchesId: number
    }
}
declare module "UnityEngine.EventSystems" {
    class StandaloneInputModule extends PointerInputModule {
        UpdateModule(): void
        IsModuleSupported(): boolean
        ShouldActivateModule(): boolean
        ActivateModule(): void
        DeactivateModule(): void
        Process(): void
        /*protected*/ constructor()
        forceModuleActive: boolean
        inputActionsPerSecond: number
        repeatDelay: number
        horizontalAxis: string
        verticalAxis: string
        submitButton: string
        cancelButton: string
    }
}
declare module "UnityEngine.EventSystems" {
    import { Enum } from "System";
    enum MoveDirection {
        Left = 0,
        Up = 1,
        Right = 2,
        Down = 3,
        None = 4,
    }
}
declare module "UnityEngine.EventSystems" {
    import { ValueType } from "System";
    import { Vector3, Vector2, GameObject } from "UnityEngine";
    class RaycastResult extends ValueType {
        constructor()
        Clear(): void
        toString(): string
        gameObject: GameObject
        readonly isValid: boolean
        module_: BaseRaycaster
        distance: number
        index: number
        depth: number
        sortingLayer: number
        sortingOrder: number
        worldPosition: Vector3
        worldNormal: Vector3
        screenPosition: Vector2
        displayIndex: number
    }
}
declare module "UnityEngine.EventSystems" {
    import { List } from "System.Collections.Generic";
    import { Object } from "System";
    class Physics2DRaycaster extends PhysicsRaycaster {
        Raycast(eventData: PointerEventData, resultAppendList: any): void
        /*protected*/ constructor()
    }
}
declare module "UnityEngine.EventSystems" {
    import { Camera, LayerMask } from "UnityEngine";
    import { List } from "System.Collections.Generic";
    import { Object } from "System";
    class PhysicsRaycaster extends BaseRaycaster {
        Raycast(eventData: PointerEventData, resultAppendList: any): void
        /*protected*/ constructor()
        readonly eventCamera: Camera
        readonly depth: number
        readonly finalEventMask: number
        eventMask: LayerMask
        maxRayIntersections: number
    }
}
declare module "UnityEngine.UI" {
    import { UnityEvent } from "UnityEngine.Events";
    namespace Button {
        class ButtonClickedEvent extends UnityEvent {
            constructor()
        }
    }
}
declare module "UnityEngine.Events" {
    /** A zero argument persistent callback that can be saved with the Scene.
     */
    class UnityEvent extends UnityEventBase {
        constructor()
        /** Add a non persistent listener to the UnityEvent.
         * @param call Callback function.
         */
        AddListener(call: () => void): void
        /** Remove a non persistent listener from the UnityEvent.
         * @param call Callback function.
         */
        RemoveListener(call: () => void): void
        Invoke(): void
    }
}
declare module "UnityEngine.Events" {
    import * as jsb from "jsb";
    import { Object, Array, Enum } from "System";
    import { Object as Object1 } from "UnityEngine";
    /** Abstract base class for UnityEvents.
     */
    abstract class UnityEventBase extends Object {
        GetPersistentEventCount(): number
        /** Get the target component of the listener at index index.
         * @param index Index of the listener to query.
         */
        GetPersistentTarget(index: number): Object1
        /** Get the target method name of the listener at index index.
         * @param index Index of the listener to query.
         */
        GetPersistentMethodName(index: number): string
        /** Modify the execution state of a persistent listener.
         * @param index Index of the listener to query.
         * @param state State to set.
         */
        SetPersistentListenerState(index: number, state: any): void
        RemoveAllListeners(): void
        toString(): string
        /** Given an object, function name, and a list of argument types; find the method that matches.
         * @param obj Object to search for the method.
         * @param functionName Function name to search for.
         * @param argumentTypes Argument types for the function.
         */
        static GetValidMethodInfo(obj: Object, functionName: string, argumentTypes: Array<any>): any
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { GameObject } from "UnityEngine";
    import { Array, Object } from "System";
    namespace DefaultControls {
        interface IFactoryControls {
            CreateGameObject(name: string, ...components: any[]): GameObject
        }
    }
}
declare module "UnityEngine.UI" {
    import { ValueType } from "System";
    import { Sprite } from "UnityEngine";
    namespace DefaultControls {
        class Resources extends ValueType {
            constructor()
            standard: Sprite
            background: Sprite
            inputField: Sprite
            knob: Sprite
            checkmark: Sprite
            dropdown: Sprite
            mask: Sprite
        }
    }
}
declare module "UnityEngine.UI" {
    import { Object } from "System";
    import { Sprite } from "UnityEngine";
    namespace Dropdown {
        class OptionData extends Object {
            constructor(text: string, image: Sprite)
            constructor(text: string)
            constructor(image: Sprite)
            constructor()
            text: string
            image: Sprite
        }
    }
}
declare module "UnityEngine.UI" {
    import { Object } from "System";
    import { List } from "System.Collections.Generic";
    namespace Dropdown {
        class OptionDataList extends Object {
            constructor()
            options: any
        }
    }
}
declare module "UnityEngine.UI" {
    import { UnityEvent1, UnityEvent } from "UnityEngine.Events";
    namespace Dropdown {
        class DropdownEvent extends UnityEvent1<number> {
            constructor()
        }
    }
}
declare module "UnityEngine.Events" {
    abstract class UnityEvent_Int32 extends UnityEventBase implements UnityEvent1<number> {
        AddListener(call: (id: number) => void): void
        RemoveListener(call: (id: number) => void): void
        Invoke(arg0: number): void
    }
}
declare module "UnityEngine.Events" {
    import { Object } from "System";
    abstract class UnityEvent1<T0> extends UnityEventBase {
        AddListener(call: any): void
        RemoveListener(call: any): void
        Invoke(arg0: T0): void
    }
}
declare module "UnityEngine.UI" {
    import { Enum } from "System";
    namespace GraphicRaycaster {
        enum BlockingObjects {
            None = 0,
            TwoD = 1,
            ThreeD = 2,
            All = 3,
        }
    }
}
declare module "UnityEngine.UI" {
    import { Enum } from "System";
    namespace Image {
        enum Type {
            Simple = 0,
            Sliced = 1,
            Tiled = 2,
            Filled = 3,
        }
    }
}
declare module "UnityEngine.UI" {
    import { Enum } from "System";
    namespace Image {
        enum FillMethod {
            Horizontal = 0,
            Vertical = 1,
            Radial90 = 2,
            Radial180 = 3,
            Radial360 = 4,
        }
    }
}
declare module "UnityEngine.UI" {
    import { Enum } from "System";
    namespace Image {
        enum OriginHorizontal {
            Left = 0,
            Right = 1,
        }
    }
}
declare module "UnityEngine.UI" {
    import { Enum } from "System";
    namespace Image {
        enum OriginVertical {
            Bottom = 0,
            Top = 1,
        }
    }
}
declare module "UnityEngine.UI" {
    import { Enum } from "System";
    namespace Image {
        enum Origin90 {
            BottomLeft = 0,
            TopLeft = 1,
            TopRight = 2,
            BottomRight = 3,
        }
    }
}
declare module "UnityEngine.UI" {
    import { Enum } from "System";
    namespace Image {
        enum Origin180 {
            Bottom = 0,
            Left = 1,
            Top = 2,
            Right = 3,
        }
    }
}
declare module "UnityEngine.UI" {
    import { Enum } from "System";
    namespace Image {
        enum Origin360 {
            Bottom = 0,
            Right = 1,
            Top = 2,
            Left = 3,
        }
    }
}
declare module "UnityEngine.UI" {
    import { Enum } from "System";
    namespace InputField {
        enum ContentType {
            Standard = 0,
            Autocorrected = 1,
            IntegerNumber = 2,
            DecimalNumber = 3,
            Alphanumeric = 4,
            Name = 5,
            EmailAddress = 6,
            Password = 7,
            Pin = 8,
            Custom = 9,
        }
    }
}
declare module "UnityEngine.UI" {
    import { Enum } from "System";
    namespace InputField {
        enum InputType {
            Standard = 0,
            AutoCorrect = 1,
            Password = 2,
        }
    }
}
declare module "UnityEngine.UI" {
    import { Enum } from "System";
    namespace InputField {
        enum CharacterValidation {
            None = 0,
            Integer = 1,
            Decimal = 2,
            Alphanumeric = 3,
            Name = 4,
            EmailAddress = 5,
        }
    }
}
declare module "UnityEngine.UI" {
    import { Enum } from "System";
    namespace InputField {
        enum LineType {
            SingleLine = 0,
            MultiLineSubmit = 1,
            MultiLineNewline = 2,
        }
    }
}
declare module "UnityEngine.UI" {
    import { UnityEvent1, UnityEvent } from "UnityEngine.Events";
    namespace InputField {
        class SubmitEvent extends UnityEvent1<string> {
            constructor()
        }
    }
}
declare module "UnityEngine.Events" {
    abstract class UnityEvent_String extends UnityEventBase implements UnityEvent1<string> {
        AddListener(call: (obj: string) => void): void
        RemoveListener(call: (obj: string) => void): void
        Invoke(arg0: string): void
    }
}
declare module "UnityEngine.UI" {
    import { UnityEvent1, UnityEvent } from "UnityEngine.Events";
    namespace InputField {
        class OnChangeEvent extends UnityEvent1<string> {
            constructor()
        }
    }
}
declare module "UnityEngine.UI" {
    import { Enum } from "System";
    namespace AspectRatioFitter {
        enum AspectMode {
            None = 0,
            WidthControlsHeight = 1,
            HeightControlsWidth = 2,
            FitInParent = 3,
            EnvelopeParent = 4,
        }
    }
}
declare module "UnityEngine.UI" {
    import { Enum } from "System";
    namespace CanvasScaler {
        enum ScaleMode {
            ConstantPixelSize = 0,
            ScaleWithScreenSize = 1,
            ConstantPhysicalSize = 2,
        }
    }
}
declare module "UnityEngine.UI" {
    import { Enum } from "System";
    namespace CanvasScaler {
        enum ScreenMatchMode {
            MatchWidthOrHeight = 0,
            Expand = 1,
            Shrink = 2,
        }
    }
}
declare module "UnityEngine.UI" {
    import { Enum } from "System";
    namespace CanvasScaler {
        enum Unit {
            Centimeters = 0,
            Millimeters = 1,
            Inches = 2,
            Points = 3,
            Picas = 4,
        }
    }
}
declare module "UnityEngine.UI" {
    import { Enum } from "System";
    namespace ContentSizeFitter {
        enum FitMode {
            Unconstrained = 0,
            MinSize = 1,
            PreferredSize = 2,
        }
    }
}
declare module "UnityEngine.UI" {
    import { Enum } from "System";
    namespace GridLayoutGroup {
        enum Corner {
            UpperLeft = 0,
            UpperRight = 1,
            LowerLeft = 2,
            LowerRight = 3,
        }
    }
}
declare module "UnityEngine.UI" {
    import { Enum } from "System";
    namespace GridLayoutGroup {
        enum Axis {
            Horizontal = 0,
            Vertical = 1,
        }
    }
}
declare module "UnityEngine.UI" {
    import { Enum } from "System";
    namespace GridLayoutGroup {
        enum Constraint {
            Flexible = 0,
            FixedColumnCount = 1,
            FixedRowCount = 2,
        }
    }
}
declare module "UnityEngine.UI" {
    import { UnityEvent1, UnityEvent } from "UnityEngine.Events";
    namespace MaskableGraphic {
        class CullStateChangedEvent extends UnityEvent1<boolean> {
            constructor()
        }
    }
}
declare module "UnityEngine.Events" {
    abstract class UnityEvent_Boolean extends UnityEventBase implements UnityEvent1<boolean> {
        AddListener(call: (obj: boolean) => void): void
        RemoveListener(call: (obj: boolean) => void): void
        Invoke(arg0: boolean): void
    }
}
declare module "UnityEngine.UI" {
    import { Enum } from "System";
    namespace Navigation {
        enum Mode {
            None = 0,
            Horizontal = 1,
            Vertical = 2,
            Automatic = 3,
            Explicit = 4,
        }
    }
}
declare module "UnityEngine.UI" {
    import { Enum } from "System";
    namespace ScrollRect {
        enum MovementType {
            Unrestricted = 0,
            Elastic = 1,
            Clamped = 2,
        }
    }
}
declare module "UnityEngine.UI" {
    import { Enum } from "System";
    namespace ScrollRect {
        enum ScrollbarVisibility {
            Permanent = 0,
            AutoHide = 1,
            AutoHideAndExpandViewport = 2,
        }
    }
}
declare module "UnityEngine.UI" {
    import { Vector2 } from "UnityEngine";
    import { UnityEvent1, UnityEvent } from "UnityEngine.Events";
    namespace ScrollRect {
        class ScrollRectEvent extends UnityEvent1<Vector2> {
            constructor()
        }
    }
}
declare module "UnityEngine.Events" {
    import { Vector2 } from "UnityEngine";
    abstract class UnityEvent_Vector2 extends UnityEventBase implements UnityEvent1<Vector2> {
        AddListener(call: (arg0: Vector2) => void): void
        RemoveListener(call: (arg0: Vector2) => void): void
        Invoke(arg0: Vector2): void
    }
}
declare module "UnityEngine.UI" {
    import { Enum } from "System";
    namespace Scrollbar {
        enum Direction {
            LeftToRight = 0,
            RightToLeft = 1,
            BottomToTop = 2,
            TopToBottom = 3,
        }
    }
}
declare module "UnityEngine.UI" {
    import { UnityEvent1, UnityEvent } from "UnityEngine.Events";
    namespace Scrollbar {
        class ScrollEvent extends UnityEvent1<number> {
            constructor()
        }
    }
}
declare module "UnityEngine.Events" {
    abstract class UnityEvent_Single extends UnityEventBase implements UnityEvent1<number> {
        AddListener(call: (arg0: number) => void): void
        RemoveListener(call: (arg0: number) => void): void
        Invoke(arg0: number): void
    }
}
declare module "UnityEngine.UI" {
    import { Enum } from "System";
    namespace Selectable {
        enum Transition {
            None = 0,
            ColorTint = 1,
            SpriteSwap = 2,
            Animation = 3,
        }
    }
}
declare module "UnityEngine.UI" {
    import { Enum } from "System";
    namespace Slider {
        enum Direction {
            LeftToRight = 0,
            RightToLeft = 1,
            BottomToTop = 2,
            TopToBottom = 3,
        }
    }
}
declare module "UnityEngine.UI" {
    import { UnityEvent1, UnityEvent } from "UnityEngine.Events";
    namespace Slider {
        class SliderEvent extends UnityEvent1<number> {
            constructor()
        }
    }
}
declare module "UnityEngine.UI" {
    import { Enum } from "System";
    namespace Toggle {
        enum ToggleTransition {
            None = 0,
            Fade = 1,
        }
    }
}
declare module "UnityEngine.UI" {
    import { UnityEvent1, UnityEvent } from "UnityEngine.Events";
    namespace Toggle {
        class ToggleEvent extends UnityEvent1<boolean> {
            constructor()
        }
    }
}
declare module "UnityEngine.EventSystems" {
    import { Enum } from "System";
    namespace PointerEventData {
        enum InputButton {
            Left = 0,
            Right = 1,
            Middle = 2,
        }
    }
}
declare module "UnityEngine.EventSystems" {
    import { Enum } from "System";
    namespace PointerEventData {
        enum FramePressState {
            Pressed = 0,
            Released = 1,
            PressedAndReleased = 2,
            NotChanged = 3,
        }
    }
}
declare module "UnityEngine.EventSystems" {
    import { UnityEvent1, UnityEvent } from "UnityEngine.Events";
    namespace EventTrigger {
        class TriggerEvent extends UnityEvent1<BaseEventData> {
            constructor()
        }
    }
}
declare module "UnityEngine.Events" {
    import { BaseEventData } from "UnityEngine.EventSystems";
    abstract class UnityEvent_BaseEventData extends UnityEventBase implements UnityEvent1<BaseEventData> {
        AddListener(call: (arg0: BaseEventData) => void): void
        RemoveListener(call: (arg0: BaseEventData) => void): void
        Invoke(arg0: BaseEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    import { Object } from "System";
    namespace EventTrigger {
        class Entry extends Object {
            constructor()
            eventID: EventTriggerType
            callback: EventTrigger.TriggerEvent
        }
    }
}
declare module "UnityEngine.EventSystems" {
    import { Object } from "System";
    namespace PointerInputModule {
        class MouseButtonEventData extends Object {
            constructor()
            PressedThisFrame(): boolean
            ReleasedThisFrame(): boolean
            buttonState: PointerEventData.FramePressState
            buttonData: PointerEventData
        }
    }
}
